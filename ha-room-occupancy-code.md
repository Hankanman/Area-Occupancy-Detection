This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-24T13:36:04.040Z

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Info

For more information about Repomix, visit: https://github.com/yamadashy/repomix

# Repository Structure
```
.devcontainer/configuration.yaml
.devcontainer/devcontainer.json
.flake8
.github/ISSUE_TEMPLATE/bug_report.md
.github/ISSUE_TEMPLATE/config.yml
.github/ISSUE_TEMPLATE/new_feature.md
.github/pull_request_template.md
.github/stale.yml
.github/workflows/black.yml
.github/workflows/hassfest.yaml
.github/workflows/validate.yaml
.gitignore
.pre-commit-config.yaml
.repomixignore
custom_components/__init__.py
custom_components/room_occupancy/__init__.py
custom_components/room_occupancy/binary_sensor.py
custom_components/room_occupancy/config_flow.py
custom_components/room_occupancy/const.py
custom_components/room_occupancy/coordinator.py
custom_components/room_occupancy/manifest.json
custom_components/room_occupancy/probability.py
custom_components/room_occupancy/sensor.py
custom_components/room_occupancy/strings.json
custom_components/room_occupancy/translations/en.json
hacs.json
LICENSE
README.md
repomix.config.json
requirements.dev.txt
requirements.txt
scripts/setup
scripts/start
scripts/sync
scripts/upgrade-dev
scripts/upgrade-version
setup.cfg
testing-guide.md
```

# Repository Files

## File: .devcontainer/configuration.yaml
```yaml
# Loads default set of integrations. Do not remove.
default_config:

# Load frontend themes from the themes folder
frontend:
  themes: !include_dir_merge_named themes

automation: !include automations.yaml
script: !include scripts.yaml
scene: !include scenes.yaml

logger:
  default: CRITICAL
  logs:
    custom_components.room_occupancy: debug

debugpy:

# Input controls for testing
input_boolean:
  # Motion sensor controls
  mock_motion_1:
    name: Mock Motion Sensor 1
    initial: off
  mock_motion_2:
    name: Mock Motion Sensor 2
    initial: off
  mock_motion_3:
    name: Mock Motion Sensor 3
    initial: off

  # Device state controls
  mock_tv:
    name: Mock TV State
    initial: off
  mock_computer:
    name: Mock Computer State
    initial: off
  mock_game_console:
    name: Mock Game Console State
    initial: off
  mock_lights:
    name: Mock Room Lights
    initial: off

input_number:
  # Environmental sensor controls
  mock_illuminance_1:
    name: Mock Illuminance 1
    min: 0
    max: 1000
    step: 1
    initial: 100
  mock_illuminance_2:
    name: Mock Illuminance 2
    min: 0
    max: 1000
    step: 1
    initial: 100

  mock_temperature_1:
    name: Mock Temperature 1
    min: 15
    max: 30
    step: 0.1
    initial: 21
  mock_temperature_2:
    name: Mock Temperature 2
    min: 15
    max: 30
    step: 0.1
    initial: 21

  mock_humidity_1:
    name: Mock Humidity 1
    min: 0
    max: 100
    step: 1
    initial: 50
  mock_humidity_2:
    name: Mock Humidity 2
    min: 0
    max: 100
    step: 1
    initial: 50

# Template sensors that simulate real devices
binary_sensor:
  - platform: template
    sensors:
      # Motion sensors
      motion_sensor_1:
        friendly_name: "Motion Sensor 1"
        device_class: motion
        value_template: "{{ states('input_boolean.mock_motion_1') }}"
        availability_template: "true"

      motion_sensor_2:
        friendly_name: "Motion Sensor 2"
        device_class: motion
        value_template: "{{ states('input_boolean.mock_motion_2') }}"
        availability_template: "true"

      motion_sensor_3:
        friendly_name: "Motion Sensor 3"
        device_class: motion
        value_template: "{{ states('input_boolean.mock_motion_3') }}"
        availability_template: "{{ now().second < 50 }}" # Simulates periodic unavailability

      # Device power states
      tv_power_sensor:
        friendly_name: "TV Power State"
        device_class: power
        value_template: "{{ states('input_boolean.mock_tv') }}"

      computer_power_sensor:
        friendly_name: "Computer Power State"
        device_class: power
        value_template: "{{ states('input_boolean.mock_computer') }}"

      game_console_power_sensor:
        friendly_name: "Game Console Power State"
        device_class: power
        value_template: "{{ states('input_boolean.mock_game_console') }}"

sensor:
  - platform: template
    sensors:
      # Illuminance sensors
      illuminance_sensor_1:
        friendly_name: "Illuminance Sensor 1"
        device_class: illuminance
        unit_of_measurement: "lx"
        value_template: "{{ states('input_number.mock_illuminance_1') | float }}"

      illuminance_sensor_2:
        friendly_name: "Illuminance Sensor 2"
        device_class: illuminance
        unit_of_measurement: "lx"
        value_template: "{{ states('input_number.mock_illuminance_2') | float }}"
        availability_template: "{{ now().minute < 55 }}" # Simulates periodic unavailability

      # Temperature sensors
      temperature_sensor_1:
        friendly_name: "Temperature Sensor 1"
        device_class: temperature
        unit_of_measurement: "°C"
        value_template: "{{ states('input_number.mock_temperature_1') | float }}"

      temperature_sensor_2:
        friendly_name: "Temperature Sensor 2"
        device_class: temperature
        unit_of_measurement: "°C"
        value_template: "{{ states('input_number.mock_temperature_2') | float }}"

      # Humidity sensors
      humidity_sensor_1:
        friendly_name: "Humidity Sensor 1"
        device_class: humidity
        unit_of_measurement: "%"
        value_template: "{{ states('input_number.mock_humidity_1') | float }}"

      humidity_sensor_2:
        friendly_name: "Humidity Sensor 2"
        device_class: humidity
        unit_of_measurement: "%"
        value_template: "{{ states('input_number.mock_humidity_2') | float }}"

      # Composite sensors
      room_activity_level:
        friendly_name: "Room Activity Level"
        unit_of_measurement: "%"
        value_template: >
          {% set motion = states('input_boolean.mock_motion_1') == 'on'
             or states('input_boolean.mock_motion_2') == 'on'
             or states('input_boolean.mock_motion_3') == 'on' %}
          {% set devices = states('input_boolean.mock_tv') == 'on'
             or states('input_boolean.mock_computer') == 'on'
             or states('input_boolean.mock_game_console') == 'on' %}
          {% set activity = 0 %}
          {% if motion %}
            {% set activity = activity + 60 %}
          {% endif %}
          {% if devices %}
            {% set activity = activity + 40 %}
          {% endif %}
          {{ activity }}

# Media Player mock
media_player:
  - platform: template
    media_players:
      room_tv:
        friendly_name: "Room TV"
        value_template: >
          {% if states('input_boolean.mock_tv') == 'on' %}
            playing
          {% else %}
            off
          {% endif %}
        turn_on:
          service: input_boolean.turn_on
          data:
            entity_id: input_boolean.mock_tv
        turn_off:
          service: input_boolean.turn_off
          data:
            entity_id: input_boolean.mock_tv
```

## File: .devcontainer/devcontainer.json
```json
// See https://aka.ms/vscode-remote/devcontainer.json for format details.
{
  "image": "mcr.microsoft.com/devcontainers/python:0-3.11",
  "name": "Room Occupancy Development",
  "containerUser": "root",
  "remoteUser": "1000",
  "appPort": [
    "9123:8123"
  ],
  "forwardPorts": [
    9123
  ],
  "portsAttributes": {
    "9123": {
      "label": "HomeAssistant port",
      "protocol": "http",
      "onAutoForward": "notify"
    }
  },
  "customizations": {
    // Configure properties specific to VS Code.
    "vscode": {
      "settings": {
        "files.eol": "\n",
        "editor.tabSize": 4,
        "editor.insertSpaces": true,
        "python.pythonPath": "/usr/bin/python3",
        "python.analysis.autoSearchPaths": false,
        "python.linting.pylintEnabled": true,
        "python.linting.enabled": true,
        "python.formatting.provider": "black",
        "editor.formatOnPaste": false,
        "editor.formatOnSave": true,
        "editor.formatOnType": true,
        "files.trimTrailingWhitespace": true
      },
      "extensions": [
        "ms-python.python",
        "GitHub.copilot",
        "ryanluker.vscode-coverage-gutters",
        "ms-python.vscode-pylance",
        "ms-python.pylint"
      ]
    }
  },
  "postCreateCommand": "mkdir -p /workspace/.haconfig && cp /workspace/.devcontainer/configuration.yaml /workspace/.haconfig && scripts/setup",
"mounts": [
    "type=bind,source=${localWorkspaceFolder},target=/workspace,consistency=cached"
]
}
```

## File: .flake8
```
[flake8]
max-line-length = 88
select = C,E,F,W,B,B950
extend-ignore = E203, E501

exclude = # don't bother looking in the following subdirectories / files.
	.git,
	__pycache__,
	assets,
	.github,

filename =
	*.py,
	*.pyw
```

## File: .github/ISSUE_TEMPLATE/bug_report.md
```markdown
---
name: Bug report
about: Create a report to let us know of any issues you encountered
labels: new bug
assignees: kartoffeltoby
---

### Prerequisites

* [ ] Model name of your Devices
* [ ] Output from Home Assistant Developer Tools state e.g.
* [ ] Output from Home Assistant Device Diagnostic from BT

```json
{
  YOUR DEVICE DIAGNOSTICS JSON OUTPUT HERE
}
```

### Description

<!-- Description of the issue -->

### Steps to Reproduce

1. <!-- First Step -->
2. <!-- Second Step -->
3. <!-- and so on… -->

**Expected behavior:**

<!-- What you expect to happen -->

**Actual behavior:**

<!-- What happens -->

### Versions

<!-- Provide both, HA and BT version -->

### Additional Information

<!-- Any additional information, configuration, or data that might be necessary to reproduce the issue. -->
```

## File: .github/ISSUE_TEMPLATE/config.yml
```yaml
blank_issues_enabled: false
contact_links:
  - name: Report a bug with the UI, Frontend
    url: https://github.com/KartoffelToby/better-thermostat-ui-card/issues
    about: This is the issue tracker for our backend. Please report issues with the UI in the frontend repository.
  - name: I have a question or need support
    url: https://github.com/KartoffelToby/better_thermostat/discussions
    about: You can checkout GitHub discussions, or join our discord for getting help.
  - name: I'm unsure where to go
    url: https://discord.gg/9BUegWTG3K
    about: If you are unsure where to go, then joining our discord; Just ask!
```

## File: .github/ISSUE_TEMPLATE/new_feature.md
```markdown
---
name: new feature
about: Create a new feature request
labels: feature
assignees: kartoffeltoby
---

## What is the feature?

### Description

<!-- Description of the issue -->


### Additional Information

<!-- Any additional information, configuration, or data that might be necessary to reproduce the issue. -->
```

## File: .github/pull_request_template.md
```markdown
## Motivation:

## Changes:

## Related issue (check one):

- [ ] fixes #<issue number goes here>
- [ ] there is no related issue ticket

## Checklist (check one):

- [ ] I did not change any code (e.g. documentation changes)
- [ ] The code change is tested and works locally.

## Test-Hardware list (for code changes)

<!-- Please specify your hardware/software which was used to test the code locally: -->

HA Version:
Zigbee2MQTT Version:
TRV Hardware:

## New device mappings

<!-- If there was a new device mapping added, please make sure to fill in this checklist: -->

- [ ] I avoided any changes to other device mappings
- [ ] There are no changes in `climate.py`

<!-- If you did change the `climate.py` please create a dedicated PR for this. -->
```

## File: .github/stale.yml
```yaml
# Number of days of inactivity before an issue becomes stale
daysUntilStale: 60
# Number of days of inactivity before a stale issue is closed
daysUntilClose: false
# Issues with these labels will never be considered stale
exemptLabels:
  - pinned
# Label to use when marking an issue as stale
staleLabel: stale
# Comment to post when marking an issue as stale. Set to `false` to disable
markComment: >
  This issue has been automatically marked as stale because it has not had
  recent activity.
# Comment to post when closing a stale issue. Set to `false` to disable
closeComment: false

# Limit the number of actions per hour, from 1-30. Default is 30
limitPerRun: 1

# Limit to only `issues` or `pulls`
only: issues
```

## File: .github/workflows/black.yml
```yaml
name: Lint

on: [push, pull_request]

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
        with:
          options: "--check --verbose --skip-magic-trailing-comma --target-version py310"
      - uses: psf/black@stable
```

## File: .github/workflows/hassfest.yaml
```yaml
name: Validate with hassfest

on:
  push:
  pull_request:
  schedule:
    - cron: "0 0 * * *"

jobs:
  validate:
    runs-on: "ubuntu-latest"
    steps:
      - uses: "actions/checkout@v2"
      - uses: home-assistant/actions/hassfest@master
```

## File: .github/workflows/validate.yaml
```yaml
name: Validate

on:
  push:
  pull_request:
  schedule:
    - cron: "0 0 * * *"

jobs:
  validate:
    runs-on: "ubuntu-latest"
    steps:
      - uses: "actions/checkout@v2"
      - name: HACS validation
        uses: "hacs/action@main"
        with:
          category: "integration"
```

## File: .gitignore
```
.jekyll-cache/
_site/
__pycache__
pythonenv*
venv
.venv
.coverage
.idea
custom_components/hacs
x_*
.haconfig
```

## File: .pre-commit-config.yaml
```yaml
repos:
  - repo: https://github.com/asottile/pyupgrade
    rev: v2.37.3
    hooks:
      - id: pyupgrade
        args: [--py311-plus]
  - repo: https://github.com/psf/black
    rev: 24.1.1
    hooks:
      - id: black
        args:
          - --safe
          - --quiet
          - --verbose 
          - --skip-magic-trailing-comma 
          - --target-version
          - py312
        files: ''
  - repo: https://github.com/PyCQA/flake8
    rev: 4.0.1
    hooks:
      - id: flake8
        additional_dependencies:
          - pycodestyle==2.8.0
          - pyflakes==2.4.0
          - flake8-docstrings==1.6.0
          - pydocstyle==6.1.1
          - flake8-comprehensions==3.10.0
          - flake8-noqa==1.2.8
          - mccabe==0.6.1
        files: ''
```

## File: .repomixignore
```
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/
```

## File: custom_components/__init__.py
```python
"""Custom components module."""
```

## File: custom_components/room_occupancy/__init__.py
```python
"""The Room Occupancy Detection integration."""

from __future__ import annotations

import logging

from homeassistant.config_entries import ConfigEntry
from homeassistant.const import Platform
from homeassistant.core import HomeAssistant

from .const import DOMAIN
from .coordinator import RoomOccupancyCoordinator

_LOGGER = logging.getLogger(__name__)

PLATFORMS = [Platform.SENSOR, Platform.BINARY_SENSOR]


async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
    """Set up Room Occupancy Detection from a config entry."""
    hass.data.setdefault(DOMAIN, {})

    # Initialize the coordinator
    coordinator = RoomOccupancyCoordinator(
        hass,
        entry.entry_id,
        entry.data,
    )

    # Fetch initial data
    await coordinator.async_config_entry_first_refresh()

    # Store coordinator in hass.data
    hass.data[DOMAIN][entry.entry_id] = {"coordinator": coordinator}

    # Set up platforms
    await hass.config_entries.async_forward_entry_setups(entry, PLATFORMS)

    return True


async def async_unload_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
    """Unload a config entry."""
    unload_ok = await hass.config_entries.async_unload_platforms(entry, PLATFORMS)
    if unload_ok:
        hass.data[DOMAIN].pop(entry.entry_id)

    return unload_ok
```

## File: custom_components/room_occupancy/binary_sensor.py
```python
"""Binary sensor platform for Room Occupancy Detection integration."""

from __future__ import annotations

import logging
from dataclasses import dataclass
from typing import Any

from homeassistant.components.binary_sensor import (
    BinarySensorDeviceClass,
    BinarySensorEntity,
    BinarySensorEntityDescription,
)
from homeassistant.config_entries import ConfigEntry
from homeassistant.core import HomeAssistant
from homeassistant.helpers.entity_platform import AddEntitiesCallback
from homeassistant.helpers.update_coordinator import CoordinatorEntity

from .const import (
    ATTR_ACTIVE_TRIGGERS,
    ATTR_CONFIDENCE_SCORE,
    ATTR_DECAY_STATUS,
    ATTR_PRIOR_PROBABILITY,
    ATTR_PROBABILITY,
    ATTR_SENSOR_AVAILABILITY,
    ATTR_SENSOR_PROBABILITIES,
    CONF_THRESHOLD,
    DEFAULT_THRESHOLD,
    DOMAIN,
    NAME_BINARY_SENSOR,
)
from .coordinator import RoomOccupancyCoordinator

_LOGGER = logging.getLogger(__name__)


@dataclass
class RoomOccupancyBinaryEntityDescription(BinarySensorEntityDescription):
    """Class describing Room Occupancy binary sensor entities."""

    def __init__(self) -> None:
        """Initialize the description."""
        super().__init__(
            key="occupancy_status",
            name=NAME_BINARY_SENSOR,
            device_class=BinarySensorDeviceClass.OCCUPANCY,
        )


class RoomOccupancyBinarySensor(CoordinatorEntity, BinarySensorEntity):
    """Representation of a Room Occupancy binary sensor."""

    entity_description: RoomOccupancyBinaryEntityDescription
    _attr_has_entity_name = True
    _attr_device_class = BinarySensorDeviceClass.OCCUPANCY

    def __init__(
        self,
        coordinator: RoomOccupancyCoordinator,
        entry_id: str,
        description: RoomOccupancyBinaryEntityDescription,
        threshold: float,
    ) -> None:
        """Initialize the binary sensor."""
        super().__init__(coordinator)
        self._attr_unique_id = f"{entry_id}_occupancy"
        self.entity_description = description
        self._attr_name = NAME_BINARY_SENSOR
        self._threshold = threshold

    @property
    def is_on(self) -> bool | None:
        """Return true if the room is occupied."""
        if self.coordinator.data is None:
            return None
        return self.coordinator.data.get("probability", 0.0) >= self._threshold

    @property
    def extra_state_attributes(self) -> dict[str, Any]:
        """Return additional sensor state attributes."""
        if self.coordinator.data is None:
            return {}

        return {
            ATTR_PROBABILITY: self.coordinator.data.get("probability", 0.0),
            ATTR_PRIOR_PROBABILITY: self.coordinator.data.get("prior_probability", 0.0),
            ATTR_ACTIVE_TRIGGERS: self.coordinator.data.get("active_triggers", []),
            ATTR_SENSOR_PROBABILITIES: self.coordinator.data.get(
                "sensor_probabilities", {}
            ),
            ATTR_DECAY_STATUS: self.coordinator.data.get("decay_status", {}),
            ATTR_CONFIDENCE_SCORE: self.coordinator.data.get("confidence_score", 0.0),
            ATTR_SENSOR_AVAILABILITY: self.coordinator.data.get(
                "sensor_availability", {}
            ),
        }

    @property
    def available(self) -> bool:
        """Return True if entity is available."""
        return (
            self.coordinator.last_update_success and self.coordinator.data is not None
        )


async def async_setup_entry(
    hass: HomeAssistant,
    entry: ConfigEntry,
    async_add_entities: AddEntitiesCallback,
) -> None:
    """Set up Room Occupancy binary sensor based on a config entry."""
    coordinator = hass.data[DOMAIN][entry.entry_id]["coordinator"]
    threshold = entry.data.get(CONF_THRESHOLD, DEFAULT_THRESHOLD)

    async_add_entities(
        [
            RoomOccupancyBinarySensor(
                coordinator,
                entry.entry_id,
                RoomOccupancyBinaryEntityDescription(),
                threshold,
            )
        ]
    )
```

## File: custom_components/room_occupancy/config_flow.py
```python
"""Config flow for Room Occupancy Detection integration."""

from __future__ import annotations

import logging
from typing import Any

import voluptuous as vol

from homeassistant import config_entries
from homeassistant.const import CONF_NAME
from homeassistant.data_entry_flow import FlowResult
from homeassistant.helpers import selector

from .const import (
    CONF_MOTION_SENSORS,
    CONF_ILLUMINANCE_SENSORS,
    CONF_HUMIDITY_SENSORS,
    CONF_TEMPERATURE_SENSORS,
    CONF_DEVICE_STATES,
    CONF_THRESHOLD,
    CONF_HISTORY_PERIOD,
    CONF_DECAY_ENABLED,
    CONF_DECAY_WINDOW,
    CONF_DECAY_TYPE,
    DEFAULT_THRESHOLD,
    DEFAULT_HISTORY_PERIOD,
    DEFAULT_DECAY_ENABLED,
    DEFAULT_DECAY_WINDOW,
    DEFAULT_DECAY_TYPE,
    DOMAIN,
)

_LOGGER = logging.getLogger(__name__)


class RoomOccupancyConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):
    """Handle a config flow for Room Occupancy Detection."""

    VERSION = 1

    async def async_step_user(
        self, user_input: dict[str, Any] | None = None
    ) -> FlowResult:
        """Handle the initial step."""
        errors = {}

        if user_input is not None:
            # Validate the input
            try:
                # Check if entry already exists
                await self.async_set_unique_id(user_input[CONF_NAME])
                self._abort_if_unique_id_configured()

                return self.async_create_entry(
                    title=user_input[CONF_NAME],
                    data=user_input,
                )
            except (ValueError, KeyError) as error:
                _LOGGER.exception("Unexpected error occurred: %s", error)
                errors["base"] = "unknown"

        return self.async_show_form(
            step_id="user",
            data_schema=vol.Schema(
                {
                    vol.Required(CONF_NAME): str,
                    vol.Required(CONF_MOTION_SENSORS): selector.EntitySelector(
                        selector.EntitySelectorConfig(
                            domain="binary_sensor",
                            device_class="motion",
                            multiple=True,
                        ),
                    ),
                    vol.Optional(CONF_ILLUMINANCE_SENSORS): selector.EntitySelector(
                        selector.EntitySelectorConfig(
                            domain="sensor",
                            device_class="illuminance",
                            multiple=True,
                        ),
                    ),
                    vol.Optional(CONF_HUMIDITY_SENSORS): selector.EntitySelector(
                        selector.EntitySelectorConfig(
                            domain="sensor",
                            device_class="humidity",
                            multiple=True,
                        ),
                    ),
                    vol.Optional(CONF_TEMPERATURE_SENSORS): selector.EntitySelector(
                        selector.EntitySelectorConfig(
                            domain="sensor",
                            device_class="temperature",
                            multiple=True,
                        ),
                    ),
                    vol.Optional(CONF_DEVICE_STATES): selector.EntitySelector(
                        selector.EntitySelectorConfig(multiple=True),
                    ),
                    vol.Optional(
                        CONF_THRESHOLD, default=DEFAULT_THRESHOLD
                    ): selector.NumberSelector(
                        selector.NumberSelectorConfig(
                            min=0.0,
                            max=1.0,
                            step=0.05,
                            mode="slider",
                        ),
                    ),
                    vol.Optional(
                        CONF_HISTORY_PERIOD, default=DEFAULT_HISTORY_PERIOD
                    ): selector.NumberSelector(
                        selector.NumberSelectorConfig(
                            min=1,
                            max=30,
                            step=1,
                            mode="slider",
                            unit_of_measurement="days",
                        ),
                    ),
                    vol.Optional(
                        CONF_DECAY_ENABLED, default=DEFAULT_DECAY_ENABLED
                    ): bool,
                    vol.Optional(
                        CONF_DECAY_WINDOW, default=DEFAULT_DECAY_WINDOW
                    ): selector.NumberSelector(
                        selector.NumberSelectorConfig(
                            min=60,
                            max=3600,
                            step=60,
                            mode="slider",
                            unit_of_measurement="seconds",
                        ),
                    ),
                    vol.Optional(
                        CONF_DECAY_TYPE, default=DEFAULT_DECAY_TYPE
                    ): selector.SelectSelector(
                        selector.SelectSelectorConfig(
                            options=["linear", "exponential"],
                            mode="dropdown",
                        ),
                    ),
                }
            ),
            errors=errors,
        )
```

## File: custom_components/room_occupancy/const.py
```python
"""Constants for the Room Occupancy Detection integration."""
from typing import Final

DOMAIN: Final = "room_occupancy"

# Configuration constants
CONF_MOTION_SENSORS = "motion_sensors"
CONF_ILLUMINANCE_SENSORS = "illuminance_sensors"
CONF_HUMIDITY_SENSORS = "humidity_sensors"
CONF_TEMPERATURE_SENSORS = "temperature_sensors"
CONF_DEVICE_STATES = "device_states"
CONF_THRESHOLD = "threshold"
CONF_HISTORY_PERIOD = "history_period"
CONF_DECAY_ENABLED = "decay_enabled"
CONF_DECAY_WINDOW = "decay_window"
CONF_DECAY_TYPE = "decay_type"

# Default values
DEFAULT_THRESHOLD = 0.5
DEFAULT_HISTORY_PERIOD = 7  # days
DEFAULT_DECAY_ENABLED = True
DEFAULT_DECAY_WINDOW = 600  # seconds (10 minutes)
DEFAULT_DECAY_TYPE = "linear"

# Attributes
ATTR_PROBABILITY = "probability"
ATTR_PRIOR_PROBABILITY = "prior_probability"
ATTR_ACTIVE_TRIGGERS = "active_triggers"
ATTR_SENSOR_PROBABILITIES = "sensor_probabilities"
ATTR_DECAY_STATUS = "decay_status"
ATTR_CONFIDENCE_SCORE = "confidence_score"
ATTR_SENSOR_AVAILABILITY = "sensor_availability"

# Entity naming
NAME_PROBABILITY_SENSOR = "Room Occupancy Probability"
NAME_BINARY_SENSOR = "Room Occupancy Status"
```

## File: custom_components/room_occupancy/coordinator.py
```python
"""Data coordinator for Room Occupancy Detection integration."""

from __future__ import annotations

from datetime import datetime, timedelta
import logging
from typing import Any

from homeassistant.const import (
    STATE_ON,
    STATE_UNAVAILABLE,
    STATE_UNKNOWN,
)
from homeassistant.core import HomeAssistant, State, callback

from homeassistant.helpers.event import async_track_state_change_event
from homeassistant.helpers.update_coordinator import DataUpdateCoordinator
import numpy as np

from .const import (
    DOMAIN,
    CONF_MOTION_SENSORS,
    CONF_ILLUMINANCE_SENSORS,
    CONF_HUMIDITY_SENSORS,
    CONF_TEMPERATURE_SENSORS,
    CONF_DEVICE_STATES,
    CONF_DECAY_ENABLED,
    CONF_DECAY_WINDOW,
    CONF_DECAY_TYPE,
)
from .probability import BayesianProbability

_LOGGER = logging.getLogger(__name__)


class RoomOccupancyCoordinator(DataUpdateCoordinator):
    """Class to manage fetching Room Occupancy data."""

    def __init__(
        self,
        hass: HomeAssistant,
        entry_id: str,
        config: dict[str, Any],
    ) -> None:
        """Initialize the coordinator."""
        super().__init__(
            hass,
            _LOGGER,
            name=DOMAIN,
            update_interval=timedelta(seconds=10),
        )
        self.entry_id = entry_id
        self.config = config
        self.bayesian = BayesianProbability()
        self._sensor_states: dict[str, State] = {}
        self._last_trigger_times: dict[str, datetime] = {}
        self._setup_sensor_tracking()

    def _setup_sensor_tracking(self) -> None:
        """Set up state tracking for all configured sensors."""
        sensors_to_track = []

        # Add all configured sensors to tracking
        for sensor_type in [
            CONF_MOTION_SENSORS,
            CONF_ILLUMINANCE_SENSORS,
            CONF_HUMIDITY_SENSORS,
            CONF_TEMPERATURE_SENSORS,
            CONF_DEVICE_STATES,
        ]:
            if sensor_type in self.config:
                sensors_to_track.extend(self.config[sensor_type])

        # Set up state tracking for each sensor
        @callback
        def async_state_changed_listener(event) -> None:
            """Handle sensor state changes."""
            self._sensor_states[event.data["entity_id"]] = event.data["new_state"]
            self._last_trigger_times[event.data["entity_id"]] = datetime.now()
            self.async_set_updated_data(self._calculate_occupancy())

        async_track_state_change_event(
            self.hass,
            sensors_to_track,
            async_state_changed_listener,
        )

        # Initialize current states
        for entity_id in sensors_to_track:
            state = self.hass.states.get(entity_id)
            if state is not None:
                self._sensor_states[entity_id] = state
                self._last_trigger_times[entity_id] = datetime.now()

    def _calculate_decay(self, sensor_id: str, last_trigger: datetime) -> float:
        """Calculate the decay factor for a sensor based on time since last trigger.

        Args:
            sensor_id: The entity ID of the sensor
            last_trigger: The datetime of the last sensor trigger

        Returns:
            float: Decay factor between 0 and 1
        """
        if not self.config.get(CONF_DECAY_ENABLED, True):
            return 1.0

        # Get sensor-specific decay window if configured, otherwise use default
        decay_window = self.config.get(
            f"decay_window_{sensor_id}", self.config.get(CONF_DECAY_WINDOW, 600)
        )

        time_diff = (datetime.now() - last_trigger).total_seconds()

        if time_diff >= decay_window:
            return 0.0

        if self.config.get(CONF_DECAY_TYPE, "linear") == "linear":
            return 1.0 - (time_diff / decay_window)
        else:  # exponential
            return np.exp(-3.0 * time_diff / decay_window)

    def _get_sensor_probability(self, sensor_id: str, state: State) -> float:
        """Calculate the probability contribution from a single sensor."""
        if state.state in (STATE_UNAVAILABLE, STATE_UNKNOWN):
            return 0.0

        # Apply different probability calculations based on sensor type
        if sensor_id in self.config.get(CONF_MOTION_SENSORS, []):
            prob = 0.95 if state.state == STATE_ON else 0.05
        elif sensor_id in self.config.get(CONF_ILLUMINANCE_SENSORS, []):
            try:
                value = float(state.state)
                # Simple threshold-based probability for illuminance
                prob = 0.7 if value > 10 else 0.3
            except ValueError:
                return 0.0
        elif sensor_id in self.config.get(CONF_HUMIDITY_SENSORS, []):
            try:
                # Compare against historical average if available
                value = float(state.state)
                prob = 0.6  # Default probability for now
            except ValueError:
                return 0.0
        elif sensor_id in self.config.get(CONF_TEMPERATURE_SENSORS, []):
            try:
                # Compare against historical average if available
                value = float(state.state)
                prob = 0.6  # Default probability for now
            except ValueError:
                return 0.0
        elif sensor_id in self.config.get(CONF_DEVICE_STATES, []):
            prob = 0.8 if state.state == STATE_ON else 0.2
        else:
            return 0.0

        # Apply decay factor
        decay = self._calculate_decay(sensor_id, self._last_trigger_times[sensor_id])
        return prob * decay

    def _calculate_occupancy(self) -> dict[str, Any]:
        """Calculate room occupancy probability using Bayesian inference."""
        sensor_probabilities = {}
        active_triggers = []
        sensor_availability = {}

        # Calculate individual sensor probabilities
        for sensor_id, state in self._sensor_states.items():
            probability = self._get_sensor_probability(sensor_id, state)
            sensor_probabilities[sensor_id] = probability

            if probability > 0.5:  # Consider as active trigger
                active_triggers.append(sensor_id)

            sensor_availability[sensor_id] = state.state not in (
                STATE_UNAVAILABLE,
                STATE_UNKNOWN,
            )

        # Calculate final probability using Bayesian inference
        if not sensor_probabilities:
            final_probability = 0.0
        else:
            final_probability = self.bayesian.calculate_probability(
                list(sensor_probabilities.values())
            )

        # Calculate confidence score based on sensor availability and diversity
        available_sensors = sum(sensor_availability.values())
        total_sensors = len(sensor_availability)
        confidence_score = (
            available_sensors / total_sensors if total_sensors > 0 else 0.0
        )

        return {
            "probability": final_probability,
            "sensor_probabilities": sensor_probabilities,
            "active_triggers": active_triggers,
            "decay_status": {
                sensor_id: self._calculate_decay(
                    sensor_id, self._last_trigger_times[sensor_id]
                )
                for sensor_id in self._sensor_states
            },
            "confidence_score": confidence_score,
            "sensor_availability": sensor_availability,
        }

    async def _async_update_data(self) -> dict[str, Any]:
        """Update data via library."""
        return self._calculate_occupancy()
```

## File: custom_components/room_occupancy/manifest.json
```json
{
  "domain": "room_occupancy",
  "name": "Room Occupancy Detection",
  "documentation": "https://github.com/Hankanman/Room-Occupancy-Detection",
  "issue_tracker": "https://github.com/Hankanman/Room-Occupancy-Detection/issues",
  "dependencies": ["statistics", "sensor", "binary_sensor"],
  "codeowners": ["@Hankanman"],
  "requirements": [],
  "iot_class": "calculated",
  "version": "0.0.1-dev",
  "config_flow": true,
  "quality_scale": "internal"
}
```

## File: custom_components/room_occupancy/probability.py
```python
"""Bayesian probability calculations for Room Occupancy Detection."""

from __future__ import annotations

import logging
from typing import List
import numpy as np

_LOGGER = logging.getLogger(__name__)


class BayesianProbability:
    """Class to handle Bayesian probability calculations."""

    def __init__(self) -> None:
        """Initialize the probability calculator."""
        self._prior = 0.5  # Start with a neutral prior

    def update_prior(self, prior: float) -> None:
        """Update the prior probability."""
        self._prior = max(0.0, min(1.0, prior))

    def _odds(self, p: float) -> float:
        """Convert probability to odds."""
        return p / (1 - p) if p != 1 else float("inf")

    def _probability(self, o: float) -> float:
        """Convert odds to probability."""
        return o / (1 + o) if o != float("inf") else 1

    def calculate_probability(self, probabilities: List[float]) -> float:
        """
        Calculate the combined probability using Bayesian inference.

        Args:
            probabilities: List of individual probabilities from different sensors

        Returns:
            Combined probability as a float between 0 and 1
        """
        if not probabilities:
            return self._prior

        try:
            # Start with the prior odds
            combined_odds = self._odds(self._prior)

            # Multiply by likelihood ratios
            for p in probabilities:
                if 0 < p < 1:  # Avoid division by zero or infinity
                    combined_odds *= self._odds(p)

            # Convert back to probability
            return self._probability(combined_odds)

        except (ZeroDivisionError, ValueError) as err:
            _LOGGER.error("Error calculating probability: %s", err)
            return self._prior

    def calculate_weighted_probability(
        self, probabilities: List[float], weights: List[float]
    ) -> float:
        """
        Calculate weighted probability using Bayesian inference.

        Args:
            probabilities: List of individual probabilities
            weights: List of weights corresponding to each probability

        Returns:
            Weighted combined probability as a float between 0 and 1
        """
        if not probabilities or not weights or len(probabilities) != len(weights):
            return self._prior

        try:
            # Normalize weights
            weights = np.array(weights)
            weights = weights / np.sum(weights)

            # Calculate weighted log odds
            weighted_odds = self._odds(self._prior)
            for p, w in zip(probabilities, weights):
                if 0 < p < 1:
                    weighted_odds *= self._odds(p) ** w

            return self._probability(weighted_odds)

        except (ZeroDivisionError, ValueError) as err:
            _LOGGER.error("Error calculating weighted probability: %s", err)
            return self._prior
```

## File: custom_components/room_occupancy/sensor.py
```python
"""Sensor platform for Room Occupancy Detection integration."""

from __future__ import annotations

import logging
from dataclasses import dataclass
from typing import Any

from homeassistant.components.sensor import (
    SensorDeviceClass,
    SensorEntity,
    SensorEntityDescription,
)
from homeassistant.config_entries import ConfigEntry
from homeassistant.const import PERCENTAGE
from homeassistant.core import HomeAssistant
from homeassistant.helpers.entity_platform import AddEntitiesCallback
from homeassistant.helpers.typing import StateType
from homeassistant.helpers.update_coordinator import CoordinatorEntity

from .const import (
    ATTR_ACTIVE_TRIGGERS,
    ATTR_CONFIDENCE_SCORE,
    ATTR_DECAY_STATUS,
    ATTR_PRIOR_PROBABILITY,
    ATTR_PROBABILITY,
    ATTR_SENSOR_AVAILABILITY,
    ATTR_SENSOR_PROBABILITIES,
    DOMAIN,
    NAME_PROBABILITY_SENSOR,
)
from .coordinator import RoomOccupancyCoordinator

_LOGGER = logging.getLogger(__name__)


@dataclass
class RoomOccupancyEntityDescription(SensorEntityDescription):
    """Class describing Room Occupancy sensor entities."""

    def __init__(self) -> None:
        """Initialize the description."""
        super().__init__(
            key="occupancy_probability",
            name=NAME_PROBABILITY_SENSOR,
            device_class=SensorDeviceClass.POWER_FACTOR,
            native_unit_of_measurement=PERCENTAGE,
        )


class RoomOccupancyProbabilitySensor(CoordinatorEntity, SensorEntity):
    """Representation of a Room Occupancy Probability sensor."""

    entity_description: RoomOccupancyEntityDescription
    _attr_has_entity_name = True
    _attr_native_unit_of_measurement = PERCENTAGE
    _attr_device_class = SensorDeviceClass.POWER_FACTOR

    def __init__(
        self,
        coordinator: RoomOccupancyCoordinator,
        entry_id: str,
        description: RoomOccupancyEntityDescription,
    ) -> None:
        """Initialize the sensor."""
        super().__init__(coordinator)
        self._attr_unique_id = f"{entry_id}_probability"
        self.entity_description = description
        self._attr_name = NAME_PROBABILITY_SENSOR

    @property
    def native_value(self) -> StateType:
        """Return the probability value."""
        if self.coordinator.data is None:
            return None
        return round(self.coordinator.data.get("probability", 0.0) * 100, 1)

    @property
    def extra_state_attributes(self) -> dict[str, Any]:
        """Return additional sensor state attributes."""
        if self.coordinator.data is None:
            return {}

        return {
            ATTR_PROBABILITY: self.coordinator.data.get("probability", 0.0),
            ATTR_PRIOR_PROBABILITY: self.coordinator.data.get("prior_probability", 0.0),
            ATTR_ACTIVE_TRIGGERS: self.coordinator.data.get("active_triggers", []),
            ATTR_SENSOR_PROBABILITIES: self.coordinator.data.get(
                "sensor_probabilities", {}
            ),
            ATTR_DECAY_STATUS: self.coordinator.data.get("decay_status", {}),
            ATTR_CONFIDENCE_SCORE: self.coordinator.data.get("confidence_score", 0.0),
            ATTR_SENSOR_AVAILABILITY: self.coordinator.data.get(
                "sensor_availability", {}
            ),
        }


async def async_setup_entry(
    hass: HomeAssistant,
    entry: ConfigEntry,
    async_add_entities: AddEntitiesCallback,
) -> None:
    """Set up Room Occupancy sensor based on a config entry."""
    coordinator = hass.data[DOMAIN][entry.entry_id]["coordinator"]

    async_add_entities(
        [
            RoomOccupancyProbabilitySensor(
                coordinator,
                entry.entry_id,
                RoomOccupancyEntityDescription(),
            )
        ]
    )
```

## File: custom_components/room_occupancy/strings.json
```json
{
    "config": {
        "step": {
            "user": {
                "title": "Room Occupancy Detection Setup",
                "description": "Configure room occupancy detection using multiple sensors",
                "data": {
                    "name": "Room Name",
                    "motion_sensors": "Motion Sensors",
                    "illuminance_sensors": "Illuminance Sensors",
                    "humidity_sensors": "Humidity Sensors",
                    "temperature_sensors": "Temperature Sensors",
                    "device_states": "Device States",
                    "threshold": "Occupancy Threshold",
                    "history_period": "Historical Data Period",
                    "decay_enabled": "Enable Sensor Decay",
                    "decay_window": "Decay Time Window",
                    "decay_type": "Decay Type"
                }
            }
        },
        "error": {
            "unknown": "Unexpected error occurred"
        },
        "abort": {
            "already_configured": "This room is already configured"
        }
    }
}
```

## File: custom_components/room_occupancy/translations/en.json
```json
{
    "config": {
        "step": {
            "user": {
                "title": "Room Occupancy Detection Setup",
                "description": "Configure room occupancy detection using multiple sensors",
                "data": {
                    "name": "Enter a name for this room",
                    "motion_sensors": "Select motion sensors for this room",
                    "illuminance_sensors": "Select illuminance sensors (optional)",
                    "humidity_sensors": "Select humidity sensors (optional)",
                    "temperature_sensors": "Select temperature sensors (optional)",
                    "device_states": "Select device states to monitor (optional)",
                    "threshold": "Probability threshold for occupancy (0-1)",
                    "history_period": "Number of days of historical data to analyze",
                    "decay_enabled": "Enable sensor reading decay over time",
                    "decay_window": "Time window for sensor decay (seconds)",
                    "decay_type": "Select decay calculation type"
                }
            }
        },
        "error": {
            "unknown": "Unexpected error occurred during setup"
        },
        "abort": {
            "already_configured": "This room is already configured in Home Assistant"
        }
    },
    "entity": {
        "sensor": {
            "room_occupancy_probability": {
                "name": "Room Occupancy Probability"
            }
        },
        "binary_sensor": {
            "room_occupancy_status": {
                "name": "Room Occupancy Status"
            }
        }
    }
}
```

## File: hacs.json
```json
{
    "name": "Room Occupancy Detection",
    "render_readme": true,
    "domains": ["binary_sensor", "sensor"],
    "homeassistant": "2024.1.0",
    "iot_class": "calculated"
}
```

## File: LICENSE
```
MIT License

Copyright (c) 2024 Seb Burrell

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## File: README.md
```markdown
# Room Occupancy Integration - Developer Guide

## Table of Contents

- [Development Environment Setup](#development-environment-setup)
- [Installation for Development](#installation-for-development)
- [Project Structure](#project-structure)
- [Testing](#testing)
- [Contributing Guidelines](#contributing-guidelines)
- [Debugging](#debugging)
- [Configuration Reference](#configuration-reference)
- [Common Issues](#common-issues)

## Development Environment Setup

### Prerequisites

- Python 3.10 or higher
- Home Assistant development environment
- Git
- Visual Studio Code (recommended)
- Docker (optional, for container-based development)

### Setting Up Local Development Environment

1. Create a virtual environment:

```bash
python -m venv venv
source venv/bin/activate  # Linux/macOS
.\venv\Scripts\activate   # Windows
```

2. Install development dependencies:

```bash
pip install -r requirements_dev.txt
```

3. Install pre-commit hooks:

```bash
pre-commit install
```

## Installation for Development

### Method 1: Direct Installation

1. Clone the repository:

```bash
git clone https://github.com/yourusername/ha-room-occupancy.git
```

2. Create symbolic link:

```bash
# Linux/macOS
ln -s /path/to/ha-room-occupancy/custom_components/room_occupancy /path/to/homeassistant/config/custom_components/room_occupancy

# Windows (as administrator)
mklink /D C:\path\to\homeassistant\config\custom_components\room_occupancy C:\path\to\ha-room-occupancy\custom_components\room_occupancy
```

3. Restart Home Assistant

### Method 2: Using HACS for Development

1. Add repository to HACS as custom repository:

   - Category: Integration
   - URL: Your repository URL
   - Branch: dev (or your development branch)

2. Install through HACS interface

3. Restart Home Assistant

## Project Structure

```bash
custom_components/room_occupancy/
├── __init__.py           # Integration initialization
├── manifest.json         # Integration metadata
├── const.py             # Constants and configuration
├── config_flow.py       # Configuration UI
├── coordinator.py       # Data update coordinator
├── probability.py       # Bayesian calculations
├── sensor.py           # Probability sensor
├── binary_sensor.py    # Occupancy sensor
├── strings.json        # String resources
└── translations/       # Localization
    └── en.json        # English translations
```

## Testing

### Setting Up Test Environment

1. Install test dependencies:

```bash
pip install -r requirements_test.txt
```

2. Install pytest-homeassistant-custom-component:

```bash
pip install pytest-homeassistant-custom-component
```

### Running Tests

1. Run all tests:

```bash
pytest tests/
```

2. Run specific test file:

```bash
pytest tests/test_sensor.py
```

3. Run with coverage:

```bash
pytest tests/ --cov=custom_components.room_occupancy
```

### Test Structure

```bash
tests/
├── conftest.py                  # Test fixtures
├── test_init.py                # Integration tests
├── test_config_flow.py         # Configuration tests
├── test_coordinator.py         # Coordinator tests
├── test_probability.py         # Probability calculation tests
├── test_sensor.py             # Probability sensor tests
└── test_binary_sensor.py      # Binary sensor tests
```

### Writing Tests

Example test case:

```python
async def test_sensor_probability_calculation(hass):
    """Test probability calculation with multiple sensors."""
    entry = MockConfigEntry(
        domain=DOMAIN,
        data={
            "name": "Test Room",
            "motion_sensors": ["binary_sensor.motion"],
            "threshold": 0.5,
        },
    )

    entry.add_to_hass(hass)
    assert await hass.config_entries.async_setup(entry.entry_id)
    await hass.async_block_till_done()

    # Test sensor states and calculations
    hass.states.async_set("binary_sensor.motion", "on")
    await hass.async_block_till_done()

    state = hass.states.get("sensor.room_occupancy_probability")
    assert state
    assert float(state.state) > 90.0  # High probability when motion detected
```

## Contributing Guidelines

### Code Style

- Follow Home Assistant's code style guidelines
- Use black for code formatting
- Use isort for import sorting
- Maintain pylint score above 9/10

### Pull Request Process

1. Create feature branch from dev
2. Write tests for new functionality
3. Update documentation
4. Submit PR against dev branch
5. Ensure all checks pass
6. Request review

## Debugging

### Enable Debug Logging

Add to configuration.yaml:

```yaml
logger:
  default: info
  logs:
    custom_components.room_occupancy: debug
```

### Common Debug Points

1. Probability Calculation:

```python
_LOGGER.debug(
    "Calculating probability - sensors: %s, values: %s",
    sensor_probabilities.keys(),
    sensor_probabilities.values()
)
```

2. Sensor Updates:

```python
_LOGGER.debug(
    "Sensor update - entity: %s, state: %s",
    entity_id,
    new_state.state
)
```

### Using Remote Debugger

1. Install debugpy:

```bash
pip install debugpy
```

2. Add breakpoint in code:

```python
import debugpy
debugpy.listen(5678)
debugpy.wait_for_client()
```

3. Connect using VS Code debug configuration

## Configuration Reference

### Configuration Options

| Option              | Type   | Default  | Description            |
| ------------------- | ------ | -------- | ---------------------- |
| name                | string | Required | Room name              |
| motion_sensors      | list   | Required | Motion sensor entities |
| illuminance_sensors | list   | Optional | Light level sensors    |
| humidity_sensors    | list   | Optional | Humidity sensors       |
| temperature_sensors | list   | Optional | Temperature sensors    |
| device_states       | list   | Optional | Device state entities  |
| threshold           | float  | 0.5      | Occupancy threshold    |
| history_period      | int    | 7        | Days of history        |
| decay_enabled       | bool   | true     | Enable sensor decay    |
| decay_window        | int    | 600      | Decay window (seconds) |
| decay_type          | string | "linear" | Decay calculation type |

### Entity Attributes

```python
attributes = {
    "probability": 0.85,          # Current probability
    "prior_probability": 0.5,     # Prior probability
    "active_triggers": ["sensor.motion_1"],  # Active sensors
    "sensor_probabilities": {     # Individual probabilities
        "sensor.motion_1": 0.95,
        "sensor.illuminance_1": 0.7
    },
    "decay_status": {            # Decay values
        "sensor.motion_1": 0.8
    },
    "confidence_score": 0.9,     # Calculation confidence
    "sensor_availability": {     # Sensor status
        "sensor.motion_1": true
    }
}
```

## Common Issues

### Installation Issues

1. **Integration Not Appearing**

   - Check custom_components folder structure
   - Verify manifest.json contents
   - Clear browser cache
   - Restart Home Assistant

2. **Configuration Fails**
   - Verify sensor entity IDs exist
   - Check sensor permissions
   - Review Home Assistant logs

### Runtime Issues

1. **High CPU Usage**

   - Increase update interval
   - Reduce number of sensors
   - Check sensor update frequency

2. **Incorrect Probability**
   - Verify sensor states
   - Check decay settings
   - Review probability calculations
   - Enable debug logging

### Troubleshooting Steps

1. Enable debug logging
2. Check sensor states
3. Verify configuration
4. Review system resources
5. Check entity availability
6. Analyze probability calculations
7. Test with minimal configuration

---

## Release Process

1. Version Bump

   - Update manifest.json version
   - Update CHANGELOG.md
   - Create release tag

2. Testing

   - Run full test suite
   - Perform manual testing
   - Test upgrade path

3. Documentation

   - Update README.md
   - Update integration documentation
   - Update example configurations

4. Release
   - Create GitHub release
   - Update HACS repository
   - Notify users of update

## Performance Optimization

### Memory Usage

- Limit historical data storage
- Clean up unused state data
- Optimize data structures

### CPU Usage

- Implement caching where appropriate
- Optimize calculation frequency
- Use efficient algorithms

### Network Usage

- Batch sensor updates
- Implement rate limiting
- Optimize update intervals

## Security Considerations

1. Data Handling

   - Sanitize user inputs
   - Validate configuration data
   - Handle sensitive data appropriately

2. Integration Security

   - Verify sensor permissions
   - Validate entity access
   - Handle errors securely

3. Best Practices
   - Follow OWASP guidelines
   - Implement proper error handling
   - Use secure default values
```

## File: repomix.config.json
```json
{
  "output": {
    "filePath": "ha-room-occupancy-code.md",
    "style": "markdown",
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  }
}
```

## File: requirements.dev.txt
```
homeassistant
pre-commit
black
codespell
ruff
yamllint
flake8
numpy
voluptuous
```

## File: requirements.txt
```
# Production dependencies
numpy
voluptuous
```

## File: scripts/setup
```
#!/usr/bin/env bash

set -e

cd "$(dirname "$0")/.."

python3 -m pip install --requirement requirements.dev.txt
```

## File: scripts/start
```
#!/usr/bin/env bash

set -e

cd "$(dirname "$0")/.."

# Create config dir if not present
if [[ ! -d "${PWD}/.haconfig" ]]; then
    mkdir -p "${PWD}/.haconfig"
    hass --config "${PWD}/.haconfig" --script ensure_config
fi

# Set the path to custom_components
## This let's us have the structure we want <root>/custom_components/integration_blueprint
## while at the same time have Home Assistant configuration inside <root>/config
## without resulting to symlinks.
export PYTHONPATH="${PYTHONPATH}:${PWD}/custom_components"

# Start Home Assistant
hass --config "${PWD}/.haconfig" --debug
```

## File: scripts/sync
```
#!/usr/bin/env bash

set -e

cd "$(dirname "$0")/.."

echo "Syncing configuration.yaml"

cp -f .devcontainer/configuration.yaml ${PWD}/.haconfig/configuration.yaml

echo "Done. Restart Home Assistant to see changes."
```

## File: scripts/upgrade-dev
```
#!/usr/bin/env bash

set -e

cd "$(dirname "$0")/.."

python3 -m pip install homeassistant

echo "Done."
```

## File: scripts/upgrade-version
```
#!/usr/bin/env bash

set -e

read -p "What HA Version? " VERSION
echo "Installing ${my_var}!"


cd "$(dirname "$0")/.."

python3 -m pip install homeassistant==$VERSION

echo "Done."
```

## File: setup.cfg
```
[flake8]
exclude = .venv,.git,.tox,docs,venv,bin,lib,deps,build
doctests = True
# To work with Black
max-line-length = 88
# E501: line too long
# W503: Line break occurred before a binary operator
# E203: Whitespace before ':'
# D202 No blank lines allowed after function docstring
# W504 line break after binary operator
ignore =
    E501,
    W503,
    E203,
    D202,
    W504

[isort]
# https://github.com/timothycrosley/isort
# https://github.com/timothycrosley/isort/wiki/isort-Settings
# splits long import on multiple lines indented by 4 spaces
multi_line_output = 3
include_trailing_comma=True
force_grid_wrap=0
use_parentheses=True
line_length=88
indent = "    "
# by default isort don't check module indexes
not_skip = __init__.py
# will group `import x` and `from x import` of the same module.
force_sort_within_sections = true
sections = FUTURE,STDLIB,INBETWEENS,THIRDPARTY,FIRSTPARTY,LOCALFOLDER
default_section = THIRDPARTY
known_first_party = custom_components.better_thermostat, tests
combine_as_imports = true
```

## File: testing-guide.md
```markdown
# Testing Guide for Room Occupancy Integration

## Local Testing Setup

### 1. Create Testing Environment

```bash
# Create a virtual environment
python -m venv venv

# Activate virtual environment
source venv/bin/activate  # Linux/macOS
.\venv\Scripts\activate   # Windows

# Install development dependencies
pip install -r requirements_dev.txt
```

### 2. Directory Structure for Testing

Create the following directory structure in your project:

```
room_occupancy/
├── custom_components/
│   └── room_occupancy/
│       ├── __init__.py
│       ├── manifest.json
│       └── ... (other component files)
├── tests/
│   ├── __init__.py
│   ├── conftest.py
│   └── ... (test files)
├── requirements.txt
└── requirements_dev.txt
```

### 3. Configure pytest

Create `pytest.ini` in the root directory:

```ini
[pytest]
testpaths = tests
norecursedirs = .git custom_components
asyncio_mode = auto
```

### 4. Running Tests Without Home Assistant

The `pytest-homeassistant-custom-component` package provides a mock Home Assistant environment for testing. Here's how to use it:

#### Basic Test Running

```bash
# Run all tests
pytest

# Run specific test file
pytest tests/test_sensor.py

# Run with coverage report
pytest --cov=custom_components.room_occupancy
```

#### Test Configuration

In your `conftest.py`, add these fixtures for mock Home Assistant setup:

```python
import pytest
from unittest.mock import patch
from homeassistant.core import HomeAssistant
from homeassistant.setup import async_setup_component

@pytest.fixture
def hass(loop):
    """Fixture to provide a test instance of Home Assistant."""
    hass = HomeAssistant()
    loop.run_until_complete(async_setup_component(hass, "homeassistant", {}))
    return hass

@pytest.fixture
def mock_hass_config():
    """Fixture to mock Home Assistant configuration."""
    return {
        "homeassistant": {
            "name": "Test Home",
            "latitude": 0,
            "longitude": 0,
            "elevation": 0,
            "unit_system": "metric",
            "time_zone": "UTC",
        }
    }
```

### 5. Writing Tests with Mock Components

Example of testing with mock entities:

```python
async def test_sensor_behavior(hass):
    """Test sensor behavior with mock entities."""
    # Set up mock motion sensor
    hass.states.async_set("binary_sensor.motion", "off")
    
    # Configure integration
    entry = MockConfigEntry(
        domain="room_occupancy",
        data={
            "name": "Test Room",
            "motion_sensors": ["binary_sensor.motion"]
        }
    )
    entry.add_to_hass(hass)
    
    # Initialize integration
    assert await hass.config_entries.async_setup(entry.entry_id)
    await hass.async_block_till_done()
    
    # Test sensor behavior
    hass.states.async_set("binary_sensor.motion", "on")
    await hass.async_block_till_done()
    
    state = hass.states.get("sensor.test_room_occupancy_probability")
    assert state is not None
    assert float(state.state) > 50  # Probability should be high with motion
```

### 6. Mocking External Dependencies

Example of mocking coordinator updates:

```python
from unittest.mock import patch

async def test_coordinator_update(hass):
    """Test coordinator update with mocked data."""
    with patch(
        "custom_components.room_occupancy.coordinator.RoomOccupancyCoordinator._async_update_data",
        return_value={"probability": 0.75}
    ):
        # Test code here
        pass
```

### 7. Testing Config Flow

Example of testing configuration flow:

```python
async def test_config_flow(hass):
    """Test the config flow."""
    result = await hass.config_entries.flow.async_init(
        DOMAIN, context={"source": config_entries.SOURCE_USER}
    )
    
    assert result["type"] == "form"
    assert result["errors"] == {}
    
    # Test form submission
    result2 = await hass.config_entries.flow.async_configure(
        result["flow_id"],
        {
            "name": "Test Room",
            "motion_sensors": ["binary_sensor.motion"]
        }
    )
    
    assert result2["type"] == "create_entry"
```

## Common Testing Patterns

### 1. Testing State Changes

```python
async def test_state_changes(hass):
    """Test response to state changes."""
    # Initial setup
    await setup_integration(hass)
    
    # Change states
    hass.states.async_set("binary_sensor.motion", "on")
    await hass.async_block_till_done()
    
    # Assert expected behavior
    state = hass.states.get("sensor.room_occupancy_probability")
    assert state is not None
```

### 2. Testing Time-Based Behavior

```python
from freezegun import freeze_time

async def test_decay(hass):
    """Test time-based decay."""
    await setup_integration(hass)
    
    with freeze_time("2024-01-01 12:00:00"):
        # Initial state
        hass.states.async_set("binary_sensor.motion", "on")
        await hass.async_block_till_done()
        initial_state = hass.states.get("sensor.room_occupancy_probability")
        
    with freeze_time("2024-01-01 12:05:00"):
        # 5 minutes later
        await hass.async_block_till_done()
        later_state = hass.states.get("sensor.room_occupancy_probability")
        
        assert float(later_state.state) < float(initial_state.state)
```

### 3. Testing Error Conditions

```python
async def test_error_handling(hass):
    """Test error handling."""
    with patch(
        "custom_components.room_occupancy.coordinator.RoomOccupancyCoordinator._async_update_data",
        side_effect=Exception("Test error")
    ):
        # Test error handling code
        pass
```

## Tips for Testing

1. Use `async_block_till_done()` after state changes
2. Mock time-dependent functions using `freeze_time`
3. Test both success and failure paths
4. Use coverage reports to identify untested code
5. Test edge cases and error conditions
6. Mock external dependencies consistently

## Running Tests in CI

Add this GitHub Actions workflow for automated testing:

```yaml
name: Tests

on: [push, pull_request]

jobs:
  tests:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.10", "3.11"]

    steps:
    - uses: actions/checkout@v3
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements_dev.txt
    - name: Run tests
      run: |
        pytest --cov=custom_components.room_occupancy
    - name: Upload coverage
      uses: codecov/codecov-action@v3
```
```
