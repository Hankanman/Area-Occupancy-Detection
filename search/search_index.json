{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Area Occupancy Detection Documentation","text":"<p>Area Occupancy Detection aims to improve occupancy accuracy beyond single motion detectors by considering various environmental factors, device states, and historical data. It uses Bayesian probability to calculate the likelihood of an area being occupied based on multiple sensor inputs and learned patterns.</p> <p></p>"},{"location":"#features","title":"Features","text":""},{"location":"#core-features","title":"Core Features","text":"<ul> <li>Bayesian Probability Calculation: Uses learned sensor reliability to calculate occupancy probability</li> <li>Dual-Model Approach: Separates presence indicators (80% weight) from environmental support (20% weight) for more accurate results</li> <li>Historical Learning: Automatically learns from your sensor history to improve accuracy</li> <li>Probability Decay: Gradually reduces probability when no activity is detected</li> <li>Multiple Sensor Types: Supports motion, media, door, window, cover, appliance, and environmental sensors (temperature, humidity, illuminance, CO2, sound pressure, atmospheric pressure, air quality, VOC, PM2.5, PM10)</li> <li>Wasp in Box: Special logic for rooms with single entry/exit points</li> <li>All Areas Aggregation: Automatically aggregates occupancy data across all configured areas for whole-home detection</li> </ul>"},{"location":"#advanced-features","title":"Advanced Features","text":"<ul> <li>Activity Detection: Identifies what activity is happening in a room (showering, cooking, watching TV, sleeping, etc.)</li> <li>Sleep Presence Detection: Detects when people are sleeping using HA Person entities and phone sleep confidence</li> <li>Sensor Likelihoods: Learns how reliable each sensor is for occupancy detection</li> <li>Purpose-Based Configuration: Automatic configuration based on room purpose</li> </ul>"},{"location":"#user-interface","title":"User Interface","text":"<ul> <li>Services: Available service calls for automation and control</li> <li>Entities: Created entities and their attributes</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#installation","title":"Installation","text":"<ul> <li>Installation Guide: How to install the integration via HACS or manual installation</li> </ul>"},{"location":"#configuration","title":"Configuration","text":"<ul> <li>Configuration Guide: Step-by-step configuration instructions</li> <li>Basic Usage: How to use the integration after setup</li> </ul>"},{"location":"#key-concepts","title":"Key Concepts","text":""},{"location":"#bayesian-probability","title":"Bayesian Probability","text":"<p>The integration uses Bayes' theorem to update occupancy probability based on sensor evidence:</p> <ol> <li>Prior Belief: Baseline probability of occupancy (learned from history)</li> <li>Sensor Evidence: Current state of configured sensors</li> <li>Likelihood: How reliable each sensor is (learned from history)</li> <li>Posterior: Updated probability after considering new evidence</li> </ol>"},{"location":"#sensor-types","title":"Sensor Types","text":"<p>The integration supports multiple sensor types with different default weights:</p> <ul> <li>Motion Sensors (1.00): Highest reliability, ground truth for occupancy detection</li> <li>Sleep (0.90): Very high reliability for overnight occupancy</li> <li>Media Devices (0.85): High reliability indicator of active use</li> <li>Wasp in Box (0.80): High reliability virtual sensor for single-entry rooms</li> <li>Cover Sensors (0.50): Moderate reliability for blinds, shades, shutters, garage doors</li> <li>Appliances (0.40): Moderate reliability</li> <li>Door Sensors (0.30): Lower reliability, but useful for entry/exit</li> <li>Power Sensors (0.30): Power consumption indicating active device usage</li> <li>Window Sensors (0.20): Minimal influence</li> <li>Environmental Sensors (0.10): Very low influence (temperature, humidity, illuminance, CO2, sound pressure, atmospheric pressure, air quality, VOC, PM2.5, PM10)</li> </ul>"},{"location":"#example-use-cases","title":"Example Use Cases","text":""},{"location":"#living-room","title":"Living Room","text":"<ul> <li>Sensors: Motion sensors, TV, door sensors</li> <li>Patterns: High occupancy in evenings, low during work hours</li> <li>Automation: Turn on lights when occupied, dim when low probability</li> </ul>"},{"location":"#office","title":"Office","text":"<ul> <li>Sensors: Motion sensors, computer, door sensors</li> <li>Patterns: High occupancy during work hours, low on weekends</li> <li>Automation: Turn on/off lights based on occupancy, adjust HVAC</li> </ul>"},{"location":"#bathroom","title":"Bathroom","text":"<ul> <li>Sensors: Motion sensors, door sensors</li> <li>Wasp in Box: Maintain occupancy when door is closed</li> <li>Automation: Turn on lights when occupied, turn off when unoccupied</li> </ul>"},{"location":"#challenges-with-basic-motion-sensors","title":"Challenges with Basic Motion Sensors","text":"<ul> <li>Lights turning off while you're still: If you sit still for too long, a basic motion sensor assumes the room is empty.</li> <li>False triggers: A pet walking through might trigger occupancy.</li> <li>Limited context: Simple motion doesn't know if you're watching TV, working at a desk, or just passing through.</li> </ul>"},{"location":"#how-area-occupancy-detection-helps","title":"How Area Occupancy Detection Helps","text":"<p>This integration provides enhanced room occupancy detection for Home Assistant by intelligently combining data from multiple sensor inputs. Unlike simple motion sensors, it leverages Bayesian probability calculations to factor in various environmental cues and device states, leading to more accurate and resilient occupancy detection.</p> <ul> <li>Increased Accuracy: By fusing data from multiple sensor types (motion, doors, media, etc.), the system gains a much richer understanding of the area's status.</li> <li>Probabilistic Approach: Instead of a simple ON/OFF state, it calculates an occupancy probability. You decide how certain the system must be before declaring occupancy.</li> <li>Adaptability: The prior probability learning feature analyses how your sensors correlate with actual occupancy, learning which sensors are reliable indicators.</li> <li>Reduced False Negatives/Positives: The combination of multi-sensor input, learned probabilities and decay logic significantly reduces incorrect occupancy states.</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Multi-Sensor Fusion: Combines inputs from motion/occupancy sensors, media players, doors, windows, covers, appliances, power sensors, sleep presence, and environmental sensors (temperature, humidity, illuminance, CO2, sound pressure, atmospheric pressure, air quality, VOC, PM2.5, PM10).</li> <li>Bayesian Inference: Calculates the probability of occupancy based on the current state of configured sensors and their individual learned likelihoods.</li> <li>Prior Probability Learning: Automatically learns how sensor states relate to actual occupancy (using motion sensors as ground truth) over a configurable history period.</li> <li>Configurable Weights: Assign weights to different sensor types to influence their impact on the overall probability.</li> <li>Probability Decay: Gradually decreases the occupancy probability when sensors indicate inactivity, providing a natural transition to \"unoccupied\".</li> <li>Purpose-Based Decay: Choosing a room purpose automatically sets a decay half life suited to the space.</li> <li>Configurable Threshold: Define the probability percentage required to consider the area \"occupied\".</li> <li>Exposed Entities:</li> <li>Occupancy Probability Sensor (%) - per area and aggregated \"All Areas\"</li> <li>Occupancy Status Binary Sensor (on/off) - per area and aggregated \"All Areas\"</li> <li>Presence Confidence Sensor (%) - per area and aggregated \"All Areas\"</li> <li>Environmental Confidence Sensor (%) - per area and aggregated \"All Areas\"</li> <li>Prior Probability Sensor (%) - per area and aggregated \"All Areas\"</li> <li>Evidence Sensor - per area only</li> <li>Decay Status Sensor (%) - per area and aggregated \"All Areas\"</li> <li>Detected Activity Sensor (enum) - per area only</li> <li>Activity Confidence Sensor (%) - per area only</li> <li>Sleeping Binary Sensor (on/off) - per area only (when people configured)</li> <li>Occupancy Threshold Number Input - per area only</li> <li>All Areas Aggregation: Automatically creates aggregated entities across all configured areas for whole-home occupancy detection.</li> <li>UI Configuration: Easy setup and management through the Home Assistant UI.</li> <li>Manual Prior Update Service: Trigger the prior learning process on demand.</li> </ul>"},{"location":"#how-it-works","title":"How It Works","text":"<ol> <li>Configuration: You select various sensors associated with an area (motion, doors, media players, etc.) and configure parameters like weights and the history period for learning.</li> <li>Prior Learning: The integration analyses the history of your selected sensors against all configured motion sensors. It calculates:</li> <li>P(Sensor Active | Area Occupied): How likely is a sensor to be active when the area is truly occupied?</li> <li>P(Sensor Active | Area Not Occupied): How likely is a sensor to be active when the area is not occupied?</li> <li>P(Area Occupied): The baseline (prior) probability of the area being occupied, derived from motion sensor history.      These learned probabilities (or defaults if history is insufficient) are stored and used in calculations.</li> <li>Real-time Calculation: As your sensor states change, the integration uses Bayes' theorem. For each active sensor, it updates the probability of occupancy based on its learned likelihoods and the overall prior probability.</li> <li>Weighted Combination: The contributions from individual active sensors are combined in log space and weighted by sensor type.</li> <li>Output: The final calculated probability is exposed. If it crosses the configured threshold, the Occupancy Status sensor turns \"on\".</li> <li>Decay: If the probability starts decreasing (fewer active sensors), an exponential decay function gradually lowers the probability over a configured time window, unless new sensor activity pushes it back up.</li> </ol>"},{"location":"#common-issues","title":"Common Issues","text":"<ol> <li> <p>No Occupancy Detection:</p> </li> <li> <p>Verify sensors are working correctly</p> </li> <li>Check threshold setting</li> <li>Ensure sensors are properly configured</li> <li> <p>Adjust sensor weights</p> </li> <li> <p>False Positives:</p> </li> <li> <p>Lower weights for less reliable sensors</p> </li> <li>Increase occupancy threshold</li> <li>Adjust decay settings</li> <li> <p>Review time-based priors</p> </li> <li> <p>False Negatives:</p> </li> <li>Increase weights for reliable sensors</li> <li>Lower occupancy threshold</li> <li>Add additional sensors</li> <li>Check time-based prior patterns</li> </ol>"},{"location":"#support","title":"Support","text":"<ul> <li>GitHub Issues: Report bugs and request features</li> <li>Community Discussion: Ask questions and share experiences</li> <li>GitHub Releases: Check for updates and changelog</li> </ul>"},{"location":"features/activity-detection/","title":"Activity Detection","text":"<p>Activity detection identifies what activity is happening in an area, not just whether the area is occupied. It provides context-aware information about how a room is being used.</p>"},{"location":"features/activity-detection/#overview","title":"Overview","text":"<p>The system evaluates a set of predefined activities against the current sensor state and area purpose. Each activity has a definition composed of weighted indicators \u2014 specific sensor types and conditions that suggest the activity is occurring. The activity with the highest score is reported.</p>"},{"location":"features/activity-detection/#available-activities","title":"Available Activities","text":"Activity Description Allowed Room Purposes Showering Hot water running in a bathroom Bathroom Bathing Extended bathroom use with door closed Bathroom Cooking Active kitchen use with appliances and environmental changes Kitchen Watching TV Media playback on a TV or receiver Living Room, Media Room, Bedroom Listening to Music Audio playback on a speaker Living Room, Media Room, Office Working Desk work with computer/appliance use Office Eating Seated meal time with environmental cues Dining Room Sleeping Sleep detected via sleep presence sensor Bedroom Idle Area is occupied but no specific activity matches Unoccupied Area is not occupied <p>Activities are purpose-aware: an activity can only be detected in rooms whose purpose matches. For example, \"Showering\" will only appear in areas with a Bathroom purpose, and \"Cooking\" only in Kitchen areas.</p>"},{"location":"features/activity-detection/#how-scoring-works","title":"How Scoring Works","text":"<p>Each activity definition contains a list of indicators \u2014 sensor types with associated weights that signal the activity. When evaluating an activity:</p> <ol> <li>Filter by purpose: Only activities matching the area's purpose are considered.</li> <li>Check each indicator: For each indicator in the activity definition, the system checks whether a matching sensor exists in the area and whether it meets the condition (active state, elevated/suppressed environmental reading).</li> <li>Score calculation: Matched indicator weights are summed. The score is then normalized by the total definition weight \u2014 meaning if some sensors in the definition are not configured in the area, the maximum achievable confidence is reduced proportionally. This prevents activities from scoring artificially high when key sensors are missing.</li> <li>Minimum threshold: An activity must reach a minimum matched weight (default: 0.3) to qualify as a candidate.</li> <li>Tiebreaking: When multiple activities qualify, ties are broken by:<ol> <li>Highest confidence score</li> <li>Purpose specificity (fewer allowed purposes = more specific)</li> <li>Highest matched evidence weight</li> </ol> </li> </ol>"},{"location":"features/activity-detection/#environmental-indicators","title":"Environmental Indicators","text":"<p>Some indicators check whether an environmental sensor reading is elevated or suppressed relative to learned Gaussian parameters, rather than using hardcoded thresholds. For example, the \"Showering\" activity checks for elevated humidity \u2014 what counts as \"elevated\" is learned from historical data specific to your home.</p>"},{"location":"features/activity-detection/#created-entities","title":"Created Entities","text":"<p>Activity detection creates two entities per area:</p> <ul> <li><code>sensor.&lt;area&gt;_detected_activity</code> (Detected Activity)<ul> <li>Type: Enum sensor</li> <li>Description: Reports the currently detected activity as one of the values listed above.</li> <li>Attributes:</li> </ul> </li> </ul> Attribute Description <code>confidence</code> Confidence score as a percentage (0-100%) <code>matching_indicators</code> List of entity IDs that matched the activity definition <ul> <li><code>sensor.&lt;area&gt;_activity_confidence</code> (Activity Confidence)<ul> <li>Type: Diagnostic sensor (%)</li> <li>Description: Reports the confidence score of the detected activity as a percentage.</li> <li>Entity Category: <code>diagnostic</code></li> </ul> </li> </ul> <p>These entities are per-area only and are not included in the All Areas aggregation, since activities are specific to individual rooms.</p>"},{"location":"features/activity-detection/#example","title":"Example","text":"<p>Consider a Bathroom area with a humidity sensor, temperature sensor, motion sensor, and door sensor:</p> <ol> <li>After someone starts a shower, humidity rises and the door closes.</li> <li>The \"Showering\" definition matches: humidity elevated (weight 0.5) + temperature elevated (0.2) + motion active (0.15) + door closed (0.15) = total weight 1.0.</li> <li>All indicators match, so the confidence is 100%.</li> <li>The detected activity sensor reports <code>showering</code> with confidence <code>100.0</code>.</li> <li>When the shower ends and humidity drops, the activity transitions to <code>idle</code> and eventually <code>unoccupied</code>.</li> </ol>"},{"location":"features/calculation/","title":"Bayesian Probability Calculation","text":"<p>This integration uses Bayesian probability to determine the likelihood of an area being occupied based on the current states of configured sensors.</p>"},{"location":"features/calculation/#core-concept","title":"Core Concept","text":"<p>Instead of a simple binary \"motion detected = occupied\" logic, this integration calculates a probability score (0% to 100%) representing the confidence that the area is occupied.</p>"},{"location":"features/calculation/#calculation-steps","title":"Calculation Steps","text":""},{"location":"features/calculation/#1-collect-evidence","title":"1. Collect Evidence","text":"<p>Each configured entity reports whether it currently provides evidence of occupancy. Entities that are decaying after recent activity are also treated as evidence.</p> <p>The evidence collection process:</p> <ul> <li>Retrieves current state from Home Assistant</li> <li>Determines if state indicates activity (based on <code>active_states</code> or <code>active_range</code>)</li> <li>Considers decay: if entity was recently active, decay may still provide evidence</li> <li>Returns <code>True</code> (active), <code>False</code> (inactive), or <code>None</code> (unavailable)</li> </ul> <p>When evidence transitions from active to inactive, decay starts automatically.</p>"},{"location":"features/calculation/#2-determine-priors","title":"2. Determine Priors","text":"<p>The integration combines the area prior (learned from history) with a time-based prior to form a baseline probability using a weighted average in logit space.</p> <p>The prior combination process:</p> <ol> <li>Gets global prior from database (learned from historical sensor data)</li> <li>Gets time-based prior for current day-of-week and time-slot</li> <li>Converts both to logit space: <code>logit(p) = log(p / (1-p))</code></li> <li>Combines using weighted average: <code>combined_logit = area_weight * area_logit + time_weight * time_logit</code></li> <li>Converts back to probability: <code>combined_prior = 1 / (1 + exp(-combined_logit))</code></li> <li>Applies prior factor (1.05) to slightly increase baseline</li> <li>Clamps to valid range [MIN_PROBABILITY, MAX_PROBABILITY]</li> </ol> <p>The default time weight is 0.2, meaning 20% of the prior comes from time-based patterns and 80% from the global area prior.</p>"},{"location":"features/calculation/#3-adjust-likelihoods","title":"3. Adjust Likelihoods","text":"<p>For each entity, the learned likelihoods <code>P(Active | Occupied)</code> and <code>P(Active | Not Occupied)</code> are adjusted based on the entity's current state:</p>"},{"location":"features/calculation/#active-entities","title":"Active Entities","text":"<p>When an entity is active (or decaying), it uses the learned likelihoods directly:</p> <ul> <li><code>p_t = prob_given_true</code></li> <li><code>p_f = prob_given_false</code></li> </ul> <p>If the entity is decaying, the likelihoods are interpolated between their learned values and neutral (0.5) based on the decay factor:</p> <pre><code>p_t_adjusted = 0.5 + (p_t_learned - 0.5) * decay_factor\np_f_adjusted = 0.5 + (p_f_learned - 0.5) * decay_factor\n</code></pre> <p>This gradually reduces the influence of stale evidence as decay progresses.</p>"},{"location":"features/calculation/#inactive-entities","title":"Inactive Entities","text":"<p>When an entity is inactive (not providing evidence), it uses inverse likelihoods:</p> <pre><code>p_t = 1.0 - prob_given_true  # P(Inactive | Occupied)\np_f = 1.0 - prob_given_false  # P(Inactive | Not Occupied)\n</code></pre> <p>This ensures inactive sensors provide proper negative evidence. For example, if a sensor is usually active when occupied (<code>prob_given_true = 0.8</code>), then when it's inactive, it suggests the area is likely not occupied (<code>p_t = 0.2</code>). This prevents inactive sensors from diluting the effect of active sensors.</p> <p>The decay factor is calculated using exponential decay: <code>decay_factor = 0.5^(age / half_life)</code>, where <code>age</code> is the time since evidence became inactive.</p>"},{"location":"features/calculation/#4-log-space-combination","title":"4. Log-Space Combination","text":"<p>The calculation is performed in log space for numerical stability. For each entity the log probabilities for the \"occupied\" and \"not occupied\" hypotheses are accumulated and weighted according to the entity type's configured weight.</p> <p>The process:</p> <ol> <li>Entity Filtering: Removes entities with zero weight or invalid likelihoods</li> <li>Prior Clamping: Ensures prior is in valid range [MIN_PROBABILITY, MAX_PROBABILITY]</li> <li>Log-Space Initialization:</li> </ol> <pre><code>log_true = log(prior)\nlog_false = log(1 - prior)\n</code></pre> <ol> <li>Entity Processing: For each entity:</li> <li>Determines effective evidence (current or decaying)</li> <li>Gets adjusted likelihoods (with decay if applicable)</li> <li>Clamps likelihoods to avoid log(0) or log(1)</li> <li> <p>Calculates weighted log contributions:</p> <pre><code>contribution_true = log(p_t) * entity.weight\ncontribution_false = log(p_f) * entity.weight\n</code></pre> </li> <li> <p>Accumulates into log probabilities:</p> <pre><code>log_true += contribution_true\nlog_false += contribution_false\n</code></pre> </li> </ol>"},{"location":"features/calculation/#5-final-probability","title":"5. Final Probability","text":"<p>The log probabilities are exponentiated and normalised to produce the final occupancy probability.</p> <p>The normalization process:</p> <ol> <li>Finds maximum log value: <code>max_log = max(log_true, log_false)</code></li> <li>Subtracts maximum to prevent overflow:</li> </ol> <pre><code>true_prob = exp(log_true - max_log)\nfalse_prob = exp(log_false - max_log)\n</code></pre> <ol> <li>Normalises: <code>probability = true_prob / (true_prob + false_prob)</code></li> <li>Handles edge case where both probabilities are zero (returns prior)</li> </ol>"},{"location":"features/calculation/#dual-model-approach-presence-environmental","title":"Dual-Model Approach: Presence + Environmental","text":"<p>The integration splits sensor evidence into two independent models before combining them:</p>"},{"location":"features/calculation/#presence-confidence","title":"Presence Confidence","text":"<p>Filters to presence-related sensor types \u2014 motion, media, appliance, door, window, cover, power, and sleep \u2014 and calculates a probability using the sigmoid model. This represents the \"hard evidence\" of someone being in the area.</p> <p>The result is exposed as the Presence Confidence diagnostic sensor.</p>"},{"location":"features/calculation/#environmental-confidence","title":"Environmental Confidence","text":"<p>Filters to environmental sensor types (temperature, humidity, illuminance, CO2, etc.) and calculates a 0-1 confidence score. A value of 50% is neutral (no environmental influence), values above 50% support occupancy, and values below 50% oppose it.</p> <p>The result is exposed as the Environmental Confidence diagnostic sensor.</p>"},{"location":"features/calculation/#combined-probability-occupancy-probability","title":"Combined Probability (Occupancy Probability)","text":"<p>The two models are combined in logit space with an 80/20 weighting:</p> <pre><code>z_combined = 0.8 \u00d7 logit(presence) + 0.2 \u00d7 logit(environmental)\nprobability = sigmoid(z_combined)\n</code></pre> <p>This means presence indicators dominate the final probability, while environmental data provides supporting or opposing evidence. The combination in logit space (rather than simple averaging) preserves the probabilistic meaning of the values.</p>"},{"location":"features/calculation/#output","title":"Output","text":"<p>The result of this calculation is shown by the Occupancy Probability sensor, which displays the calculated probability as a percentage (0% to 100%).</p> <p>The Occupancy Status binary sensor compares this probability to the configured Occupancy Threshold to determine its <code>on</code> or <code>off</code> state. When the probability equals or exceeds the threshold, the status sensor turns <code>on</code>.</p>"},{"location":"features/calculation/#mathematical-foundation","title":"Mathematical Foundation","text":"<p>The calculation uses Bayes' theorem to combine evidence from multiple sensors. The system works in log space for numerical stability when combining many probabilities. For detailed mathematical explanations, see Bayesian Calculation Deep Dive.</p>"},{"location":"features/calculation/#entity-weight-application","title":"Entity Weight Application","text":"<p>Each entity type has a configured weight (0.0-1.0) that determines how much its evidence contributes to the final probability.</p> <p>The weight is applied as a multiplier to the log probability contribution:</p> <ul> <li>Weight 1.0: Full contribution (entity fully influences the result)</li> <li>Weight 0.5: Half contribution (entity has moderate influence)</li> <li>Weight 0.0: No contribution (entity is excluded from calculation)</li> </ul> <p>Default weights by entity type:</p> <ul> <li>Motion sensors: 1.00 (highest reliability, ground truth)</li> <li>Sleep: 0.90 (very high reliability)</li> <li>Media players: 0.85 (high reliability)</li> <li>Wasp in Box: 0.80 (high reliability)</li> <li>Cover sensors: 0.50 (moderate reliability)</li> <li>Appliances: 0.40 (moderate reliability)</li> <li>Door sensors: 0.30 (lower reliability)</li> <li>Power sensors: 0.30 (lower reliability)</li> <li>Window sensors: 0.20 (low reliability)</li> <li>Environmental sensors: 0.10 (very low reliability) - includes temperature, humidity, illuminance, CO2, sound pressure, atmospheric pressure, air quality, VOC, PM2.5, and PM10 sensors</li> </ul>"},{"location":"features/calculation/#decay-interpolation","title":"Decay Interpolation","text":"<p>When Probability Decay is active, likelihoods are interpolated between their learned values and neutral probabilities (0.5) based on the decay factor. As decay progresses, the likelihoods move toward neutral, gradually reducing their influence on the final probability. For the mathematical formula, see Bayesian Calculation Deep Dive.</p>"},{"location":"features/calculation/#edge-case-handling","title":"Edge Case Handling","text":"<p>The calculation handles several edge cases to ensure robust operation:</p> <ul> <li>Unavailable Entities: Entities with unavailable states are skipped unless they're decaying</li> <li>Zero Weight Entities: Entities with zero weight are excluded from the calculation</li> <li>Invalid Likelihoods: Entities with invalid likelihoods are excluded to prevent calculation errors</li> <li>No Entities: If no valid entities are available, the calculation returns the prior probability</li> <li>Numerical Stability: The system uses various techniques to prevent numerical overflow and underflow</li> </ul> <p>For detailed technical information about edge case handling, see Bayesian Calculation Deep Dive.</p>"},{"location":"features/calculation/#example-calculation","title":"Example Calculation","text":"<p>Consider an area with:</p> <ul> <li>Prior: 0.3 (30% baseline occupancy)</li> <li>Motion sensor: Active, weight 0.85, <code>P(Active|Occupied)=0.9</code>, <code>P(Active|Not Occupied)=0.1</code></li> <li>Media player: Inactive, weight 0.70, <code>P(Active|Occupied)=0.6</code>, <code>P(Active|Not Occupied)=0.2</code></li> </ul> <p>Step 1: Initialize log probabilities</p> <pre><code>log_true = log(0.3) = -1.204\nlog_false = log(0.7) = -0.357\n</code></pre> <p>Step 2: Process motion sensor (active)</p> <pre><code>p_t = 0.9, p_f = 0.1\nlog_true += log(0.9) * 0.85 = -1.204 + (-0.105) * 0.85 = -1.293\nlog_false += log(0.1) * 0.85 = -0.357 + (-2.303) * 0.85 = -2.315\n</code></pre> <p>Step 3: Process media player (inactive)</p> <p>For inactive entities, we use inverse likelihoods:</p> <pre><code>p_t = 1 - 0.6 = 0.4  # P(Inactive | Occupied) = 1 - P(Active | Occupied)\np_f = 1 - 0.2 = 0.8  # P(Inactive | Not Occupied) = 1 - P(Active | Not Occupied)\n\nlog_true += log(0.4) * 0.70 = -1.293 + (-0.916) * 0.70 = -1.934\nlog_false += log(0.8) * 0.70 = -2.315 + (-0.223) * 0.70 = -2.471\n</code></pre> <p>The inverse likelihoods provide negative evidence (the inactive media player suggests the area might not be occupied), but the motion sensor's strong positive evidence dominates the calculation.</p> <p>Step 4: Process door sensor (active)</p> <pre><code>p_t = 0.4, p_f = 0.3\nlog_true += log(0.4) * 0.25 = -1.934 + (-0.916) * 0.25 = -2.163\nlog_false += log(0.3) * 0.25 = -2.471 + (-1.204) * 0.25 = -2.772\n</code></pre> <p>Step 5: Normalize</p> <pre><code>max_log = max(-2.163, -2.772) = -2.163\ntrue_prob = exp(-2.163 - (-2.163)) = exp(0) = 1.0\nfalse_prob = exp(-2.772 - (-2.163)) = exp(-0.609) = 0.544\nprobability = 1.0 / (1.0 + 0.544) = 0.648 (64.8%)\n</code></pre> <p>The motion sensor's strong positive evidence (active with high <code>P(Active|Occupied)</code>) significantly increases the probability from the 30% prior to 67.6%.</p>"},{"location":"features/calculation/#see-also","title":"See Also","text":"<ul> <li>Complete Calculation Flow - End-to-end process explanation</li> <li>Bayesian Calculation Deep Dive - Detailed mathematical explanation</li> <li>Prior Learning - How priors are learned from history</li> <li>Likelihood Learning - How likelihoods are learned</li> <li>Decay Feature - Decay mechanism overview</li> <li>Entity Evidence Collection - How evidence is determined</li> </ul>"},{"location":"features/decay/","title":"Probability Decay","text":"<p>To prevent the occupancy status from flickering <code>off</code> the instant sensors become inactive (e.g., if you sit still for a moment), the integration includes a probability decay mechanism.</p>"},{"location":"features/decay/#purpose","title":"Purpose","text":"<p>The decay feature provides a smoother transition from an occupied state to an unoccupied state. When sensor activity ceases or suggests the area might be becoming vacant, the calculated Occupancy Probability doesn't immediately drop. Instead, it gradually decreases over a configured time window.</p>"},{"location":"features/decay/#how-decay-works","title":"How Decay Works","text":"<ol> <li>Trigger Condition: Decay starts only when the calculated occupancy probability (based on currently active sensors) decreases compared to the previous calculation cycle.</li> <li>Decay Start: When a decrease is detected:<ul> <li>The system notes the current time (<code>decay_start_time</code>).</li> <li>It records the probability value before the decrease (<code>decay_start_probability</code>). This value serves as the starting point for the decay curve.</li> <li>The Decay Status sensor likely becomes active (showing &gt; 0%).</li> </ul> </li> <li>Exponential Decay: As time passes from <code>decay_start_time</code>, the system calculates a decay factor based on an exponential function. The rate of decay is determined by the configured Decay Half Life and an internal decay constant (<code>DECAY_LAMBDA</code>). A shorter half life results in faster decay.</li> <li>Applying Decay: The calculated decay factor is applied to the <code>decay_start_probability</code>. This results in a potentially lower probability value.</li> <li>Floor Value: Importantly, the decayed probability can never go below the probability currently being calculated based on any sensors that are still active. If, during decay, a sensor reactivates and pushes the calculated probability up, that new higher value becomes the floor.</li> <li>Decay Stops When:<ul> <li>The calculated occupancy probability (based on sensor states) increases or stays the same. The decay state is reset.</li> <li>The decayed probability reaches the defined minimum probability (e.g., 1%). The probability stays at the minimum, and the decay state is reset.</li> </ul> </li> </ol>"},{"location":"features/decay/#configuration","title":"Configuration","text":"<ul> <li>Decay Enabled: A toggle to turn the decay feature on or off entirely.</li> <li>Decay Half Life (seconds): The time for the probability to fall to half of its starting value when no new activity occurs. For example, a 300-second half life means the probability halves every 5 minutes (it may stop earlier if activity resumes).</li> </ul> <p>Note: The previous Decay Minimum Delay option has been removed in version 9.2. Any existing configurations are updated automatically during migration.</p>"},{"location":"features/decay/#output","title":"Output","text":"<ul> <li>The Occupancy Probability sensor reflects the decayed value when decay is active.</li> <li>The Decay Status sensor indicates the progress of the decay, likely as a percentage (0% when not decaying, increasing towards 100% as decay progresses towards the minimum probability). Note: The exact representation might vary; check the sensor's state in your HA instance. </li> </ul>"},{"location":"features/entities/","title":"Entities","text":"<p>This integration creates several entities in Home Assistant to expose the calculated data and allow control.</p>"},{"location":"features/entities/#primary-entities","title":"Primary Entities","text":"<ul> <li> <p><code>binary_sensor.area_occupancy_status_&lt;area_name&gt;</code> (Occupancy Status)</p> <ul> <li>State: <code>on</code> / <code>off</code></li> <li>Description: This is the main occupancy output. It turns <code>on</code> if the Occupancy Probability is greater than or equal to the Occupancy Threshold, and <code>off</code> otherwise.</li> <li>Icon: Changes based on state (<code>mdi:home-account</code> for <code>on</code>, <code>mdi:home-outline</code> for <code>off</code>).</li> <li>Device Class: <code>occupancy</code></li> </ul> </li> <li> <p><code>sensor.area_occupancy_probability_&lt;area_name&gt;</code> (Occupancy Probability)</p> <ul> <li>State: Numeric value (0.0 to 100.0)</li> <li>Unit: <code>%</code></li> <li>Description: Shows the current calculated Bayesian probability that the area is occupied. This value incorporates sensor inputs, learned priors, weights, and decay (if active).</li> <li>Device Class: <code>power_factor</code> (used for % display)</li> <li>State Class: <code>measurement</code></li> </ul> </li> <li> <p><code>number.area_occupancy_threshold_&lt;area_name&gt;</code> (Occupancy Threshold)</p> <ul> <li>State: Numeric value (configurable range, typically 1-99)</li> <li>Unit: <code>%</code></li> <li>Description: Allows you to adjust the probability threshold required for the Occupancy Status binary sensor to turn <code>on</code>. Changes made here are reflected immediately in the binary sensor's state.</li> <li>Mode: <code>slider</code> or <code>box</code> (depends on HA frontend)</li> </ul> </li> <li> <p><code>sensor.area_presence_confidence_&lt;area_name&gt;</code> (Presence Confidence)</p> <ul> <li>State: Numeric value (0.0 to 100.0)</li> <li>Unit: <code>%</code></li> <li>Description: Shows the probability calculated from strong presence indicators only (motion, media, appliances, doors, windows, covers, power, sleep). This isolates the \"hard evidence\" of occupancy from environmental support.</li> <li>Device Class: <code>power_factor</code></li> <li>State Class: <code>measurement</code></li> <li>Entity Category: <code>diagnostic</code></li> </ul> </li> <li> <p><code>sensor.area_environmental_confidence_&lt;area_name&gt;</code> (Environmental Confidence)</p> <ul> <li>State: Numeric value (0.0 to 100.0)</li> <li>Unit: <code>%</code></li> <li>Description: Shows the confidence from environmental sensors. 50% is neutral (no environmental influence), values above 50% mean environmental data supports occupancy, and values below 50% mean environmental data opposes occupancy.</li> <li>Device Class: <code>power_factor</code></li> <li>State Class: <code>measurement</code></li> <li>Entity Category: <code>diagnostic</code></li> </ul> </li> <li> <p><code>sensor.area_detected_activity_&lt;area_name&gt;</code> (Detected Activity)</p> <ul> <li>State: One of: <code>showering</code>, <code>bathing</code>, <code>cooking</code>, <code>eating</code>, <code>watching_tv</code>, <code>listening_to_music</code>, <code>working</code>, <code>sleeping</code>, <code>idle</code>, <code>unoccupied</code></li> <li>Description: Reports the currently detected activity in the area. Activities are constrained by the area's purpose (e.g., \"showering\" only appears in bathrooms). See Activity Detection for details.</li> <li>Device Class: <code>enum</code></li> <li>Attributes:<ul> <li><code>confidence</code>: Confidence score as a percentage (0-100%).</li> <li><code>matching_indicators</code>: List of entity IDs that matched the activity definition.</li> </ul> </li> </ul> </li> <li> <p><code>sensor.area_activity_confidence_&lt;area_name&gt;</code> (Activity Confidence)</p> <ul> <li>State: Numeric value (0.0 to 100.0)</li> <li>Unit: <code>%</code></li> <li>Description: Shows the confidence score of the detected activity as a percentage.</li> <li>Device Class: <code>power_factor</code></li> <li>State Class: <code>measurement</code></li> <li>Entity Category: <code>diagnostic</code></li> </ul> </li> <li> <p><code>binary_sensor.&lt;area_name&gt;_sleeping</code> (Sleeping)</p> <ul> <li>State: <code>on</code> / <code>off</code></li> <li>Description: Turns <code>on</code> when one or more people assigned to this area are detected as sleeping. Supports multiple sleep sensors per person (both numeric and binary). Only created for areas that have people configured via the Manage People option. See Sleep Presence for details.</li> <li>Device Class: <code>occupancy</code></li> <li>Icon: <code>mdi:sleep</code></li> <li>Attributes:<ul> <li><code>people_sleeping</code>: List of friendly names of people currently sleeping.</li> <li><code>people</code>: Detailed list with person name, state, sleep sensor states, threshold, and sleeping status per person.</li> </ul> </li> </ul> </li> </ul>"},{"location":"features/entities/#diagnostic-entities","title":"Diagnostic Entities","text":"<p>These entities provide insight into the internal calculations and are useful for tuning and debugging.</p> <ul> <li> <p><code>sensor.area_prior_probability_&lt;area_name&gt;</code> (Prior Probability)</p> <ul> <li>State: Numeric value (0.0 to 100.0)</li> <li>Unit: <code>%</code></li> <li>Description: Shows the combined prior probability used for occupancy calculations.</li> <li>Device Class: <code>power_factor</code></li> <li>State Class: <code>measurement</code></li> <li>Entity Category: <code>diagnostic</code></li> <li>Attributes:<ul> <li><code>global_prior</code>: Baseline prior derived from historical analysis.</li> <li><code>time_prior</code>: Time-based modifier applied to the prior.</li> <li><code>day_of_week</code>: Day-of-week index used for time prior.</li> <li><code>time_slot</code>: Time slot index used for time prior.</li> </ul> </li> </ul> </li> <li> <p><code>sensor.area_evidence_&lt;area_name&gt;</code> (Evidence)</p> <ul> <li>State: Number of entities currently managed</li> <li>Description: Lists entities providing evidence and those that are inactive.</li> <li>Entity Category: <code>diagnostic</code></li> <li>Attributes:<ul> <li><code>evidence</code>: Comma-separated list of active entity names.</li> <li><code>no_evidence</code>: Comma-separated list of inactive entity names.</li> <li><code>total</code>: Total number of entities.</li> <li><code>details</code>: Detailed information for each entity including probabilities and decay status.</li> </ul> </li> </ul> </li> <li> <p><code>sensor.area_decay_status_&lt;area_name&gt;</code> (Decay Status)</p> <ul> <li>State: Numeric value (0.0 to 100.0)</li> <li>Unit: <code>%</code></li> <li>Description: Indicates the progress of the probability decay when active. <code>0.0</code> means decay is not active. A value increasing towards <code>100.0</code> suggests decay is in progress. (100% likely corresponds to reaching the minimum probability limit or the configured decay window duration).</li> <li>Device Class: <code>power_factor</code></li> <li>State Class: <code>measurement</code></li> <li>Entity Category: <code>diagnostic</code></li> <li>Attributes: (May include details like <code>decay_start_time</code>, <code>decay_start_probability</code> - check the entity state in Developer Tools for specifics).</li> </ul> </li> </ul>"},{"location":"features/entities/#all-areas-aggregation-device","title":"All Areas Aggregation Device","text":"<p>When you configure your first area, the integration automatically creates an \"All Areas\" device that aggregates occupancy data across all configured areas. This provides a unified view of occupancy across your entire home.</p> <p>Excluding areas from aggregation</p> <p>Areas can be excluded from the All Areas aggregation using the Exclude from All Areas toggle in each area's Detection Behavior settings. This is useful for outdoor or utility areas (garages, driveways, patios) that you don't want contributing to the whole-home occupancy status. See Configuration for details.</p>"},{"location":"features/entities/#device-information","title":"Device Information","text":"<ul> <li>Device Name: <code>All Areas</code></li> <li>Device Identifier: <code>all_areas</code></li> <li>Created Automatically: Yes, when the first area is configured</li> </ul>"},{"location":"features/entities/#aggregation-entities","title":"Aggregation Entities","text":"<p>The \"All Areas\" device creates the following entities (using <code>all_areas</code> instead of an area name):</p> <ul> <li> <p><code>binary_sensor.area_occupancy_status_all_areas</code> (All Areas Occupancy Status)</p> <ul> <li>State: <code>on</code> / <code>off</code></li> <li>Description: Aggregated occupancy status using OR logic: turns <code>on</code> if any area is occupied, <code>off</code> only when all areas are unoccupied.</li> <li>Icon: Changes based on state (<code>mdi:home-account</code> for <code>on</code>, <code>mdi:home-outline</code> for <code>off</code>).</li> <li>Device Class: <code>occupancy</code></li> <li>Use Case: Perfect for whole-home automations like \"turn off all lights when no one is home\" or \"enable away mode when all areas are clear\".</li> </ul> </li> <li> <p><code>sensor.area_occupancy_probability_all_areas</code> (All Areas Occupancy Probability)</p> <ul> <li>State: Numeric value (0.0 to 100.0)</li> <li>Unit: <code>%</code></li> <li>Description: Average occupancy probability across all configured areas. Calculated as the mean of all individual area probabilities.</li> <li>Device Class: <code>power_factor</code> (used for % display)</li> <li>State Class: <code>measurement</code></li> <li>Use Case: Provides a single metric representing overall occupancy likelihood across your home.</li> </ul> </li> <li> <p><code>sensor.area_prior_probability_all_areas</code> (All Areas Prior Probability)</p> <ul> <li>State: Numeric value (0.0 to 100.0)</li> <li>Unit: <code>%</code></li> <li>Description: Average prior probability across all areas. This represents the baseline occupancy likelihood before considering current sensor evidence.</li> <li>Device Class: <code>power_factor</code></li> <li>State Class: <code>measurement</code></li> <li>Entity Category: <code>diagnostic</code></li> <li>Use Case: Useful for understanding overall occupancy patterns across your home.</li> </ul> </li> <li> <p><code>sensor.area_decay_status_all_areas</code> (All Areas Decay Status)</p> <ul> <li>State: Numeric value (0.0 to 100.0)</li> <li>Unit: <code>%</code></li> <li>Description: Average decay status across all areas. Indicates the overall progress of probability decay when activity decreases.</li> <li>Device Class: <code>power_factor</code></li> <li>State Class: <code>measurement</code></li> <li>Entity Category: <code>diagnostic</code></li> <li>Use Case: Helps understand when overall occupancy is decreasing across multiple areas.</li> </ul> </li> <li> <p><code>sensor.area_presence_confidence_all_areas</code> (All Areas Presence Confidence)</p> <ul> <li>State: Numeric value (0.0 to 100.0)</li> <li>Unit: <code>%</code></li> <li>Description: Average presence confidence across all configured areas.</li> <li>Device Class: <code>power_factor</code></li> <li>State Class: <code>measurement</code></li> <li>Entity Category: <code>diagnostic</code></li> </ul> </li> <li> <p><code>sensor.area_environmental_confidence_all_areas</code> (All Areas Environmental Confidence)</p> <ul> <li>State: Numeric value (0.0 to 100.0)</li> <li>Unit: <code>%</code></li> <li>Description: Average environmental confidence across all configured areas.</li> <li>Device Class: <code>power_factor</code></li> <li>State Class: <code>measurement</code></li> <li>Entity Category: <code>diagnostic</code></li> </ul> </li> </ul> <p>Note</p> <p>Detected Activity and Activity Confidence are not aggregated across areas, as activities are specific to individual rooms.</p>"},{"location":"features/entities/#how-aggregation-works","title":"How Aggregation Works","text":"<p>The \"All Areas\" device uses different aggregation strategies depending on the metric:</p> <ul> <li>Occupancy Status (Binary Sensor): Uses OR logic - if any area is occupied, the aggregated status is <code>on</code>. Only when all areas are unoccupied does it show <code>off</code>.</li> <li>Probability: Uses average - calculates the mean probability across all areas.</li> <li>Prior Probability: Uses average - calculates the mean prior probability across all areas.</li> <li>Decay Status: Uses average - calculates the mean decay status across all areas.</li> <li>Presence Confidence: Uses average - calculates the mean presence confidence across all areas.</li> <li>Environmental Confidence: Uses average - calculates the mean environmental confidence across all areas.</li> </ul>"},{"location":"features/entities/#example-use-cases","title":"Example Use Cases","text":"<ol> <li> <p>Whole-Home Occupancy Detection: <pre><code>automation:\n  - alias: \"Turn off all lights when no one is home\"\n    trigger:\n      - platform: state\n        entity_id: binary_sensor.area_occupancy_status_all_areas\n        to: 'off'\n    action:\n      - service: light.turn_off\n        target:\n          entity_id: all\n</code></pre></p> </li> <li> <p>Average Occupancy Monitoring: <pre><code>sensor:\n  - platform: template\n    sensors:\n      overall_occupancy:\n        value_template: \"{{ states('sensor.area_occupancy_probability_all_areas') | float }}\"\n        unit_of_measurement: '%'\n</code></pre></p> </li> <li> <p>Multi-Area Presence Detection:    Use the <code>binary_sensor.area_occupancy_status_all_areas</code> entity in presence detection automations that need to know if anyone is home, regardless of which specific area.</p> </li> </ol>"},{"location":"features/entities/#notes","title":"Notes","text":"<ul> <li>The \"All Areas\" device is created automatically when you configure your first area.</li> <li>Areas with Exclude from All Areas enabled are not included in the aggregation.</li> <li>The Evidence sensor is not created for \"All Areas\" as it would be too complex to aggregate evidence details across multiple areas.</li> <li>The Detected Activity and Activity Confidence sensors are not created for \"All Areas\" as activities are specific to individual rooms.</li> <li>All aggregation calculations are performed in real-time based on the current state of individual areas.</li> <li>The device appears in Home Assistant's device registry under the name \"All Areas\".</li> </ul>"},{"location":"features/entities/#floor-based-aggregation-devices","title":"Floor-Based Aggregation Devices","text":"<p>If your areas are assigned to floors in Home Assistant, the integration automatically creates per-floor aggregation devices. These work identically to the All Areas device but only aggregate areas on the same floor.</p>"},{"location":"features/entities/#how-it-works","title":"How It Works","text":"<p>At startup, the integration discovers which floors your configured areas belong to (via the Home Assistant floor registry) and creates a device for each floor. If you add or remove floors, the devices update on the next reload.</p>"},{"location":"features/entities/#device-information_1","title":"Device Information","text":"<ul> <li>Device Name: <code>&lt;Floor Name&gt;</code> (e.g., \"Upstairs\", \"Ground Floor\")</li> <li>Created Automatically: Yes, for each floor that has at least one configured area</li> </ul>"},{"location":"features/entities/#floor-aggregation-entities","title":"Floor Aggregation Entities","text":"<p>Each floor device creates the same set of entities as the All Areas device, scoped to that floor:</p> <ul> <li> <p><code>binary_sensor.area_occupancy_status_&lt;floor_name&gt;</code> (Floor Occupancy Status)</p> <ul> <li>Uses OR logic: <code>on</code> if any area on the floor is occupied.</li> </ul> </li> <li> <p><code>sensor.area_occupancy_probability_&lt;floor_name&gt;</code> (Floor Occupancy Probability)</p> <ul> <li>Average probability across areas on this floor.</li> </ul> </li> <li> <p><code>sensor.area_prior_probability_&lt;floor_name&gt;</code> (Floor Prior Probability)</p> <ul> <li>Average prior probability across areas on this floor.</li> <li>Entity Category: <code>diagnostic</code></li> </ul> </li> <li> <p><code>sensor.area_decay_status_&lt;floor_name&gt;</code> (Floor Decay Status)</p> <ul> <li>Average decay status across areas on this floor.</li> <li>Entity Category: <code>diagnostic</code></li> </ul> </li> <li> <p><code>sensor.area_presence_confidence_&lt;floor_name&gt;</code> (Floor Presence Confidence)</p> <ul> <li>Average presence confidence across areas on this floor.</li> <li>Entity Category: <code>diagnostic</code></li> </ul> </li> <li> <p><code>sensor.area_environmental_confidence_&lt;floor_name&gt;</code> (Floor Environmental Confidence)</p> <ul> <li>Average environmental confidence across areas on this floor.</li> <li>Entity Category: <code>diagnostic</code></li> </ul> </li> </ul> <p>Note</p> <p>Floor aggregation respects the Exclude from All Areas toggle \u2014 excluded areas are also excluded from their floor's aggregation.</p>"},{"location":"features/entities/#example-use-cases_1","title":"Example Use Cases","text":"<ol> <li> <p>Floor-Based Lighting: <pre><code>automation:\n  - alias: \"Turn off upstairs lights when floor is clear\"\n    trigger:\n      - platform: state\n        entity_id: binary_sensor.area_occupancy_status_upstairs\n        to: 'off'\n        for:\n          minutes: 10\n    action:\n      - service: light.turn_off\n        target:\n          area_id:\n            - master_bedroom\n            - guest_bedroom\n            - upstairs_bathroom\n</code></pre></p> </li> <li> <p>Floor-Level HVAC Control:    Use the floor occupancy probability to adjust heating/cooling zones per floor rather than per room.</p> </li> </ol>"},{"location":"features/likelihood/","title":"Sensor Likelihoods","text":"<p>Each sensor has learned characteristics that describe how reliable it is as evidence of occupancy.</p> <p>For non-motion sensors, the system learns the statistical distribution of the sensor's state (or value) when the room is occupied vs. unoccupied. This allows for a continuous, dynamic calculation of likelihood based on the exact current state.</p> <p>See Sensor Correlation &amp; Continuous Likelihood for detailed information on how this works.</p>"},{"location":"features/likelihood/#motion-sensors","title":"Motion Sensors","text":"<p>Motion sensors do not have learned likelihoods. Instead, they use user-configurable likelihoods that you can set per area during configuration:</p> <ul> <li><code>P(Active | Occupied)</code>: Configurable (default: 0.95 or 95%)</li> <li><code>P(Active | Not Occupied)</code>: Configurable (default: 0.005 or 0.5%)</li> </ul> <p>Motion sensors are used as ground truth to determine when the area is occupied. Learning motion sensor likelihoods would create a circular dependency where motion sensors determine occupied intervals and then calculate their own likelihoods from those same intervals. Instead, you can configure these values based on your specific motion sensor setup and reliability.</p> <p>You can adjust these values in the integration's configuration for each area. Higher values for <code>P(Active | Occupied)</code> mean the motion sensor is more reliable when the area is actually occupied. Lower values for <code>P(Active | Not Occupied)</code> mean fewer false positives.</p>"},{"location":"features/likelihood/#other-sensors","title":"Other Sensors","text":"<p>For all other sensor types, likelihoods are learned from historical data by analyzing their activity relative to the occupied intervals determined by motion sensors. The analysis method depends on sensor type:</p>"},{"location":"features/likelihood/#numeric-sensors-temperature-humidity-co2-etc","title":"Numeric Sensors (Temperature, Humidity, CO2, etc.)","text":"<p>Numeric sensors use correlation analysis to learn statistical distributions (Gaussian PDFs) that allow for dynamic likelihood calculation based on the exact sensor value.</p> <p>See Sensor Correlation &amp; Continuous Likelihood for detailed information.</p>"},{"location":"features/likelihood/#binary-sensors-media-players-appliances-doors-windows","title":"Binary Sensors (Media Players, Appliances, Doors, Windows)","text":"<p>Binary sensors use duration-based analysis to calculate static probabilities directly from how long they're active during occupied vs. unoccupied periods.</p> <p>The system calculates:</p> <ul> <li><code>P(Active | Occupied)</code>: Probability the sensor is active when the area is occupied</li> <li><code>P(Active | Unoccupied)</code>: Probability the sensor is active when the area is unoccupied</li> </ul> <p>These probabilities are stored as static values and used regardless of the current sensor state.</p>"},{"location":"features/likelihood/#default-likelihoods","title":"Default Likelihoods","text":"<p>If history-based learning is disabled, insufficient history is available, or analysis fails, default likelihoods from the integration are used instead. These defaults come from the <code>EntityType</code> definition and vary by sensor type.</p> <p>You can manually refresh the stored likelihoods by calling the <code>area_occupancy.run_analysis</code> service.</p>"},{"location":"features/prior-learning/","title":"Prior Probability Learning","text":"<p>To make the Bayesian calculations more accurate and specific to your environment, the integration automatically learns key probability values from your sensor history. This process adapts the system to how you actually use the space.</p>"},{"location":"features/prior-learning/#what-is-a-prior-probability","title":"What is a Prior Probability?","text":"<p>Simply put the prior is the probability that the area is occupied at any given time. For example \"I spend about 30% of my time in the living room\" so the prior for the living room is 0.30. This sets the \"ground truth\" for the living room.</p> <p>Initially, the integration uses default prior values. However, the Prior Learning process aims to calculate a more accurate prior based on the historical behavior of your motion sensors, reflecting how often that area is typically occupied. This is done by analyzing the history of your sensors over a lookback period (default: 60 days).</p> <p>In the context of Bayesian probability, the prior probability (often denoted as <code>P(Occupied)</code> or simply <code>prior</code>) represents our initial belief about the likelihood of an event before considering any new evidence. For this integration, it's the baseline probability that the area is occupied, independent of the current state of the sensors.</p>"},{"location":"features/prior-learning/#how-priors-are-calculated","title":"How Priors Are Calculated","text":"<p>The system calculates two types of priors to provide a robust baseline:</p> <ol> <li>Global Prior: A single value representing the overall \"busyness\" of a room (e.g., a living room is occupied 30% of the time, a guest room 1% of the time).</li> <li>Time-Based Prior: A time-specific probability based on the day of week and time of day (e.g., \"Mondays at 09:00\").</li> </ol> <p>The final prior used for real-time detection is a combination of these two, giving weight to the specific time of day while using the global prior as a stable anchor.</p>"},{"location":"features/prior-learning/#1-global-prior-calculation","title":"1. Global Prior Calculation","text":"<p>The Global Prior is determined by analyzing the history of your sensors over a lookback period (default: 60 days).</p> <ul> <li>Motion Analysis: First, it calculates the percentage of time motion sensors were active.</li> <li>Fallback for Low Activity: If motion sensors show very low activity (less than 10% of the time), the system assumes people might be sitting still (e.g., watching TV or working). It then checks Media Players and Appliances to supplement the occupancy data.</li> <li>Result: This produces a single probability value (e.g., 0.35 or 35%) that serves as the general baseline for the room.</li> </ul>"},{"location":"features/prior-learning/#2-time-based-prior-calculation","title":"2. Time-Based Prior Calculation","text":"<p>The Time-Based Prior provides granularity by breaking the week into 1-hour slots (e.g., \"Monday 09:00-10:00\", \"Tuesday 14:00-15:00\"). This allows the system to learn time-of-day patterns specific to your usage.</p> <ul> <li>Grid: It creates a schedule of 168 slots (24 hours \u00d7 7 days).</li> <li>History Analysis: For each slot, it analyzes historical motion sensor data to determine how often the room was occupied during that specific hour on that day of the week.</li> <li>Data Source: Only motion sensors are used for time prior calculation (no media/appliance fallback).</li> <li>Calculation Method: The system processes occupied intervals from the lookback period (default: 60 days), groups them by day of week and time slot, and calculates the occupancy percentage for each slot.</li> <li>Safety Bounds: The system bounds these time-specific probabilities between 3% and 90%. This prevents extreme values from dominating the calculation, ensuring that the system remains responsive to new sensor evidence even if the schedule suggests the room \"should\" be empty.</li> <li>Result: This produces a unique probability for every hour of the week, allowing the system to \"expect\" occupancy at usual times (like evening TV time) and \"expect\" vacancy at others (like work hours).</li> <li>Storage: Time priors are calculated during the analysis cycle and stored in the database. They are automatically recalculated as new historical data becomes available.</li> </ul> <p>See Time Prior Flow for complete implementation details.</p>"},{"location":"features/prior-learning/#ground-truth-defining-occupancy","title":"Ground Truth: Defining \"Occupancy\"","text":"<p>To learn from history, the system needs to know when the room was actually occupied. It uses Motion Sensors as the \"Ground Truth\" or Gold Standard.</p> <ul> <li>Why Motion?: Motion sensors are the most direct indicator of human presence. They rarely generate false positives (indicating presence when no one is there).</li> <li>Motion Timeout: The system automatically accounts for the time after motion stops. If your motion sensors have a timeout (e.g., 5 minutes), this \"cooldown\" period is counted as occupied time, ensuring consistent logic across all calculations.</li> </ul>"},{"location":"features/prior-learning/#real-time-probability-adjustment","title":"Real-Time Probability Adjustment","text":"<p>When the integration runs in real-time, it determines the current Prior Probability dynamically:</p> <ol> <li>Combine Priors: It starts by mixing the Global Prior and the specific Time-Based Prior for the current hour. This balances the general busyness of the room with the specific expectation for the current time.</li> <li>Bias Towards Safety: The system slightly biases the prior towards assuming occupancy (multiplying by a small factor). This is a \"better safe than sorry\" heuristic to prevent lights from turning off on you.</li> <li>Apply Minimum Floor: Finally, it applies the Minimum Prior Override (if configured). This ensures that even in very rarely used rooms, the probability never drops so low that the system becomes unresponsive to new sensor activity.</li> </ol>"},{"location":"features/prior-learning/#handling-special-situations","title":"Handling Special Situations","text":"<p>The system is designed to handle various edge cases robustly:</p> <ul> <li>New Installations: If there is no history yet, the system uses a neutral Default Prior (50%) to avoid making assumptions until data is available.</li> <li>Missing Data: If specific time slots have no history (e.g., a power outage occurred every Tuesday at 2 AM), it falls back to safe defaults.</li> <li>Sensor Dropouts: If a sensor becomes unavailable, it is temporarily excluded from the calculation to prevent skewing the data.</li> </ul>"},{"location":"features/prior-learning/#minimum-prior-override","title":"Minimum Prior Override","text":"<p>You can configure a <code>min_prior_override</code> for each area.</p> <ul> <li>Purpose: This setting prevents the calculated prior from dropping too low in rarely-used rooms (like a guest room or attic).</li> <li>Effect: If the historical probability is extremely low (e.g., 0.01%), the system might require overwhelming evidence to switch to \"Occupied.\" Setting a minimum override (e.g., 0.10) ensures the system remains responsive to new motion or sensor activity, even in \"quiet\" rooms.</li> </ul>"},{"location":"features/prior-learning/#default-behaviors","title":"Default Behaviors","text":"<p>When data is missing or insufficient, the system uses these defaults:</p> <ul> <li>Neutral (0.5): Used when historical data is completely missing or invalid (e.g., during initial setup).</li> <li>Time Slot Default (0.5): Used for specific time slots that have no recorded history. As historical data accumulates, these slots will be populated with calculated values during the analysis cycle.</li> </ul>"},{"location":"features/prior-learning/#troubleshooting","title":"Troubleshooting","text":""},{"location":"features/prior-learning/#time-priors-not-learning","title":"Time Priors Not Learning","text":"<p>Symptom: Time priors always return 0.5 (neutral) regardless of time of day.</p> <p>Possible Causes:</p> <ol> <li>Insufficient Historical Data: Time priors require at least some historical data to calculate. If you've just installed the integration, wait for the first analysis cycle to complete (runs hourly by default).</li> <li>No Motion Sensor Activity: If motion sensors haven't detected activity during a specific time slot, that slot will default to 0.5 until data is available.</li> <li>Analysis Cycle Not Running: Check that the analysis cycle is running successfully. Time priors are calculated during the analysis cycle.</li> </ol> <p>How to Verify: Check the Home Assistant logs for messages like \"Time priors saved for area X: Y slots populated\" after an analysis cycle completes.</p> <p>See Also: Time Prior Flow for complete implementation details.</p>"},{"location":"features/purpose/","title":"Area Purpose and Decay Behaviour","text":"<p>The integration lets you assign an Area Purpose to each instance. The purpose describes how the room is typically used and determines a sensible default for the probability decay speed.</p> <p>Selecting a purpose automatically sets the Decay Half Life \u2013 the time it takes for the occupancy probability to halve when no new activity occurs. You can still override this value in the options flow if required.</p> Purpose Description Default Half Life Passageway Short transit spaces such as hallways or landings. Evidence fades very quickly. Very short (~45 sec) Driveway Parking and vehicle access area. Brief transit for entering/exiting vehicles. Very short (~1 min) Utility Functional rooms like laundries or boot rooms. Short (~90 sec) Garage Storage and workshop space. Visits range from quick retrieval to extended projects. Moderate (~3 min) Kitchen Kitchen work zones. Moderate (~4 min) Garden Outdoor activity space for gardening, relaxing, or yard work. Moderate-long (~6 min) Bathroom Showers, baths, getting ready. Moderate-long (~7.5 min) Dining Room Dining or breakfast areas. Moderate-long (~8 min) Living Room Living rooms or play areas. Long (~8 minutes) Office Offices or desks. Long (~10 min) Media Room Lounges or reading nooks. Long (~10 minutes) Bedroom Bedrooms and similar spaces. Very long (~20 min) <p>The chosen purpose does not directly alter the Bayesian calculation beyond this decay timing. A shorter half life causes the probability to drop faster after activity stops; a longer half life keeps the area marked as occupied for longer.</p>"},{"location":"features/purpose/#purpose-justifications","title":"Purpose Justifications","text":"<p>Each purpose's half-life is tuned to match typical usage patterns:</p> <ul> <li> <p>Passageway (45s): People walk through quickly (5-30 seconds typically). After someone leaves, the area should be empty almost immediately. A short half-life ensures quick clearing after transit.</p> </li> <li> <p>Driveway (60s / 1 min): People typically spend 10-30 seconds entering or exiting vehicles, with occasional brief pauses for loading or unloading. A very short half-life ensures the area clears quickly after vehicles depart, similar to passageways but accounting for brief stops.</p> </li> <li> <p>Utility (90s): Quick functional visits like grabbing detergent (10-30s) or putting on shoes (30-60s). A short half-life matches these brief interactions without unnecessary delay.</p> </li> <li> <p>Garage (180s / 3 min): Visits range from quick item retrieval (30-60 seconds) to extended projects (15-30+ minutes). A moderate half-life accommodates both brief functional visits and longer work sessions without premature clearing during active use.</p> </li> <li> <p>Kitchen (240s / 4 min): Kitchen work involves moving between stations (stove, fridge, sink, counter). Residents step away and return frequently. A moderate half-life prevents flicker when moving between work zones while still clearing reasonably quickly after cooking ends.</p> </li> <li> <p>Garden (360s / 6 min): Outdoor activities like gardening, relaxing, or yard work can involve periods of stillness where motion sensors may not detect activity. A moderate-long half-life accounts for sparse motion detection while maintaining occupancy during active outdoor use.</p> </li> <li> <p>Bathroom (450s / 7.5 min): Showers typically last 5-15 minutes, but motion sensors may not detect much movement during showers. A moderate-long half-life ensures the area stays marked as occupied throughout a typical shower, preventing lights from turning off.</p> </li> <li> <p>Dining Room (480s / 8 min): Meals typically last 10-20 minutes, but people sit relatively still while eating. A moderate-long half-life matches typical meal duration, accounting for periods of stillness between bites.</p> </li> <li> <p>Living Room (520s / ~8.5 min): Conversations and board games create sporadic motion with quiet pauses. A moderate-long half-life allows evidence to fade gently, riding out quiet pauses without flickering.</p> </li> <li> <p>Office (600s / 10 min): Long seated sessions with occasional trips for coffee or printer. People can be very still while focused on work. A longer half-life prevents premature \"vacant\" detection during focused work periods while still clearing after extended absence.</p> </li> <li> <p>Media Room (620s / ~10 min): People can remain very still while watching TV or reading. A longer half-life keeps the room marked as \"occupied\" through extended stretches of calm activity, while still allowing the room to clear after a reasonable period of inactivity.</p> </li> <li> <p>Bedroom (1200s / 20 min): Deep sleep has minimal motion. A very long half-life prevents false vacancy during deep sleep while still allowing the house to revert to \"empty\" within a couple of hours after everyone gets up. This is especially important for preventing lights from turning off during the night.</p> </li> </ul>"},{"location":"features/purpose/#dynamic-sleeping-decay","title":"Dynamic Sleeping Decay","text":"<p>Areas with the <code>Bedroom</code> purpose have a special dynamic behavior tied to your household's sleep schedule.</p> <ul> <li>During Sleep Hours: Uses the configured <code>Bedroom</code> half-life to maintain occupancy probability for long periods of inactivity while you sleep.</li> <li>Outside Sleep Hours: Automatically switches to behave like a <code>Living Room</code> area, recognizing that bedrooms are often used for reading or getting ready during the day where shorter memory is appropriate.</li> </ul> <p>You can configure your global <code>Sleep Start</code> and <code>Sleep End</code> times in the integration's global settings.</p>"},{"location":"features/sensor-correlation/","title":"Sensor Correlation &amp; Continuous Likelihood","text":"<p>The Area Occupancy Detection integration uses advanced statistical analysis to learn occupancy patterns from sensors. The system uses different analysis methods depending on sensor type:</p> <ul> <li>Numeric Sensors (Temperature, Humidity, CO2, etc.): Use correlation analysis with Gaussian Probability Density Functions (PDFs) to calculate continuous, dynamic likelihoods based on exact sensor values.</li> <li>Binary Sensors (Media Players, Appliances, Doors, Windows): Use duration-based analysis to calculate static probabilities from interval overlap durations.</li> </ul>"},{"location":"features/sensor-correlation/#overview","title":"Overview","text":"<p>While motion sensors directly indicate presence, other sensors often show correlation with occupancy. For example:</p> <ul> <li>Numeric Sensors:</li> <li>Temperature might rise when people are in a room.</li> <li>CO2 levels often increase with occupancy.</li> <li>Humidity might change when a shower is used.</li> <li>Binary Sensors:</li> <li>Media Players might be playing when occupied.</li> <li>Appliances might be running when occupied.</li> <li>Doors/Windows might be open more often when occupied.</li> </ul> <p>The system analyses these patterns differently:</p> <ul> <li>Numeric sensors use correlation analysis to learn statistical distributions and calculate dynamic likelihoods.</li> <li>Binary sensors use duration-based analysis to calculate static probabilities directly from how long they're active during occupied vs. unoccupied periods.</li> </ul>"},{"location":"features/sensor-correlation/#how-it-works","title":"How It Works","text":"<p>The system uses different analysis methods for numeric and binary sensors:</p>"},{"location":"features/sensor-correlation/#numeric-sensors-correlation-analysis","title":"Numeric Sensors: Correlation Analysis","text":""},{"location":"features/sensor-correlation/#1-correlation-check-qualification","title":"1. Correlation Check (Qualification)","text":"<p>Every hour as part of the analysis cycle, the system analyses the relationship between the sensor's value and the area's occupancy state using the Pearson correlation coefficient.</p> <p>The system classifies correlations into different types based on their strength:</p> <ul> <li>Strong Positive Correlation (\u2265 0.4): Value increases significantly when occupied. Classified as <code>strong_positive</code>.</li> <li>Strong Negative Correlation (\u2264 -0.4): Value decreases significantly when occupied. Classified as <code>strong_negative</code>.</li> <li>Weak Positive Correlation (0.15 to 0.4): Value increases moderately when occupied. Classified as <code>positive</code>.</li> <li>Weak Negative Correlation (-0.4 to -0.15): Value decreases moderately when occupied. Classified as <code>negative</code>.</li> <li>No Correlation (&lt; 0.15 absolute value): No meaningful pattern found. Classified as <code>none</code> with <code>analysis_error: \"no_correlation\"</code>.</li> </ul> <p>Thresholds:</p> <ul> <li>Weak Correlation Threshold: 0.15 - Minimum correlation strength to be considered meaningful</li> <li>Moderate Correlation Threshold: 0.4 - Minimum correlation strength for strong correlations</li> </ul> <p>Both strong and weak correlations are used for occupancy detection using the same Gaussian PDF approach. Only correlations below the weak threshold (&lt; 0.15) are rejected to prevent false positives from noise.</p>"},{"location":"features/sensor-correlation/#2-learning-distributions","title":"2. Learning Distributions","text":"<p>If a sensor qualifies, the system learns two statistical distributions:</p> <ol> <li>Occupied Distribution: \\((\\mu_{occ}, \\sigma_{occ})\\) - The pattern when the room is known to be occupied.</li> <li>Unoccupied Distribution: \\((\\mu_{unocc}, \\sigma_{unocc})\\) - The pattern when the room is known to be empty.</li> </ol> <p>These parameters are stored in the <code>Correlations</code> database table.</p>"},{"location":"features/sensor-correlation/#3-calculating-dynamic-likelihood","title":"3. Calculating Dynamic Likelihood","text":"<p>When the sensor reports a new value \\(x\\), the system calculates two probability densities using the Gaussian PDF formula:</p> \\[ f(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{-\\frac{1}{2}(\\frac{x-\\mu}{\\sigma})^2} \\] <ol> <li>\\(P(x | Occupied)\\): Likelihood of \\(x\\) given the \"Occupied\" distribution.</li> <li>\\(P(x | Unoccupied)\\): Likelihood of \\(x\\) given the \"Unoccupied\" distribution.</li> </ol>"},{"location":"features/sensor-correlation/#4-bayesian-update","title":"4. Bayesian Update","text":"<p>These densities are used directly in the Bayesian update formula.</p> <ul> <li>If \\(x\\) is closer to the Occupied Mean, the likelihood ratio favors occupancy.</li> <li>If \\(x\\) is closer to the Unoccupied Mean, it favors vacancy.</li> <li>The strength of the evidence scales with how extreme the value is relative to the distributions.</li> </ul>"},{"location":"features/sensor-correlation/#binary-sensors-duration-based-analysis","title":"Binary Sensors: Duration-Based Analysis","text":""},{"location":"features/sensor-correlation/#1-interval-overlap-calculation","title":"1. Interval Overlap Calculation","text":"<p>The system calculates how long each binary sensor interval overlaps with occupied vs. unoccupied periods:</p> <ul> <li>Active Duration During Occupied: Total seconds the sensor is active while the area is occupied.</li> <li>Active Duration During Unoccupied: Total seconds the sensor is active while the area is unoccupied.</li> <li>Total Occupied Duration: Total seconds the area is occupied.</li> <li>Total Unoccupied Duration: Total seconds the area is unoccupied.</li> </ul>"},{"location":"features/sensor-correlation/#2-static-probability-calculation","title":"2. Static Probability Calculation","text":"<p>The system calculates two static probabilities:</p> <ol> <li>\\(P(Active | Occupied)\\): <code>active_duration_occupied / total_occupied_duration</code></li> <li>\\(P(Active | Unoccupied)\\): <code>active_duration_unoccupied / total_unoccupied_duration</code></li> </ol> <p>These probabilities are clamped between 0.05 and 0.95 to avoid extreme values.</p>"},{"location":"features/sensor-correlation/#3-storage-and-usage","title":"3. Storage and Usage","text":"<p>These static probabilities are stored directly in the <code>Entities</code> table as <code>prob_given_true</code> and <code>prob_given_false</code>. They are used at runtime regardless of the current sensor state.</p>"},{"location":"features/sensor-correlation/#example","title":"Example","text":"<p>Scenario: Temperature Sensor</p> <ul> <li>Unoccupied: Mean = 20\u00b0C</li> <li>Occupied: Mean = 24\u00b0C</li> </ul> Current Temp (\\(x\\)) Result 20\u00b0C Strong Vacancy Evidence (Matches Unoccupied mean) 22\u00b0C Neutral (Ambiguous overlap) 24\u00b0C Strong Occupancy Evidence (Matches Occupied mean) <p>Scenario: Media Player (Binary)</p> <ul> <li>\\(P(Active | Occupied)\\): 0.85 (85% chance it's playing when occupied)</li> <li>\\(P(Active | Unoccupied)\\): 0.05 (5% chance it's playing when unoccupied)</li> </ul> Current State Occupied Probability Used Unoccupied Probability Used Notes OFF 0.15 0.95 Inverse probabilities ON 0.85 0.05 Direct probabilities"},{"location":"features/sensor-correlation/#benefits","title":"Benefits","text":"<ol> <li>Appropriate Analysis Methods: Numeric sensors use dynamic PDF calculation for continuous values, while binary sensors use simple duration-based probabilities.</li> <li>No \"Cliff Edge\" (Numeric): Small changes in sensor values result in small changes in probability.</li> <li>True Evidence Weighting (Numeric): Extreme values provide stronger evidence.</li> <li>Automatic Calibration: The system learns what is \"normal\" for each specific room.</li> <li>Simple and Reliable (Binary): Duration-based analysis provides straightforward probabilities for binary states.</li> </ol>"},{"location":"features/sensor-correlation/#data-flow","title":"Data Flow","text":"<ol> <li>Data Collection:</li> <li>Numeric Sensors: <code>NumericSamples</code> are recorded on sensor changes.</li> <li>Binary Sensors: <code>Intervals</code> are recorded (on/off periods with timestamps).</li> <li><code>OccupiedIntervalsCache</code> tracks occupancy (ground truth from motion sensors).</li> <li>Hourly Analysis:</li> <li>Numeric Sensors: <code>analyze_correlation()</code> runs correlation analysis and learns Gaussian parameters.</li> <li>Binary Sensors: <code>analyze_binary_likelihoods()</code> calculates duration-based static probabilities.</li> <li>Entity Update:</li> <li>Numeric Sensors: Live <code>Entity</code> objects are updated with <code>learned_gaussian_params</code>.</li> <li>Binary Sensors: Live <code>Entity</code> objects are updated with <code>prob_given_true</code> and <code>prob_given_false</code>.</li> <li>Runtime Usage: Likelihoods are retrieved via <code>get_likelihoods()</code> which uses the appropriate method based on sensor type.</li> </ol>"},{"location":"features/sensor-correlation/#viewing-results","title":"Viewing Results","text":"<p>Call the <code>area_occupancy.run_analysis</code> service to view results:</p> <p>Numeric Sensor Example:</p> <pre><code>sensor.lounge_temperature:\n  type: temperature\n  prob_given_true: 0.75 # Runtime calculated from Gaussian PDF\n  prob_given_false: 0.15\n  active_range: [20.0, 24.0] # Learned active range\n  analysis_data:\n    mean_occupied: 24.0\n    std_occupied: 1.0\n    mean_unoccupied: 20.0\n    std_unoccupied: 1.0\n  analysis_error: null\n</code></pre> <p>Binary Sensor Example:</p> <pre><code>light.study_bulb_1:\n  type: appliance\n  prob_given_true: 0.85 # Static probability from duration analysis\n  prob_given_false: 0.10\n  active_states: [\"on\", \"standby\"]\n  analysis_data: null # Binary sensors don't store Gaussian params\n  analysis_error: null\n</code></pre> <p>If a sensor analysis fails, you might see:</p> <pre><code>sensor.random_noise:\n  prob_given_true: 0.09 # Falls back to EntityType defaults\n  prob_given_false: 0.01\n  analysis_error: \"no_correlation\"\n  analysis_data: null\n</code></pre>"},{"location":"features/sensors/","title":"Sensors","text":""},{"location":"features/sensors/#sensor-selection","title":"Sensor Selection","text":"<p>You will be prompted to select entities for various categories. You only need to select sensors relevant to the specific area you are configuring.</p> Sensor Type Entity Type Description Default States/Range Motion Sensors <code>binary_sensor</code> Additional motion sensors in the area such as PIR or mmWave sensors. <code>on</code> Door Sensors <code>binary_sensor</code> Relevant door sensors. <code>Closed</code> Window Sensors <code>binary_sensor</code> Relevant window sensors. <code>Open</code> Media Devices <code>media_player</code> Relevant media players. <code>playing</code>, <code>paused</code> Appliances <code>switch</code>, <code>binary_sensor</code>, <code>sensor</code> Relevant switch or sensor entities representing appliances. <code>on</code>, <code>standby</code> Illuminance Sensors <code>sensor</code> Illuminance sensors measuring light levels (lux) <code>30.0 - 100000.0</code> Temperature Sensors <code>sensor</code> Temperature sensors measuring temperature <code>18.0 - 24.0</code> Humidity Sensors <code>sensor</code> Humidity sensors measuring humidity <code>70.0 - 100.0</code> CO2 Sensors <code>sensor</code> Carbon dioxide sensors measuring CO2 levels (ppm) <code>400.0 - 1200.0</code> CO Sensors <code>sensor</code> Carbon monoxide sensors measuring CO levels (ppm) <code>5.0 - 50.0</code> Sound Pressure Sensors <code>sensor</code> Sound pressure sensors measuring noise levels in decibels (dB) <code>40.0 - 80.0</code> Atmospheric Pressure Sensors <code>sensor</code> Atmospheric pressure sensors measuring air pressure (hPa) <code>980.0 - 1050.0</code> Air Quality Index Sensors <code>sensor</code> Air quality index sensors measuring overall air quality <code>50.0 - 150.0</code> VOC Sensors <code>sensor</code> Volatile organic compound sensors measuring VOC levels (ppb) <code>200.0 - 1000.0</code> PM2.5 Sensors <code>sensor</code> Particulate matter sensors measuring PM2.5 levels (\u00b5g/m\u00b3) <code>12.0 - 55.0</code> PM10 Sensors <code>sensor</code> Particulate matter sensors measuring PM10 levels (\u00b5g/m\u00b3) <code>55.0 - 155.0</code> Cover Sensors <code>cover</code> Blinds, shades, shutters, garage doors being operated <code>opening</code>, <code>closing</code> Power Sensors <code>sensor</code> Power sensors measuring power consumption (W/kW) <code>0.1 - 10.0</code>"},{"location":"features/sensors/#sensor-weights","title":"Sensor Weights","text":"<p>Weights allow you to adjust the influence of different types of sensors on the final probability calculation. Weights range from 0.0 (no influence) to 1.0 (maximum influence). Default values are provided based on typical sensor reliability for occupancy. You can override the default weights in the configuration menu for each sensor type.</p> Sensor Type Default Weight Motion Sensor 1.00 Sleep 0.90 Media Device 0.85 Wasp in Box 0.80 Cover Sensor 0.50 Appliance 0.40 Door Sensor 0.30 Power Sensor 0.30 Window Sensor 0.20 Environmental Sensor 0.10 <p>Note</p> <p>The Sleep weight is not user-configurable per sensor. It is automatically applied when sleep presence is detected via People Management.</p>"},{"location":"features/services/","title":"Services","text":"<p>The Area Occupancy Detection integration provides services that can be called from automations or scripts.</p>"},{"location":"features/services/#area_occupancyrun_analysis","title":"<code>area_occupancy.run_analysis</code>","text":"<p>Runs the historical analysis process for all areas in the Area Occupancy instance. This imports recent state data from the recorder, updates priors and likelihoods, and refreshes the coordinator.</p> <p>Example:</p> <pre><code>service: area_occupancy.run_analysis\n</code></pre> <p>Returns:</p> <ul> <li><code>areas</code>: Dictionary mapping area names to their analysis data. Each area contains:</li> <li><code>area_name</code>: Name of the area</li> <li><code>current_prior</code>: Current global prior probability</li> <li><code>global_prior</code>: Global prior after analysis</li> <li><code>time_prior</code>: Time-based prior used in calculations</li> <li><code>prior_entity_ids</code>: List of entities included in analysis</li> <li><code>total_entities</code>: Total number of entities</li> <li><code>entity_states</code>: Current states of all entities</li> <li><code>likelihoods</code>: Updated likelihood data per entity. Each entity in <code>likelihoods</code> contains:<ul> <li><code>analysis_error</code>: Error code indicating why analysis failed or was not performed (see below)</li> </ul> </li> <li><code>update_timestamp</code>: ISO timestamp of when the analysis completed</li> <li><code>analysis_time_ms</code>: Total time taken for the full analysis in milliseconds (float)</li> <li><code>device_sw_version</code>: Integration software version string</li> </ul>"},{"location":"features/services/#analysis_error-values","title":"<code>analysis_error</code> Values","text":"<p>The <code>analysis_error</code> field in each entity's likelihood data indicates why correlation analysis failed or was not performed. Possible values:</p> <ul> <li><code>null</code> - Analysis completed successfully with no errors</li> <li><code>\"not_analyzed\"</code> - Entity has not been analyzed yet (default state for non-motion sensors before first analysis)</li> <li><code>\"motion_sensor_excluded\"</code> - Motion sensors are excluded from correlation analysis by design, as they are used to determine occupancy rather than correlate with it</li> <li><code>\"no_occupied_intervals\"</code> - No occupied time intervals were found in the analysis period, so correlation cannot be calculated</li> <li><code>\"no_occupied_time\"</code> - The total occupied time in the analysis period is zero or negative, indicating insufficient occupancy data</li> <li><code>\"no_unoccupied_time\"</code> - The total unoccupied time in the analysis period is zero or negative, indicating the area was occupied for the entire period</li> <li><code>\"no_sensor_data\"</code> - No sensor interval data was found for this entity in the analysis period</li> <li><code>\"no_occupied_samples\"</code> - No sensor samples were found when the area was occupied, preventing correlation calculation</li> <li><code>\"no_unoccupied_samples\"</code> - No sensor samples were found when the area was unoccupied, preventing correlation calculation</li> <li><code>\"no_correlation\"</code> - The correlation coefficient is below the moderate threshold, indicating no meaningful correlation between the sensor and occupancy</li> <li><code>\"too_few_samples\"</code> - Insufficient samples collected for reliable correlation analysis (below minimum threshold)</li> <li><code>\"too_few_samples_after_filtering\"</code> - After filtering samples, there are insufficient samples remaining for correlation analysis</li> <li><code>\"no_occupancy_data\"</code> - No occupied intervals were found for analysis validation</li> </ul> <p>Notes:</p> <ul> <li>This service always runs analysis for all configured areas.</li> <li>Services that query historical data can be resource-intensive.</li> <li>Analysis results (including <code>analysis_error</code> values) are persisted to the database and will be restored when entities are reloaded. This ensures that <code>analysis_error</code> values are preserved across Home Assistant restarts and entity reloads.</li> </ul>"},{"location":"features/services/#area_occupancyexport_config","title":"<code>area_occupancy.export_config</code>","text":"<p>Exports the complete integration configuration as YAML. This is useful for debugging, sharing your setup when reporting issues, or backing up your configuration.</p> <p>Example:</p> <pre><code>service: area_occupancy.export_config\n</code></pre> <p>Returns:</p> <p>The full merged configuration (config entry data + options) as a dictionary. Each area configuration is reordered so that <code>area_id</code> appears first for readability. The response includes:</p> <ul> <li>All area configurations (sensors, weights, thresholds, decay settings, purpose, etc.)</li> <li>People configurations (person entities, sleep sensors, sleep areas)</li> <li>Global settings (sleep schedule)</li> </ul> <p>Viewing the output</p> <p>Call this service from Developer Tools &gt; Services in Home Assistant. The response is rendered as YAML directly in the UI, making it easy to review or copy your full configuration.</p>"},{"location":"features/sleep-presence/","title":"Sleep Presence Detection","text":"<p>Sleep presence detection identifies when people are sleeping in an area, using Home Assistant Person entities combined with one or more sleep detection sensors. This supports a wide range of devices including the Companion App sleep confidence, iOS Sleep Focus, Withings sleep mats, and any other binary or numeric sleep sensor.</p>"},{"location":"features/sleep-presence/#how-it-works","title":"How It Works","text":"<p>The system pairs two pieces of information per person:</p> <ol> <li>Person entity (<code>person.&lt;name&gt;</code>): Tracks whether the person is <code>home</code> or <code>not_home</code>. If a device tracker override is configured, that entity's state is used instead.</li> <li>Sleep sensors: One or more sensors that indicate sleep. Two types are supported:<ul> <li>Numeric sensors (e.g., <code>sensor.&lt;name&gt;_sleep_confidence</code>): A 0-100 value where the person is considered sleeping when the value is at or above the configured confidence threshold.</li> <li>Binary sensors (e.g., <code>binary_sensor.&lt;name&gt;_in_bed</code>, <code>binary_sensor.&lt;name&gt;_sleep_focus</code>): The person is considered sleeping when the sensor is <code>on</code>.</li> </ul> </li> </ol> <p>When both conditions are met \u2014 the person is home (per the person entity or the overriding device tracker) and any of their sleep sensors is active \u2014 the sleep presence sensor for the assigned area turns on.</p> <p>When to use the device tracker override</p> <p>HA's Person entity aggregates all associated device trackers and reports <code>home</code> when any tracker is home. If you have multiple trackers (e.g., phone GPS, router presence) and one is more reliable for sleep detection, set it as the override so the sleep check uses that specific tracker instead of the aggregated result.</p>"},{"location":"features/sleep-presence/#configuration","title":"Configuration","text":"<p>Sleep presence is configured through the Manage People option in the integration's main menu:</p> <ol> <li>Navigate to Settings &gt; Devices &amp; Services &gt; Integrations &gt; Area Occupancy Detection &gt; Configure.</li> <li>Select Manage People from the main menu.</li> <li>For each person, configure:</li> </ol> Setting Description Person Entity The <code>person.&lt;name&gt;</code> entity to track Sleep Sensors One or more sleep detection sensors. Supports numeric sensors (e.g., sleep confidence 0-100%) and binary sensors (e.g., in-bed sensor, Sleep Focus). Any active sensor means the person is sleeping. Sleep Area Which area this person sleeps in Confidence Threshold Minimum value (0-100) for numeric sleep sensors to consider the person sleeping. Does not apply to binary sensors. Default: 75 Device Tracker (optional) A specific <code>device_tracker</code> entity to use for home/away detection instead of the person entity. When set, this tracker's state is checked instead of <code>person.&lt;name&gt;</code>. Leave empty to use the person entity (default). <p>You can add multiple people, each assigned to a different (or the same) sleep area.</p> <p>Supported sleep sensors</p> <ul> <li>Android Companion App: <code>sensor.&lt;name&gt;_sleep_confidence</code> (numeric, 0-100)</li> <li>iOS Sleep Focus: <code>binary_sensor.&lt;name&gt;_sleep_focus</code> (binary)</li> <li>Withings Sleep Mat: <code>binary_sensor.&lt;name&gt;_in_bed</code> (binary)</li> <li>Any binary sensor that turns <code>on</code> when sleeping</li> </ul>"},{"location":"features/sleep-presence/#created-entity","title":"Created Entity","text":"<p>For each area that has at least one person assigned, a binary sensor is created:</p> <ul> <li><code>binary_sensor.&lt;area&gt;_sleeping</code> (Sleeping)<ul> <li>State: <code>on</code> / <code>off</code></li> <li>Description: Turns <code>on</code> when one or more assigned people are detected as sleeping in this area.</li> <li>Device Class: <code>occupancy</code></li> <li>Icon: <code>mdi:sleep</code></li> <li>Attributes:</li> </ul> </li> </ul> Attribute Description <code>people_sleeping</code> List of friendly names of people currently sleeping <code>people</code> Detailed list with <code>person_name</code>, <code>person_state</code>, <code>sleep_confidence</code>, <code>sleep_threshold</code>, and <code>sleeping</code> (bool) per person"},{"location":"features/sleep-presence/#impact-on-occupancy","title":"Impact on Occupancy","text":"<p>The sleep presence sensor feeds into the occupancy calculation as an <code>InputType.SLEEP</code> entity:</p> <ul> <li>Weight: 0.90 (very strong influence)</li> <li>P(Active | Occupied): 0.95</li> <li>P(Active | Not Occupied): 0.02</li> <li>Decay half-life: 2 hours (7200 seconds)</li> </ul> <p>This means that when sleep is detected, the area will be held at a high occupancy probability. When sleep ends, the probability decays gradually over roughly 2 hours rather than dropping instantly.</p>"},{"location":"features/sleep-presence/#requirements","title":"Requirements","text":"<ul> <li>Person entities configured in Home Assistant</li> <li>At least one sleep detection sensor per person (Companion App, in-bed sensor, Sleep Focus, etc.)</li> <li>At least one area configured in the integration</li> </ul>"},{"location":"features/sleep-presence/#tips","title":"Tips","text":"<ul> <li>Threshold tuning: Start with the default threshold of 75 for numeric sensors. If the sensor doesn't trigger reliably, decrease it. If it triggers too easily (e.g., while watching TV in bed), increase it. Binary sensors ignore the threshold entirely.</li> <li>Multiple sensors per person: You can combine multiple sleep sensors for better reliability. For example, use both a phone sleep confidence sensor and a Withings sleep mat. If any sensor is active, the person is considered sleeping.</li> <li>Multiple bedrooms: Each person can be assigned to a different sleep area, making this work well for households with multiple bedrooms.</li> <li>Interaction with Bedroom purpose: Sleep presence works alongside the Bedroom purpose decay settings. During sleep, the combination of long bedroom decay and the sleep sensor's own 2-hour decay half-life provides very stable occupancy.</li> </ul> <p>Migration from single sensor</p> <p>If you previously configured a single sleep confidence sensor per person, the integration automatically migrates this to the new multi-sensor format. Your existing configuration will continue to work without any changes.</p>"},{"location":"features/wasp-in-box/","title":"Wasp in Box","text":"<p>The \"Wasp in Box\" feature provides enhanced occupancy detection for rooms with a single entry/exit point (like bathrooms, closets, or small offices). It uses a simple but effective principle: if someone enters a room and the door closes, they remain in that room until the door opens again.</p>"},{"location":"features/wasp-in-box/#concept","title":"Concept","text":"<p>The feature is named after the concept of a wasp trapped in a box - once inside, it remains there until an opening appears. Similarly, once a person enters a closed space, they must be considered \"present\" until they exit through the door.</p>"},{"location":"features/wasp-in-box/#configuration","title":"Configuration","text":"<p>The Wasp in Box sensor can be configured in the integration settings:</p> Setting Description Default Related Scenarios Enable Wasp in Box Turn this virtual sensor on or off Disabled All scenarios Motion Timeout How long motion events are considered recent (in seconds) 300s (5 min) Scenarios 3, 4 Wasp Weight The weight factor for this sensor in probability calculations (0.1-1.0) 0.8 N/A (probability) Maximum Duration Maximum time (in seconds) a space can be marked as occupied before automatically resetting (0 = no limit) 0 (disabled) Scenario 11 Verification Delay Delay before re-checking motion to verify occupancy, in seconds (0-120, 0 = disabled) 0 (disabled) Scenarios 10a, 10b"},{"location":"features/wasp-in-box/#core-principles","title":"Core Principles","text":"<p>The sensor implements three fundamental rules:</p> <ol> <li>ANY door opening releases occupancy - The \"wasp\" can escape through any available exit</li> <li>ALL doors must be closed for occupancy - The \"box\" must be sealed to trap the \"wasp\"</li> <li>ANY motion indicates presence - Even a single motion sensor detecting movement confirms the \"wasp\" is present</li> </ol>"},{"location":"features/wasp-in-box/#logic-flow-chart","title":"Logic Flow Chart","text":"<p>The following diagram shows how the sensor processes events and makes occupancy decisions:</p> <pre><code>flowchart TD\n    Start([\"Event Received\"]) --&gt; EventType{\"Event Type?\"}\n    EventType -- Door Event --&gt; DoorChange[\"Door State Changed\"]\n    EventType -- Motion Event --&gt; MotionChange[\"Motion State Changed\"]\n    DoorChange --&gt; UpdateDoorAgg[\"Calculate Aggregate Door State&lt;br&gt;ANY door open = OPEN&lt;br&gt;ALL doors closed = CLOSED\"]\n    UpdateDoorAgg --&gt; CheckDoorOpen{\"Aggregate Door&lt;br&gt;State = OPEN?\"}\n    CheckDoorOpen -- Yes --&gt; CheckCurrentlyOccupied{\"Currently&lt;br&gt;Occupied?\"}\n    CheckCurrentlyOccupied -- Yes --&gt; ReleaseOccupancy[\"Set UNOCCUPIED&lt;br&gt;Cancel Timers\"]\n    CheckCurrentlyOccupied -- No --&gt; NoChange1[\"No State Change\"]\n    CheckDoorOpen -- No: All Closed --&gt; CheckMotionActive{\"Any Motion&lt;br&gt;Active?\"}\n    CheckMotionActive -- Yes --&gt; SetOccupied[\"Set OCCUPIED&lt;br&gt;Start Timers\"]\n    CheckMotionActive -- No --&gt; CheckRecentMotion{\"Recent Motion&lt;br&gt;Within Timeout?\"}\n    CheckRecentMotion -- Yes --&gt; SetOccupied\n    CheckRecentMotion -- No --&gt; NoChange2[\"No State Change\"]\n    MotionChange --&gt; UpdateMotionAgg[\"Calculate Aggregate Motion State&lt;br&gt;ANY motion active = ON&lt;br&gt;ALL motion off = OFF\"]\n    UpdateMotionAgg --&gt; CheckMotionOn{\"Motion&lt;br&gt;Turned ON?\"}\n    CheckMotionOn -- Yes --&gt; RecordTime[\"Record Motion Time\"]\n    CheckMotionOn -- No --&gt; MotionOff[\"Motion Cleared\"]\n    RecordTime --&gt; CheckDoorsClosedMotion{\"All Doors&lt;br&gt;Closed?\"}\n    CheckDoorsClosedMotion -- Yes --&gt; SetOccupied\n    CheckDoorsClosedMotion -- No --&gt; NoChange3[\"No State Change\"]\n    MotionOff --&gt; CheckOccupiedMotion{\"Currently&lt;br&gt;Occupied?\"}\n    CheckOccupiedMotion -- Yes --&gt; MaintainState[\"Maintain OCCUPIED&lt;br&gt;Wasp in Box Logic\"]\n    CheckOccupiedMotion -- No --&gt; NoChange4[\"No State Change\"]\n    ReleaseOccupancy --&gt; End([\"Update HA State\"])\n    SetOccupied --&gt; End\n    NoChange1 --&gt; End\n    NoChange2 --&gt; End\n    NoChange3 --&gt; End\n    NoChange4 --&gt; End\n    MaintainState --&gt; End\n\n    style ReleaseOccupancy fill:#D50000,color:#FFFFFF\n    style SetOccupied fill:#006127,color:#FFFFFF\n    style MaintainState fill:#2962FF,color:#FFFFFF</code></pre> <p>Key Decision Points:</p> <ul> <li>Door Opens: If ANY door opens while occupied \u2192 immediate release</li> <li>All Doors Close: Check for active or recent motion to trigger occupancy</li> <li>Motion Detected: If all doors are closed \u2192 trigger occupancy</li> <li>Motion Clears: If occupied \u2192 maintain state (wasp in box principle)</li> </ul>"},{"location":"features/wasp-in-box/#complete-scenario-reference","title":"Complete Scenario Reference","text":"<p>This section documents every possible combination of door and motion events and the expected sensor behavior.</p>"},{"location":"features/wasp-in-box/#basic-entry-scenarios","title":"Basic Entry Scenarios","text":""},{"location":"features/wasp-in-box/#scenario-1-door-closes-motion-detected","title":"Scenario 1: Door Closes \u2192 Motion Detected","text":"<p>Initial State: Sensor OFF, Door OPEN, Motion OFF</p> <ol> <li>Door CLOSES \u2192 Sensor stays OFF (no motion yet)</li> <li>Motion DETECTED \u2192 Sensor turns ON \u2713</li> </ol> <p>Logic: Motion detected with door closed triggers occupancy</p>"},{"location":"features/wasp-in-box/#scenario-2-motion-detected-door-closes","title":"Scenario 2: Motion Detected \u2192 Door Closes","text":"<p>Initial State: Sensor OFF, Door OPEN, Motion ON</p> <ol> <li>Motion DETECTED (door open) \u2192 Sensor stays OFF (door still open)</li> <li>Door CLOSES \u2192 Sensor turns ON \u2713</li> </ol> <p>Logic: Door closes with active motion triggers occupancy</p>"},{"location":"features/wasp-in-box/#scenario-3-motion-clears-door-closes-within-timeout","title":"Scenario 3: Motion \u2192 Clears \u2192 Door Closes (Within Timeout)","text":"<p>Initial State: Sensor OFF, Door OPEN, Motion OFF</p> <ol> <li>Motion DETECTED \u2192 Sensor stays OFF (door still open)</li> <li>Motion CLEARS \u2192 Sensor stays OFF</li> <li>Wait &lt; motion_timeout seconds</li> <li>Door CLOSES \u2192 Sensor turns ON \u2713</li> </ol> <p>Logic: Door closes with recent motion (within timeout window) triggers occupancy. This is the classic \"person enters room\" pattern.</p>"},{"location":"features/wasp-in-box/#scenario-4-motion-clears-door-closes-after-timeout","title":"Scenario 4: Motion \u2192 Clears \u2192 Door Closes (After Timeout)","text":"<p>Initial State: Sensor OFF, Door OPEN, Motion OFF</p> <ol> <li>Motion DETECTED \u2192 Sensor stays OFF (door still open)</li> <li>Motion CLEARS \u2192 Sensor stays OFF</li> <li>Wait &gt; motion_timeout seconds</li> <li>Door CLOSES \u2192 Sensor stays OFF \u2717</li> </ol> <p>Logic: Door closes but motion is too old (outside timeout window). This prevents false positives from stale motion events.</p>"},{"location":"features/wasp-in-box/#exit-and-persistence-scenarios","title":"Exit and Persistence Scenarios","text":""},{"location":"features/wasp-in-box/#scenario-5-door-opens-while-occupied","title":"Scenario 5: Door Opens While Occupied","text":"<p>Initial State: Sensor ON, Door CLOSED, Motion OFF</p> <ul> <li>Door OPENS \u2192 Sensor turns OFF \u2713</li> </ul> <p>Logic: Door opening always clears occupancy (the \"wasp escapes\" through any exit)</p>"},{"location":"features/wasp-in-box/#scenario-6-motion-clears-while-occupied","title":"Scenario 6: Motion Clears While Occupied","text":"<p>Initial State: Sensor ON, Door CLOSED, Motion ON</p> <ul> <li>Motion CLEARS \u2192 Sensor stays ON \u2713</li> </ul> <p>Logic: Once occupied, sensor maintains state until door opens. This is the core \"wasp in box\" behavior - motion stopping doesn't mean the person left.</p>"},{"location":"features/wasp-in-box/#scenario-7-motion-detected-with-door-already-closed","title":"Scenario 7: Motion Detected With Door Already Closed","text":"<p>Initial State: Sensor OFF, Door CLOSED, Motion OFF</p> <ul> <li>Motion DETECTED \u2192 Sensor turns ON \u2713</li> </ul> <p>Logic: Motion with door closed immediately triggers occupancy</p>"},{"location":"features/wasp-in-box/#door-cycle-scenarios","title":"Door Cycle Scenarios","text":""},{"location":"features/wasp-in-box/#scenario-8-multiple-door-cycles-without-motion","title":"Scenario 8: Multiple Door Cycles Without Motion","text":"<p>Initial State: Sensor OFF, Door CLOSED, Motion OFF</p> <ol> <li>Door OPENS \u2192 Sensor stays OFF</li> <li>Door CLOSES \u2192 Sensor stays OFF (no motion)</li> <li>Door OPENS again \u2192 Sensor stays OFF</li> <li>Door CLOSES again \u2192 Sensor stays OFF \u2717</li> </ol> <p>Logic: Door cycles without motion don't trigger occupancy. A person must be detected entering.</p>"},{"location":"features/wasp-in-box/#scenario-9-quick-entry-then-exit","title":"Scenario 9: Quick Entry Then Exit","text":"<p>Initial State: Sensor OFF, Door CLOSED, Motion OFF</p> <ol> <li>Door OPENS \u2192 Sensor stays OFF</li> <li>Motion DETECTED (briefly) \u2192 Sensor stays OFF (door open)</li> <li>Motion CLEARS</li> <li>Door CLOSES (within motion_timeout) \u2192 Sensor turns ON</li> <li>Door OPENS immediately \u2192 Sensor turns OFF \u2713</li> </ol> <p>Logic: Detects person entering then immediately leaving. Motion during entry is captured, triggers occupancy when door closes, then door opening releases them.</p>"},{"location":"features/wasp-in-box/#verification-scenarios-if-enabled","title":"Verification Scenarios (if enabled)","text":""},{"location":"features/wasp-in-box/#scenario-10a-motion-sustained-through-verification","title":"Scenario 10a: Motion Sustained Through Verification","text":"<p>Initial State: Sensor OFF, verification_delay = 30s</p> <ol> <li>Sensor turns ON (entry detected) \u2192 Verification timer starts</li> <li>Wait 30 seconds</li> <li>Motion still ON \u2192 Sensor stays ON \u2713</li> </ol> <p>Logic: Verification confirms genuine occupancy</p>"},{"location":"features/wasp-in-box/#scenario-10b-motion-clears-before-verification","title":"Scenario 10b: Motion Clears Before Verification","text":"<p>Initial State: Sensor OFF, verification_delay = 30s</p> <ol> <li>Sensor turns ON (entry detected) \u2192 Verification timer starts</li> <li>Motion CLEARS</li> <li>Wait 30 seconds</li> <li>No motion detected \u2192 Sensor turns OFF \u2713</li> </ol> <p>Logic: Verification detected a false positive (e.g., sensor cooldown caused initial trigger). This prevents false occupancy from quick in-and-out movements.</p>"},{"location":"features/wasp-in-box/#timeout-scenarios","title":"Timeout Scenarios","text":""},{"location":"features/wasp-in-box/#scenario-11-maximum-duration-timeout","title":"Scenario 11: Maximum Duration Timeout","text":"<p>Initial State: Sensor ON, max_duration = 3600s (1 hour)</p> <ul> <li>Wait &gt; 3600 seconds \u2192 Sensor turns OFF \u2713</li> </ul> <p>Logic: Safety timeout prevents sensor staying ON indefinitely if someone exits through an unmonitored path</p>"},{"location":"features/wasp-in-box/#multiple-sensor-scenarios","title":"Multiple Sensor Scenarios","text":""},{"location":"features/wasp-in-box/#scenario-12-multiple-doors-any-door-opens","title":"Scenario 12: Multiple Doors - Any Door Opens","text":"<p>Initial State: Sensor ON, Door A CLOSED, Door B CLOSED</p> <ol> <li>Door A OPENS \u2192 Sensor turns OFF \u2713</li> <li>(Door B still closed)</li> </ol> <p>Logic: ANY door opening releases occupancy, regardless of which door or how many other doors remain closed</p>"},{"location":"features/wasp-in-box/#scenario-13-multiple-doors-all-must-close","title":"Scenario 13: Multiple Doors - All Must Close","text":"<p>Initial State: Sensor OFF, Door A OPEN, Door B CLOSED, Motion ON</p> <ol> <li>Motion DETECTED \u2192 Sensor stays OFF (Door A still open)</li> <li>Door B OPENS then CLOSES \u2192 Sensor stays OFF (Door A still open)</li> <li>Door A CLOSES \u2192 Sensor turns ON \u2713 (all doors now closed)</li> </ol> <p>Logic: ALL doors must be closed for occupancy to trigger</p>"},{"location":"features/wasp-in-box/#scenario-14-multiple-motion-sensors-any-triggers","title":"Scenario 14: Multiple Motion Sensors - Any Triggers","text":"<p>Initial State: Sensor OFF, All Doors CLOSED, Motion1 OFF, Motion2 OFF</p> <ol> <li>Motion2 DETECTED (Motion1 still OFF) \u2192 Sensor turns ON \u2713</li> </ol> <p>Logic: ANY motion sensor detecting movement triggers occupancy when doors are closed</p>"},{"location":"features/wasp-in-box/#scenario-15-multiple-motion-sensors-staggered-detection","title":"Scenario 15: Multiple Motion Sensors - Staggered Detection","text":"<p>Initial State: Sensor OFF, All Doors CLOSED</p> <ol> <li>Motion1 DETECTED \u2192 Sensor turns ON</li> <li>Motion1 CLEARS</li> <li>Motion2 DETECTED \u2192 Sensor stays ON \u2713</li> <li>Motion2 CLEARS \u2192 Sensor stays ON \u2713 (wasp in box)</li> <li>Door opens \u2192 Sensor turns OFF</li> </ol> <p>Logic: ANY motion keeps occupancy active. Once all motion clears, wasp-in-box logic maintains occupancy until door opens.</p>"},{"location":"features/wasp-in-box/#decision-table","title":"Decision Table","text":"<p>Quick reference for all state transitions:</p> Current State Door State Motion State Motion Recency Result Reason OFF Closes (all) ON (any) - Turn ON Entry with active motion OFF Closes (all) OFF Within timeout Turn ON Entry with recent motion OFF Closes (all) OFF Outside timeout Stay OFF Motion too old ON Opens (any) - - Turn OFF Exit detected OFF Closed (all) Turns ON - Turn ON Motion in closed room ON Closed (all) Turns OFF - Stay ON Wasp in box persists OFF Open (any) ON - Stay OFF Can't trap with open door OFF Open (any) OFF - Stay OFF No entry detected"},{"location":"features/wasp-in-box/#benefits","title":"Benefits","text":"<ul> <li>Solves the \"bathroom problem\": Traditional motion sensors often time out while someone is in the bathroom, leading to lights turning off at inconvenient moments</li> <li>Works with minimal sensors: Can function with just a door sensor if needed</li> <li>Complements motion detection: Fills the gaps where motion detection fails</li> <li>Improves automation reliability: More accurately maintains occupancy state for rooms where people may be stationary</li> <li>Supports multiple sensors: Automatically aggregates state from multiple doors and motion sensors</li> </ul>"},{"location":"features/wasp-in-box/#technical-details","title":"Technical Details","text":"<p>The Wasp in Box sensor tracks state transitions in a finite state machine:</p> <ol> <li>UNKNOWN \u2192 Initial state before any data is collected</li> <li>UNOCCUPIED \u2192 No one is in the room</li> <li>OCCUPIED \u2192 Someone is in the room</li> </ol> <p>The sensor uses Home Assistant's state tracking to monitor door and motion entities, processing their state changes to update its internal state based on the scenarios documented above.</p>"},{"location":"features/wasp-in-box/#state-persistence","title":"State Persistence","text":"<p>The sensor retains its state between Home Assistant restarts, making it reliable for long-term occupancy tracking. State restoration includes:</p> <ul> <li>Current occupancy status</li> <li>Last door event timestamp</li> <li>Last motion event timestamp</li> <li>Last occupied timestamp (for max duration calculations)</li> </ul>"},{"location":"features/wasp-in-box/#maximum-duration-feature","title":"Maximum Duration Feature","text":"<p>The sensor can be configured with a maximum occupancy duration. This addresses scenarios where a space might be incorrectly marked as occupied for extended periods:</p> <ol> <li>When enabled, the sensor will automatically reset to unoccupied after the specified duration (see Scenario 11)</li> <li>Set to 0 (default) to disable this feature and maintain the traditional Wasp in Box behavior</li> <li>Useful in environments where someone might leave through an unmonitored exit</li> </ol>"},{"location":"features/wasp-in-box/#multi-sensor-aggregation","title":"Multi-Sensor Aggregation","text":"<p>When multiple sensors are configured, the Wasp in Box sensor automatically aggregates their states:</p> <ul> <li>Multiple Doors: Returns aggregate \"OPEN\" if ANY door is open, \"CLOSED\" if all are closed (Scenarios 12, 13)</li> <li>Multiple Motion Sensors: Returns aggregate \"ON\" if ANY sensor detects motion, \"OFF\" if all are off (Scenarios 14, 15)</li> <li>Scalability: Works seamlessly with any number of door or motion sensors</li> <li>Reliability: If one sensor fails or becomes unavailable, others continue to function</li> </ul>"},{"location":"features/wasp-in-box/#integration","title":"Integration","text":"<p>The feature creates a binary sensor that becomes part of your Area Occupancy Detection system:</p> <ul> <li>Entity ID: <code>binary_sensor.[area_name]_wasp_in_box</code></li> <li>States: <code>on</code> (occupied) / <code>off</code> (unoccupied)</li> <li>Device Class: <code>occupancy</code></li> <li>Weight: The sensor's state is considered alongside other sensors in the Bayesian probability calculation, with its influence determined by the configured weight (default: 0.8)</li> <li>Decay Disabled: Unlike standard motion sensors, this sensor has probability decay disabled. When the door opens, it transitions immediately to \"OFF\", ensuring the room is marked as vacant instantly without a fading memory period.</li> </ul>"},{"location":"features/wasp-in-box/#motion-timeout","title":"Motion Timeout","text":"<p>The motion timeout (default 300 seconds = 5 minutes) determines how long after motion detection the sensor will still consider that motion \"recent\" enough to trigger occupancy when a door closes.</p> <ul> <li>Longer timeout: More forgiving, catches slower-moving people (Scenario 3)</li> <li>Shorter timeout: More precise, reduces false positives from stale motion (Scenario 4)</li> <li>Recommendation: Start with 300s and adjust based on typical entry behavior</li> </ul>"},{"location":"features/wasp-in-box/#motion-re-verification","title":"Motion Re-verification","text":"<p>The verification delay feature helps prevent false positives when people enter and exit quickly:</p> <ul> <li>How it works: When the room is marked as occupied, wait the specified delay, then re-check motion sensors (Scenarios 10a, 10b)</li> <li>If motion present: Keep the room occupied (genuine occupancy)</li> <li>If no motion: Clear occupancy (false positive from sensor cooldown)</li> <li>Recommendation: Start with 15-30 seconds for most setups; adjust based on your motion sensor cooldown periods</li> </ul>"},{"location":"features/wasp-in-box/#use-cases-examples","title":"Use Cases &amp; Examples","text":""},{"location":"features/wasp-in-box/#single-entry-point-rooms","title":"Single Entry Point Rooms","text":"<p>Perfect for rooms with one door and predictable entry/exit patterns:</p> <ul> <li>Bathrooms: Maintain occupancy even when showering or otherwise stationary (Scenario 6)</li> <li>Closets: Detect occupancy in walk-in closets with minimal sensor requirements</li> <li>Small Offices: Maintain occupancy state when people are sitting still at a desk</li> <li>Storage Rooms: Track when people are retrieving items from storage</li> </ul>"},{"location":"features/wasp-in-box/#multiple-entry-point-rooms","title":"Multiple Entry Point Rooms","text":"<p>Works with multiple doors when all exits are monitored:</p> <ul> <li>Bathrooms with en-suite access: Monitor both hallway and bedroom doors (Scenarios 12, 13)</li> <li>Pass-through spaces: Rooms with entrance and exit doors</li> <li>Note: ANY door opening releases occupancy, so all entry/exit points should have sensors</li> </ul>"},{"location":"features/wasp-in-box/#motion-detection-strategies","title":"Motion Detection Strategies","text":"<ul> <li>Comprehensive motion coverage: Multiple motion sensors ensure detection anywhere in the room (Scenarios 14, 15)</li> <li>Entry-only motion: Single sensor at entrance captures people entering (Scenarios 1-4)</li> <li>Door-only mode: Can function without motion sensors using duration-based occupancy</li> <li>Persistent occupancy: Unlike regular motion sensors, maintains state during inactivity (Scenario 6)</li> </ul>"},{"location":"features/wasp-in-box/#entity-attributes","title":"Entity Attributes","text":"<p>The sensor provides these diagnostic attributes to help understand its current state:</p> Attribute Description Example Value <code>door_state</code> Aggregate state of monitored door(s): \"on\" (open) or \"off\" (closed) <code>off</code> <code>last_door_time</code> ISO 8601 timestamp of the last door state change <code>2025-01-15T10:30:45.123Z</code> <code>motion_state</code> Aggregate state of motion sensors: \"on\" (detected) or \"off\" (clear) <code>on</code> <code>last_motion_time</code> ISO 8601 timestamp of the last motion detection <code>2025-01-15T10:29:30.456Z</code> <code>motion_timeout</code> Current motion timeout setting in seconds <code>300</code> <code>max_duration</code> Maximum occupancy duration in seconds (0 = disabled) <code>3600</code> <code>last_occupied_time</code> ISO 8601 timestamp when the space was last marked as occupied <code>2025-01-15T10:30:00.789Z</code> <code>verification_delay</code> Configured verification delay in seconds (0 = disabled) <code>30</code> <code>verification_pending</code> Whether a verification check is currently scheduled <code>true</code> / <code>false</code> <p>These attributes are useful for:</p> <ul> <li>Debugging: Understanding why the sensor changed state</li> <li>Automations: Creating advanced logic based on timing or state combinations</li> <li>Dashboards: Displaying detailed occupancy information</li> </ul>"},{"location":"getting-started/basic-usage/","title":"Basic Usage","text":"<p>Once configured, the integration creates entities for each area. The two you'll use most are Occupancy Status (a binary sensor for automations) and Occupancy Probability (the underlying confidence percentage). Everything else helps you understand and tune the system.</p>"},{"location":"getting-started/basic-usage/#what-to-focus-on-first","title":"What to Focus on First","text":"<p>After your first area is set up:</p> <ol> <li>Watch the Occupancy Probability graph in the History panel for a few hours to see how it responds to your activity</li> <li>Adjust the Threshold if needed \u2014 start at 50%, raise it if you get false positives, lower it for more sensitivity</li> <li>Let it learn \u2014 the integration analyses your sensor history automatically and gets more accurate over time</li> </ol> <p></p> <p>The graph above shows a 24-hour period for a lounge. The threshold is set at 75% because there are strong occupancy indicators (multiple motion sensors + TV as a media player). You can see clear periods of occupancy from the spikes in Occupancy Probability and the corresponding Occupancy Status turning on/off.</p> <p>The prior probability (yellow) shows the baseline \u2014 around 20% of the time someone is in this room. It fluctuates by time-of-day and day-of-week, getting more accurate the longer the integration runs.</p>"},{"location":"getting-started/basic-usage/#created-entities","title":"Created Entities","text":""},{"location":"getting-started/basic-usage/#primary-entities-use-in-automations","title":"Primary Entities (Use in Automations)","text":"<p>These are the entities you'll use day to day:</p> <p>Occupancy Status \u2014 Binary sensor showing whether the area is occupied.</p> State Description Occupied (on) Probability of occupancy is at or above the threshold. Clear (off) Probability of occupancy is below the threshold. <p>Occupancy Probability \u2014 The calculated probability (0-100%) based on all sensor inputs, learned patterns, and decay.</p> <p>Threshold \u2014 Adjustable number entity (1-99%) controlling when the Occupancy Status turns on. Change this to tune sensitivity without reconfiguring the integration.</p> <p>Detected Activity \u2014 An enum sensor showing what activity is happening: <code>showering</code>, <code>cooking</code>, <code>watching_tv</code>, <code>listening_to_music</code>, <code>working</code>, <code>eating</code>, <code>sleeping</code>, <code>idle</code>, or <code>unoccupied</code>. Activities are constrained by the area's purpose \u2014 for example, \"showering\" only appears in bathrooms. Note: the <code>sleeping</code> activity value here is inferred from sensor indicators and is separate from the Sleeping binary sensor (under Optional Entities), which uses the Companion App's sleep confidence. See Activity Detection for details.</p>"},{"location":"getting-started/basic-usage/#diagnostic-entities-for-tuning-and-understanding","title":"Diagnostic Entities (For Tuning and Understanding)","text":"<p>These help you understand why the system reached its conclusion. All are marked as diagnostic in Home Assistant.</p> <p>Presence Confidence \u2014 Probability from strong presence indicators only (motion, media, appliances, doors, windows, covers, power, sleep). Shows the \"hard evidence\" side of the calculation.</p> <p>Environmental Confidence \u2014 How much environmental sensors (temperature, humidity, CO2, etc.) support or oppose occupancy. 50% is neutral, above supports, below opposes.</p> <p>Prior Probability \u2014 The baseline probability before any current evidence is considered. Useful for seeing learned time-of-day patterns.</p> Attribute Description <code>global_prior</code> Baseline prior derived from historical analysis <code>time_prior</code> Time-based modifier applied to the prior <code>day_of_week</code> Day-of-week index used for time prior <code>time_slot</code> Time slot index used for time prior <p>Evidence \u2014 Lists which sensors are currently providing evidence and which are inactive.</p> Attribute Description <code>evidence</code> Comma-separated list of active entity names <code>no_evidence</code> Comma-separated list of inactive entity names <code>total</code> Total number of entities <code>details</code> Detailed information for each entity including probabilities and decay status <p>Decay Status \u2014 Shows decay progress (0-100%) when probability is decreasing after activity stops.</p> <p>Activity Confidence \u2014 Confidence (0-100%) in the currently detected activity.</p>"},{"location":"getting-started/basic-usage/#optional-entities","title":"Optional Entities","text":"<p>Sleeping \u2014 A binary sensor that turns <code>on</code> when people assigned to this area are detected as sleeping. Only created when people are configured via Manage People in the integration options. See Sleep Presence for details.</p>"},{"location":"getting-started/basic-usage/#basic-automations","title":"Basic Automations","text":""},{"location":"getting-started/basic-usage/#occupancy-based-lighting","title":"Occupancy-Based Lighting","text":"<pre><code>automation:\n  - alias: \"Turn on lights when area occupied\"\n    trigger:\n      - platform: state\n        entity_id: binary_sensor.living_room_occupancy_status\n        to: \"on\"\n    action:\n      - service: light.turn_on\n        target:\n          entity_id: light.living_room\n\n  - alias: \"Turn off lights when area unoccupied\"\n    trigger:\n      - platform: state\n        entity_id: binary_sensor.living_room_occupancy_status\n        to: \"off\"\n        for:\n          minutes: 5\n    action:\n      - service: light.turn_off\n        target:\n          entity_id: light.living_room\n</code></pre>"},{"location":"getting-started/basic-usage/#high-probability-alert","title":"High Probability Alert","text":"<pre><code>automation:\n  - alias: \"High Occupancy Probability Alert\"\n    trigger:\n      - platform: numeric_state\n        entity_id: sensor.living_room_occupancy_probability\n        above: 90\n    action:\n      - service: notify.mobile_app\n        data:\n          title: \"High Occupancy Probability\"\n          message: \"Living Room occupancy probability is {{ states('sensor.living_room_occupancy_probability') }}%\"\n</code></pre>"},{"location":"getting-started/basic-usage/#troubleshooting","title":"Troubleshooting","text":"Problem What to check Probability stuck low Verify sensors are reporting correctly in Developer Tools &gt; States. Check the Evidence sensor to see which entities are active. Sensors missing from evidence Ensure the sensor is added in the area's configuration and its state matches the expected active states (e.g., <code>on</code> for motion, <code>playing</code> for media). Activity not detected Activity detection is purpose-aware \u2014 check the area's purpose matches the expected activity (e.g., \"showering\" requires Bathroom purpose). Too many false positives Raise the Occupancy Threshold or reduce weights for unreliable sensors. Too many false negatives Lower the threshold, add more sensors, or increase weights for reliable sensors. <p>For detailed debugging, see the Debugging guide.</p>"},{"location":"getting-started/basic-usage/#tips-and-tricks","title":"Tips and Tricks","text":"<ol> <li> <p>Optimal Threshold:</p> </li> <li> <p>Start at 50%</p> </li> <li>Increase for fewer false positives</li> <li> <p>Decrease for higher sensitivity</p> </li> <li> <p>Sensor Weights:</p> </li> <li> <p>Adjust based on reliability</p> </li> <li>Higher weights = stronger influence</li> <li> <p>Balance multiple sensors</p> </li> <li> <p>Decay Settings:</p> </li> <li> <p>Match room usage patterns</p> </li> <li>Longer windows for less traffic</li> <li> <p>Shorter windows for high traffic</p> </li> <li> <p>Historical Learning:</p> </li> <li>Allow time to accumulate data</li> <li>Accuracy improves over the first few weeks</li> <li>Use the <code>area_occupancy.run_analysis</code> service to trigger a manual refresh</li> </ol>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>Area Occupancy Detection is built for simplicity: just specify the sensors available in each area and a purpose, the integration will then intelligently handle occupancy detection for you. While some customization options are available, the system\u2019s powerful history-based intelligence learns your habits over time\u2014automatically refining its accuracy without constant manual tweaking.</p>"},{"location":"getting-started/configuration/#before-you-start","title":"Before You Start","text":"<p>Almost every option in the config is optional, sensible defaults are available for everything. The minimum configuration for an area is:</p> <ul> <li>A Home Assistant Area. Must exist in Home Assistant first, see here to set up areas</li> <li>A Purpose. What the room is used for, see more about purposes here</li> <li>1 Motion sensor. A physical device in the area like PIR, mmWave</li> </ul> <p>The integration will work with just these configured. Everything else can be added as you get new devices. However the more you add in, the more accurate the predictions will be.</p>"},{"location":"getting-started/configuration/#configuration-wizard","title":"Configuration Wizard","text":"<p>Area configuration uses a multi-step wizard that walks you through setup one section at a time:</p>"},{"location":"getting-started/configuration/#step-1-area-basics","title":"Step 1: Area Basics","text":"<p>Select the Home Assistant area and its primary Purpose. The purpose sets a sensible default for the decay half-life used when probability decreases.</p> <p>The following purposes are available (in order of decay time, shortest to longest):</p> <ul> <li>Passageway</li> <li>Driveway</li> <li>Utility</li> <li>Garage</li> <li>Kitchen</li> <li>Garden</li> <li>Bathroom</li> <li>Dining Room</li> <li>Living Room</li> <li>Office</li> <li>Media Room</li> <li>Bedroom</li> </ul> <p>You can override the resulting half-life in the Detection Behavior step if needed.</p> <p>Global Sleep Schedule: For areas with the <code>Bedroom</code> purpose, the half-life dynamically adjusts based on your configured sleep schedule. You can set your household\u2019s <code>Sleep Start</code> and <code>Sleep End</code> times in the Global Settings menu (accessible via the main integration options). Outside of sleep hours, <code>Bedroom</code> areas behave like <code>Living Room</code> areas.</p>"},{"location":"getting-started/configuration/#step-2-motion-sensors","title":"Step 2: Motion Sensors","text":"<p>Configure motion and presence sensors for the area. At least one motion sensor is required. You can also adjust:</p> <ul> <li>Motion Weight: How much influence motion sensors have on the calculation</li> <li>Motion Timeout: Additional timeout applied to historical motion data (configured using a duration picker)</li> </ul>"},{"location":"getting-started/configuration/#step-3-additional-sensors","title":"Step 3: Additional Sensors","text":"<p>Configure optional sensors grouped into collapsible sections. You only need to add sensors that are relevant to the area:</p> <ul> <li>Windows, Doors &amp; Covers: Door sensors, window sensors, cover entities with active state configuration</li> <li>Media Players: Media devices with active state selection</li> <li>Appliances: Switches and appliances with active state selection</li> <li>Environmental Sensors: Illuminance, temperature, humidity, CO2, CO, sound, pressure, air quality, VOC, PM2.5, PM10</li> <li>Power Sensors: Power consumption monitoring</li> </ul> <p>More information on the Sensors page.</p>"},{"location":"getting-started/configuration/#step-4-detection-behavior","title":"Step 4: Detection Behavior","text":"<p>Configure how occupancy is detected and reported:</p> Parameter Description Default Occupancy Threshold (%) The probability percentage required for the main Occupancy Status binary sensor to turn <code>on</code> 50% Enable Time Decay Toggle whether to enable the Probability Decay feature Enabled Decay Half-Life How long it takes for probability to reduce by half after activity stops (duration picker) Based on purpose Minimum Prior Override The minimum prior probability to use, overriding learned patterns. Set to 0 to disable. 0 (disabled) Exclude from All Areas When enabled, this area won\u2019t contribute to the All Areas or floor aggregate sensors. Useful for garages, driveways, and outdoor areas. Disabled <p>This step also includes the Wasp in Box configuration section for single-entry rooms.</p>"},{"location":"getting-started/configuration/#people-management","title":"People Management","text":"<p>You can configure sleep presence detection through the Manage People option in the integration\u2019s main menu. This allows the integration to detect when people are sleeping and maintain high occupancy probability in bedrooms overnight.</p> <p>For each person, you configure:</p> <ul> <li>Person Entity: The <code>person.&lt;name&gt;</code> entity to track</li> <li>Sleep Sensors: One or more sleep detection sensors (supports both numeric sensors like Companion App sleep confidence and binary sensors like in-bed sensors or iOS Sleep Focus)</li> <li>Sleep Area: Which area this person sleeps in</li> <li>Confidence Threshold: Minimum value for numeric sleep sensors to consider the person sleeping (default: 75). Does not apply to binary sensors.</li> <li>Device Tracker (optional): A specific device tracker for home/away detection instead of the person entity</li> </ul> <p>When configured, a Sleeping binary sensor is created for each assigned area. See Sleep Presence for details.</p>"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<p>After configuration:</p> <ol> <li>Monitor the created entities to ensure they reflect actual occupancy</li> <li>Adjust the threshold if needed</li> <li>Review the Basic Usage guide</li> </ol>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#hacs","title":"HACS","text":"<ol> <li>Ensure HACS is installed: If you don't have the Home Assistant Community Store (HACS) installed, follow their instructions to set it up first.</li> <li>Navigate to HACS: Open your Home Assistant frontend and go to HACS in the sidebar.</li> <li>Search for Area Occupancy Detection: Search for \"Area Occupancy Detection\" and select then Download.</li> <li>Restart Home Assistant: After the download is complete, restart your Home Assistant instance</li> </ol>"},{"location":"getting-started/installation/#initial-setup","title":"Initial Setup","text":"<ol> <li>Go to Settings &gt; Devices &amp; Services &gt; Integrations &gt; + Add Integration.</li> <li>Search for Area Occupancy Detection and select it.</li> <li>Configure Area Name:</li> <li>Select a Home Assistant area for this occupancy detection. The area name will be automatically used for the device and entities.</li> <li>You may need to create the area in Home Assistant first if it doesn't exist.</li> <li>Configure Area Purpose:</li> <li>Choose the purpose of the area. This sets a sensible default for the decay half-life used when probability decreases. The purpose selection affects how quickly the system \"forgets\" about occupancy after activity stops.</li> <li>Configure Sensors:</li> <li>Select the sensors that will be used to detect occupancy.</li> <li>You will need to select at least one motion/presence sensor for the integration to work.</li> <li>You can then add sensors of many different types to the area to improve the accuracy of the occupancy detection.</li> </ol>"},{"location":"getting-started/installation/#configuration","title":"Configuration","text":"<p>When you first create the integration you will be taken straight to configuring the first area.</p> <p>When adding new areas you will need to navigate to Integrations -&gt; Area Occupancy Detection -&gt; Configure (\u2699\ufe0f Cog icon). This will bring up the configuration menu.</p> <p>There is detailed documentation on the configuration options here: Configuration.</p>"},{"location":"getting-started/installation/#before-you-start","title":"Before You Start","text":"<p>For an ideal setup you will need to perform these steps in Home Assistant before setting up the integration:</p> <ul> <li>Set up Home Assistant Areas, see here to set up areas</li> <li>Set up Home Assistant Floors, see here to set up floors</li> <li>Set up Home Assistant People, see here to set up people</li> </ul> <p>Almost every option in the config is optional, sensible defaults are available for eveything. The minimum configuration for an area is:</p> <ul> <li>A Home Assistant Area. Must exist in Home Assistant first, see here to set up areas</li> <li>A Purpose. What the room is used for, see more about purposes here</li> <li>1 Motion sensor. A physical device in the area like PIR, mmWave</li> </ul> <p>The integration will work with just these configured. Everything else can be added as you get new devices. However the more you add in, the more accurate the predictions will be.</p>"},{"location":"getting-started/installation/#main-menu","title":"Main Menu","text":"<p>The main menu allows you to modify global settings, add a new area, manage existing areas, or manage people for sleep presence detection.</p> <p></p>"},{"location":"getting-started/installation/#global-settings","title":"Global Settings","text":"<p>The global settings menu allows you to modify the global settings for the integration, these are limited for now and will be expanded in the future.</p> <p></p>"},{"location":"getting-started/installation/#add-new-area","title":"Add New Area","text":"<p>The add new area menu allows you to add a new area to the integration.</p> <p></p> <p>The next steps asks you for the motion sensors you have in that area. just add any sensors you have, leave the rest as default for initial config.</p> <p></p> <p>You can then choose any other sensors you have in the area to contribute, again on first config, just add any sensors you have, leave the weights and states as default. Everything here is optional.</p> <p></p>"},{"location":"getting-started/installation/#manage-areas","title":"Manage Areas","text":"<p>The manage areas menu allows you to manage existing areas, you can see a summary of each area and the sensors associated with it. You can then select one of the areas to edit or remove.</p> <p></p> <p></p>"},{"location":"getting-started/installation/#manage-people","title":"Manage People","text":"<p>The manage people menu allows you to add and configure people associated with your home, they must be set up as people in Home Assistant first so they can be selected in the people picker. Choosing entities for sleep confidence and device tracking (from HA Companion app for example) allows AOD to track sleep for a given area. Choosing an area for a person essentially defines their bedroom.</p> <p></p> <p></p>"},{"location":"getting-started/installation/#getting-help","title":"Getting Help","text":"<p>If you encounter issues:</p> <ol> <li>Search GitHub Issues</li> <li>Join the Discussion</li> </ol>"},{"location":"getting-started/why/","title":"Why Area Occupancy Detection?","text":"<p>Have you ever had your lights turn off while you're still in the room? Or watched your smart home mark you as \"away\" while you're sitting perfectly still, watching TV? These frustrating experiences happen because most occupancy detection relies on simple motion sensors that can't understand context.</p> <p>Area Occupancy Detection solves these real-world problems by thinking more intelligently about what \"occupied\" really means. Instead of just checking if motion was detected, it combines multiple clues, learns from your patterns, and calculates the probability that someone is actually there.</p> <p>Area Occupancy Detection doesn't automate anything for you\u2014it provides the intelligent occupancy information you need to create reliable automations. AOD creates sensors that your automations can use to control lights, heating, and other devices. Think of AOD as the \"smart sensor\" that gives your automations better data to work with.</p>"},{"location":"getting-started/why/#the-quick-answer","title":"The Quick Answer","text":"<p>Here's why AOD is different:</p> <p>HA: \"Motion detected? Occupied. Motion stopped? Not occupied.\"</p> <p>\ud83c\udfaf AOD: \"Let me check motion, TV, doors, appliances, learned patterns, and time of day... 75% confident someone is there.\"</p> <p>HA: You configure everything manually. It never learns.</p> <p>\ud83e\udde0 AOD: Learns from your history automatically. Gets smarter over time. Knows you're usually in the kitchen Sunday mornings.</p> <p>Core HA: One sensor fails \u2192 wrong answer.</p> <p>\ud83d\udd00 AOD: Combines multiple sensors intelligently. If motion misses you, TV being on maintains occupancy probability \u2192 your automations keep lights on.</p> <p>Core HA: Motion stops \u2192 occupancy sensor turns off \u2192 automations turn lights off immediately.</p> <p>\u23f1\ufe0f AOD: Motion stops \u2192 probability gradually decreases \u2192 occupancy sensor stays on longer \u2192 your automations keep lights on while you sit still.</p> <p>Core HA: Basic features only.</p> <p>\u2728 AOD: Activity detection (what's happening, not just who's there), sleep presence tracking, \"Wasp in Box\" for bathrooms, whole-home aggregation, purpose-based defaults.</p> <p>The bottom line: AOD provides intelligent occupancy sensors that your automations can use. It learns, adapts, and understands context\u2014so when you build automations that respond to occupancy, they work reliably instead of turning lights off while you're still in the room.</p>"},{"location":"getting-started/why/#creating-automations-with-aod","title":"Creating Automations with AOD","text":"<p>Here's how AOD fits into your automation workflow:</p>"},{"location":"getting-started/why/#the-workflow","title":"The Workflow","text":"<ol> <li>AOD analyzes your sensors \u2192 Motion, TV, doors, appliances, learned patterns</li> <li>AOD calculates probability \u2192 Combines all inputs using Bayesian inference</li> <li>AOD creates occupancy sensors \u2192 Binary occupancy status and probability sensors</li> <li>Your automations use these sensors \u2192 Trigger actions based on occupancy state or probability</li> <li>AOD learns and adapts \u2192 Gets smarter over time, improving your automations automatically</li> </ol>"},{"location":"getting-started/why/#what-aod-provides","title":"What AOD Provides","text":"<p>AOD creates sensors that your automations can use:</p> <ul> <li>Occupancy Status: Binary sensor (<code>on</code> = occupied, <code>off</code> = clear) - use this in most automations</li> <li>Occupancy Probability: Percentage (0-100%) - use this for conditional or gradual actions</li> <li>Detected Activity: What's happening in the room (showering, cooking, watching TV, sleeping, etc.) - use this for context-aware automations</li> <li>Sleeping: Whether people are sleeping in the area - use for overnight occupancy (all data processed locally, no cloud services)</li> <li>Presence Confidence / Environmental Confidence: Split view of what's driving the probability</li> <li>Prior Probability: Baseline from learned patterns - useful for monitoring and debugging</li> <li>Threshold: Adjustable setting - fine-tune without reconfiguration</li> </ul>"},{"location":"getting-started/why/#how-you-use-it","title":"How You Use It","text":"<p>You create automations that respond to AOD's sensors. For example:</p> <ul> <li>Turn lights on when occupancy status turns <code>on</code></li> <li>Turn lights off when occupancy status turns <code>off</code> (with a delay to prevent flickering)</li> <li>Adjust heating based on occupancy probability</li> <li>Dim lights gradually as probability decreases</li> </ul> <p>The key difference: AOD provides intelligent occupancy data. You decide what actions to take based on that data.</p> <p>For automation examples, see the Basic Usage Guide.</p>"},{"location":"getting-started/why/#what-core-home-assistant-can-do","title":"What Core Home Assistant Can Do","text":"<p>Home Assistant provides several built-in ways to detect occupancy, each with its own strengths and limitations:</p>"},{"location":"getting-started/why/#binary-motion-sensors","title":"Binary Motion Sensors","text":"<p>The simplest approach: a motion sensor reports <code>on</code> when motion is detected, <code>off</code> when it's not. This is straightforward, but has significant limitations:</p> <ul> <li>No context: Can't tell the difference between someone sitting still and an empty room</li> <li>Instant state changes: Motion stops \u2192 immediately marked as unoccupied</li> <li>Single point of failure: One sensor determines everything</li> <li>No learning: Doesn't adapt to your patterns</li> </ul>"},{"location":"getting-started/why/#template-sensors","title":"Template Sensors","text":"<p>You can manually combine multiple sensors using YAML templates, but this requires YAML knowledge and manual configuration for every combination. No learning, no probability\u2014just binary results.</p>"},{"location":"getting-started/why/#automation-conditions","title":"Automation Conditions","text":"<p>You can use AND/OR logic in automations to combine sensors, but each automation requires manual configuration. No learning, no probability, and you must update everything when you add sensors.</p>"},{"location":"getting-started/why/#history-and-statistics","title":"History and Statistics","text":"<p>Home Assistant can analyze historical data, but you must manually query APIs, write scripts, and configure everything yourself. No automatic learning.</p>"},{"location":"getting-started/why/#summary-of-core-ha-limitations","title":"Summary of Core HA Limitations","text":"Feature Core HA AOD Learning Manual configuration only Automatic learning from history Probability Binary on/off only Probability percentage (0-100%) Adaptation Static configuration Adapts to your patterns Sensor Reliability You must configure manually Learns automatically Multi-Sensor Fusion Manual templates/automations Automatic with learned weights Time-Based Patterns Manual configuration Learns day/time patterns automatically Activity Detection None Detects what's happening (cooking, showering, etc.) Sleep Tracking None Detects sleep via phone companion app Specialized Features None Wasp in Box, whole-home aggregation, purpose-based config"},{"location":"getting-started/why/#what-makes-aod-different","title":"What Makes AOD Different","text":""},{"location":"getting-started/why/#1-intelligent-probability-vs-binary-logic","title":"1. Intelligent Probability vs. Binary Logic","text":"<p>Core HA Approach:</p> <ul> <li>Binary state: <code>occupied</code> or <code>not occupied</code></li> <li>Instant decisions based on current sensor states</li> <li>No nuance or confidence level</li> </ul> <p>AOD Approach:</p> <ul> <li>Probability percentage: 0% to 100% confidence</li> <li>Configurable threshold (e.g., 75% = occupied)</li> <li>More nuanced understanding of occupancy</li> </ul> <p>Example:</p> <ul> <li>Core HA: Motion detected \u2192 <code>occupied = true</code> (even if it's just a pet)</li> <li>AOD: Motion detected + TV off + door closed + learned patterns \u2192 <code>probability = 45%</code> \u2192 below threshold \u2192 <code>occupied = false</code></li> </ul> <p>Benefit: Fewer false positives and false negatives. The system understands that not all motion means occupancy.</p>"},{"location":"getting-started/why/#2-automatic-learning-vs-manual-configuration","title":"2. Automatic Learning vs. Manual Configuration","text":"<p>Core HA Approach:</p> <ul> <li>You configure everything manually</li> <li>You decide which sensors to trust</li> <li>You set up time-based patterns yourself</li> <li>Static configuration that doesn't improve</li> </ul> <p>AOD Approach:</p> <ul> <li>Prior Learning: Automatically learns baseline occupancy patterns (global and time-based). See Prior Learning for details</li> <li>Likelihood Learning: Learns how reliable each sensor is. See Sensor Likelihoods for details</li> <li>Time-based Patterns: Learns day-of-week and time-of-day patterns automatically</li> </ul> <p>Benefit: Gets smarter over time. The longer it runs, the more accurate it becomes. No manual tuning required.</p>"},{"location":"getting-started/why/#3-multi-sensor-fusion-vs-manual-combination","title":"3. Multi-Sensor Fusion vs. Manual Combination","text":"<p>Core HA Approach:</p> <ul> <li>You manually combine sensors with templates or automation conditions</li> <li>You decide how to weight each sensor</li> <li>Requires YAML knowledge or complex automations</li> <li>Must update configuration when you add sensors</li> </ul> <p>AOD Approach:</p> <ul> <li>Automatically combines motion, media, appliances, doors, windows, covers, power sensors, sleep presence, and environmental sensors</li> <li>Separates presence indicators (80% weight) from environmental support (20% weight) for more accurate results</li> <li>Each sensor type has learned reliability with weighted contributions</li> <li>See Bayesian Calculation for details</li> </ul> <p>Example:</p> <ul> <li>Core HA: You write a template: <code>motion OR tv_playing OR computer_on</code></li> <li>AOD: Automatically considers all sensors, weighs them by learned reliability, and calculates probability</li> </ul> <p>Benefit: Richer context and more accurate detection. The system understands that multiple weak signals can be as strong as one strong signal.</p>"},{"location":"getting-started/why/#4-probability-decay-vs-instant-onoff","title":"4. Probability Decay vs. Instant On/Off","text":"<p>Core HA Approach:</p> <ul> <li>Motion stops \u2192 occupancy sensor immediately turns off</li> <li>No grace period for sitting still</li> <li>Your automations turn lights off even if you're still in the room</li> </ul> <p>AOD Approach:</p> <ul> <li>Gradual probability decay when activity stops</li> <li>Occupancy sensor stays on longer, giving your automations better data</li> <li>See Probability Decay for details</li> </ul> <p>Example:</p> <ul> <li>Core HA: You sit still for 1 minute \u2192 motion stops \u2192 occupancy sensor turns off \u2192 your automation turns lights off</li> <li>AOD: You sit still \u2192 motion stops \u2192 probability gradually decreases over 5-10 minutes \u2192 occupancy sensor stays on \u2192 your automation keeps lights on until probability drops below threshold</li> </ul> <p>Benefit: Prevents lights from turning off when you're still in the room. More natural, less frustrating behavior.</p>"},{"location":"getting-started/why/#5-specialized-features","title":"5. Specialized Features","text":"<p>AOD includes features not available in core Home Assistant:</p>"},{"location":"getting-started/why/#activity-detection","title":"Activity Detection","text":"<p>Identifies what is happening in a room \u2014 not just that someone is there. The system can detect activities like showering, cooking, watching TV, working, sleeping, and more. Activities are tied to room purpose, so \"showering\" only appears in bathrooms and \"cooking\" only in kitchens. See Activity Detection for details.</p> <p>Example:</p> <ul> <li>Core HA: Motion detected in kitchen \u2192 you know someone is there, but not what they're doing</li> <li>AOD: Appliance on + humidity elevated + temperature elevated = <code>cooking</code> with 85% confidence \u2192 your automation can turn on the extractor fan</li> </ul>"},{"location":"getting-started/why/#sleep-presence-detection","title":"Sleep Presence Detection","text":"<p>Detects when people are sleeping by combining Home Assistant Person entities with phone-reported sleep confidence from the Companion App. When sleep is detected, the area maintains high occupancy probability overnight. See Sleep Presence for details.</p> <p>Example:</p> <ul> <li>Core HA: No motion in bedroom overnight \u2192 occupancy turns off \u2192 heating turns off while you sleep</li> <li>AOD: Person home + phone reports sleeping \u2192 Sleeping sensor on \u2192 occupancy probability stays high \u2192 your automation keeps heating on</li> </ul>"},{"location":"getting-started/why/#wasp-in-box","title":"Wasp in Box","text":"<p>Special logic for rooms with a single entry/exit point (bathrooms, closets, small offices). If someone enters and the door closes, they remain until the door opens again. See Wasp in Box for details.</p> <p>Example:</p> <ul> <li>Core HA: Motion stops in bathroom \u2192 occupancy sensor turns off \u2192 your automation turns lights off (even if door is closed)</li> <li>AOD: Door closed + recent motion \u2192 maintains occupancy probability \u2192 occupancy sensor stays on \u2192 your automation keeps lights on</li> </ul>"},{"location":"getting-started/why/#all-areas-aggregation","title":"All Areas Aggregation","text":"<p>Automatically creates aggregated entities across all configured areas for whole-home occupancy detection. No manual configuration required.</p>"},{"location":"getting-started/why/#purpose-based-configuration","title":"Purpose-Based Configuration","text":"<p>Selecting a room purpose (Living Room, Bedroom, Kitchen, etc.) automatically sets sensible defaults for decay half-life and other parameters. See Purpose-Based Configuration for details.</p>"},{"location":"getting-started/why/#real-world-scenarios","title":"Real-World Scenarios","text":""},{"location":"getting-started/why/#scenario-1-watching-tv","title":"Scenario 1: Watching TV","text":"<p>The Problem: You're watching TV in the living room. You sit still for 10 minutes. The motion sensor stops detecting movement.</p> <p>Core HA Solution:</p> <ul> <li>Motion sensor \u2192 <code>off</code></li> <li>Occupancy sensor \u2192 <code>off</code></li> <li>Your automation turns lights off</li> <li>You're sitting in the dark, frustrated</li> </ul> <p>AOD Solution:</p> <ul> <li>Motion sensor \u2192 inactive</li> <li>TV \u2192 <code>playing</code></li> <li>Learned pattern: \"Evening + TV playing = likely occupied\"</li> <li>Probability: 85% (above threshold)</li> <li>Occupancy sensor \u2192 <code>on</code></li> <li>Your automation keeps lights on</li> <li>You continue watching comfortably</li> </ul>"},{"location":"getting-started/why/#scenario-2-working-at-desk","title":"Scenario 2: Working at Desk","text":"<p>The Problem: You're working at your desk. No motion for 15 minutes while you read or type.</p> <p>Core HA Solution:</p> <ul> <li>Motion sensor \u2192 <code>off</code> after timeout</li> <li>Occupancy sensor \u2192 <code>off</code></li> <li>Your automations turn lights/heating off</li> </ul> <p>AOD Solution:</p> <ul> <li>Motion sensor \u2192 inactive</li> <li>Computer/appliance \u2192 <code>on</code></li> <li>Learned pattern: \"Work hours + computer on = likely occupied\"</li> <li>Probability: 70% (above threshold)</li> <li>Occupancy sensor \u2192 <code>on</code></li> <li>Your automations keep lights/heating on</li> <li>You work comfortably</li> </ul>"},{"location":"getting-started/why/#scenario-3-pet-walking-through","title":"Scenario 3: Pet Walking Through","text":"<p>The Problem: Your pet walks through the room, triggering the motion sensor.</p> <p>Core HA Solution:</p> <ul> <li>Motion detected \u2192 occupancy sensor \u2192 <code>on</code></li> <li>Your automation turns lights on</li> <li>False positive</li> </ul> <p>AOD Solution:</p> <ul> <li>Motion detected \u2192 weak signal</li> <li>No other sensors active</li> <li>Learned pattern: \"Single brief motion = likely not occupied\"</li> <li>Probability: 25% (below threshold)</li> <li>Occupancy sensor \u2192 <code>off</code></li> <li>Your automation doesn't turn lights on</li> <li>False positive avoided</li> </ul>"},{"location":"getting-started/why/#scenario-4-bathroom-wasp-in-box","title":"Scenario 4: Bathroom (Wasp in Box)","text":"<p>The Problem: You're in the bathroom. Motion stops, but the door is closed.</p> <p>Core HA Solution:</p> <ul> <li>Motion stops \u2192 occupancy sensor \u2192 <code>off</code></li> <li>Your automation turns lights off</li> <li>You're in the dark</li> </ul> <p>AOD Solution (with Wasp in Box enabled):</p> <ul> <li>Motion stops \u2192 but door is closed</li> <li>Wasp in Box logic: \"Door closed + recent motion = occupied\"</li> <li>Probability: 80% (above threshold)</li> <li>Occupancy sensor \u2192 <code>on</code></li> <li>Your automation keeps lights on</li> <li>You're comfortable</li> </ul>"},{"location":"getting-started/why/#when-to-use-aod-vs-core-ha","title":"When to Use AOD vs. Core HA","text":""},{"location":"getting-started/why/#use-aod-when","title":"Use AOD When:","text":"<ul> <li>\u2705 You want intelligent, adaptive occupancy detection</li> <li>\u2705 You have multiple sensors per area (motion, media, doors, etc.)</li> <li>\u2705 You want automatic learning from your patterns</li> <li>\u2705 You need probability-based detection (not just binary)</li> <li>\u2705 You want to know what is happening in a room (activity detection)</li> <li>\u2705 You need reliable overnight bedroom occupancy (sleep presence)</li> <li>\u2705 You want specialized features (Wasp in Box, whole-home aggregation)</li> <li>\u2705 You want less maintenance (system learns and adapts)</li> <li>\u2705 You're frustrated with automations turning lights off while you're still in the room</li> <li>\u2705 You want your smart home to feel truly smart</li> </ul>"},{"location":"getting-started/why/#use-core-ha-when","title":"Use Core HA When:","text":"<ul> <li>\u2705 Simple binary motion detection is sufficient for your needs</li> <li>\u2705 You prefer manual control over automatic learning</li> <li>\u2705 You only have a single motion sensor per area</li> <li>\u2705 You want to learn YAML/automation configuration</li> <li>\u2705 You need very simple, predictable behavior</li> <li>\u2705 You enjoy manually configuring and maintaining templates</li> </ul>"},{"location":"getting-started/why/#key-benefits-summary","title":"Key Benefits Summary","text":"<ol> <li>Accuracy: Multi-sensor fusion + learning = fewer false positives/negatives</li> <li>Adaptability: Learns your patterns automatically, gets smarter over time</li> <li>Intelligence: Bayesian probability vs. simple binary logic</li> <li>Context: Activity detection tells you what is happening, not just if someone is there</li> <li>Overnight: Sleep presence keeps bedrooms occupied while you sleep</li> <li>Convenience: UI-based configuration, automatic learning, purpose-based defaults</li> <li>Specialized Features: Wasp in Box, whole-home aggregation, dual presence/environmental model</li> <li>Privacy: Runs locally, no cloud services, full control</li> </ol>"},{"location":"getting-started/why/#getting-started","title":"Getting Started","text":"<p>Ready to try Area Occupancy Detection? See the Installation Guide and Configuration Guide to get started. The integration creates occupancy sensors that you can use in your automations. It starts learning from your sensor history immediately and gets smarter over time.</p>"},{"location":"getting-started/why/#learn-more","title":"Learn More","text":"<ul> <li>Bayesian Calculation: How probability is calculated</li> <li>Prior Learning: How the system learns from history</li> <li>Activity Detection: How activity detection works</li> <li>Sleep Presence: How sleep detection works</li> <li>Probability Decay: How decay prevents false negatives</li> <li>Wasp in Box: Special logic for single-entry rooms</li> <li>Sensor Likelihoods: How sensor reliability is learned</li> </ul>"},{"location":"simulator/","title":"Simulator","text":"0.00% No areas loaded                Help              Area Occupancy Detection Simulator <p>                 This simulator lets you interactively explore how sensor states,                 weights, and prior probabilities affect occupancy calculations.                 It uses the exact same Python code that runs in                 your Home Assistant integration, ensuring calculations match                 exactly what happens in your actual setup.               </p> Getting Started <p> Step 1: In Home Assistant, run the                 \"Run Analysis\" service                 for your area(s). This generates YAML output with all your                 sensors, their states, likelihoods, and current probability                 calculations.               </p> <p> Step 2: Copy the entire YAML output from the                 service call and paste it into the                 \"Service YAML Input\"                 text area below.               </p> <p> Step 3: Click                 \"Load Simulation\" to send the data to the                 simulator server. The simulator will populate with your sensors,                 current states, and all configuration values.               </p> <p> Step 4: If your analysis output contains                 multiple areas, use the Area dropdown to switch                 between them.               </p> Understanding the Interface Header Section <ul> <li> Area Name: The name of the currently selected                   area                 </li> <li> Probability Value: The calculated occupancy                   probability (0-100%)                 </li> <li> Probability Bar: Visual representation of the                   current probability                 </li> <li> Probability Chart: Time-series graph showing                   how probability changes over time as you interact with sensors                 </li> </ul> Sensors Section <p>Each sensor card displays:</p> <ul> <li> Sensor Name: Friendly name or entity ID                 </li> <li> Current State: The sensor's current value or                   state                 </li> <li> Type &amp; Weight: Sensor type (motion, media,                   door, etc.) and its weight in calculations                 </li> <li> Likelihood Values: P(active|occupied) and                   P(active|vacant) probabilities                 </li> <li> Controls: <ul> <li> Binary Sensors: Toggle switch or buttons                       to set active/inactive states                     </li> <li> Numeric Sensors: Input field to enter                       temperature, humidity, illuminance, or other numeric                       values                     </li> </ul> </li> <li> Metrics: Contribution (how much this sensor                   affects probability), Likelihood, and Decay Factor (if sensor                   is decaying)                 </li> </ul> Prior Probabilities Section <ul> <li> Global Prior: Base probability that the area                   is occupied, independent of time or sensor evidence                 </li> <li> Time Prior: Learned probability based on                   schedules or historical activity patterns                 </li> <li> Combined Prior: Weighted combination of                   global and time priors                 </li> <li> Final Prior: Effective prior after Bayesian                   factor and clamping are applied                 </li> <li> Area Purpose: Select a purpose (Social, Work,                   Rest, etc.) to auto-populate decay settings                 </li> <li> Half-life: Time in seconds for sensor                   evidence to decay by 50% when inactive                 </li> </ul> Entity Type Weights Section <p>                 Adjust the weight (influence) of each sensor type on the overall                 probability calculation:               </p> <ul> <li>Motion: Motion sensors (default: 1.0)</li> <li>Media: Media players (default: 0.85)</li> <li>Appliance: Appliances (default: 0.4)</li> <li>Door: Door sensors (default: 0.3)</li> <li>Window: Window sensors (default: 0.2)</li> <li> Illuminance: Light level sensors (default:                   0.1)                 </li> <li> Humidity: Humidity sensors (default: 0.1)                 </li> <li> Temperature: Temperature sensors (default:                   0.1)                 </li> </ul> <p>                 Higher weights mean that sensor type has more influence on the                 final probability. Weights apply to all sensors of that type.               </p> What You Can Do <ul> <li> Toggle Binary Sensors: Use switches or                   buttons to change motion, door, window, and appliance states.                   See immediate probability updates.                 </li> <li> Adjust Numeric Sensors: Enter new values for                   temperature, humidity, or illuminance sensors to see how they                   affect probability.                 </li> <li> Modify Entity Type Weights: Use sliders to                   change how much each sensor type contributes. Changes apply to                   all sensors of that type.                 </li> <li> Experiment with Priors: Adjust global and                   time priors to see how base probabilities affect calculations.                 </li> <li> Change Area Purpose: Select different                   purposes to see how decay settings change based on area type.                 </li> <li> Observe Decay: When sensors become inactive,                   watch how their evidence decays over time based on the                   half-life setting.                 </li> <li> View Detailed Metrics: See likelihood,                   contribution, and decay factors for each sensor to understand                   its impact.                 </li> <li> Track Changes: The probability chart shows                   the last 30 updates, helping you visualize how probability                   evolves.                 </li> <li> Switch Between Areas: If your analysis                   contains multiple areas, use the Area dropdown to simulate                   different areas.                 </li> </ul> How It Works <p>                 The simulator uses a stateless architecture where each                 interaction sends the current configuration to a server running                 the                 actual Python code from the Area Occupancy                 Detection integration. This ensures:               </p> <ul> <li>                   Calculations match exactly what happens in Home Assistant                 </li> <li>                   You can test different scenarios and configurations before                   implementing them                 </li> <li>                   You can understand how each sensor, weight, and prior affects                   the final probability                 </li> <li>                   The probability chart provides a visual history of changes                 </li> <li>                   Real-time updates occur automatically every second, or                   immediately when you change a control                 </li> </ul> Tips <ul> <li>                   The API Status badge shows whether the                   simulator server is online and responding.                 </li> <li>                   Sensor contributions show positive values when the sensor                   increases probability and negative values when it decreases                   probability.                 </li> <li>                   Decay factors apply when sensors transition from active to                   inactive, gradually reducing their influence over time.                 </li> <li>                   All changes are calculated in real-time, so you get immediate                   feedback on how your configuration behaves.                 </li> <li>                   The simulator preserves your YAML data when switching between                   areas, so you can easily compare different areas from the same                   analysis.                 </li> </ul>                  Close                Load Simulation Loading... Checking Something went wrong                  Retry"},{"location":"technical/analysis-chain/","title":"Sensor Correlation Analysis Chain","text":"<p>This document provides a comprehensive breakdown of the sensor analysis chain, from data collection through likelihood calculation. It details how numeric sensors use correlation analysis with Gaussian PDFs, while binary sensors use duration-based static probability calculation.</p>"},{"location":"technical/analysis-chain/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Complete Flow Overview</li> <li>Phase-by-Phase Breakdown</li> <li>Key Operations Reference</li> <li>Unified Architecture</li> </ol>"},{"location":"technical/analysis-chain/#complete-flow-overview","title":"Complete Flow Overview","text":"<p>The analysis chain consists of four main phases:</p> <ol> <li>Data Collection (Continuous) - Raw sensor data is continuously synced from Home Assistant</li> <li>Hourly Analysis Cycle (Scheduled) - Periodic analysis runs every hour</li> <li>Sensor Analysis (Within Analysis Cycle) - Analyses sensors using appropriate method:</li> <li>Numeric Sensors: Correlation analysis with Gaussian PDFs</li> <li>Binary Sensors: Duration-based static probability calculation</li> <li>Likelihood Calculation (Runtime) - Retrieves likelihoods using appropriate method based on sensor type</li> </ol> <pre><code>flowchart TD\n    Start([Hourly Timer Fires]) --&gt; Sync[Sync States from Recorder]\n    Sync --&gt; HealthCheck[Database Health Check]\n    HealthCheck --&gt; Prune[Prune Old Intervals]\n    Prune --&gt; Cache[Populate OccupiedIntervalsCache]\n    Cache --&gt; Aggregate[Interval Aggregation]\n    Aggregate --&gt; Prior[Prior Analysis]\n    Prior --&gt; CorrAnalysis[Correlation Analysis]\n    CorrAnalysis --&gt; Refresh[Refresh Coordinator]\n    Refresh --&gt; Save[Save to Database]\n    Save --&gt; End([Complete])\n\n    CorrAnalysis --&gt; SensorDetail[For Each Entity]\n    SensorDetail --&gt; CheckType{Is Binary?}\n\n    CheckType -- Yes --&gt; BinaryAnalysis[Binary Likelihood Analysis]\n    CheckType -- No --&gt; NumericAnalysis[Numeric Correlation Analysis]\n\n    BinaryAnalysis --&gt; GetBinaryIntervals[Get Binary Intervals]\n    GetBinaryIntervals --&gt; GetOccIntervals[Get OccupiedIntervalsCache]\n    GetOccIntervals --&gt; CalcOverlap[Calculate Interval Overlaps]\n    CalcOverlap --&gt; CalcProbs[Calculate Static Probabilities]\n    CalcProbs --&gt; UpdateBinary[Update Entity with Static Probs]\n\n    NumericAnalysis --&gt; GetSamples[Get NumericSamples]\n    GetSamples --&gt; GetOccIntervals2[Get OccupiedIntervalsCache]\n    GetOccIntervals2 --&gt; MapOccupancy[Map Samples to Occupancy]\n    MapOccupancy --&gt; CalcCorr[Calculate Pearson Correlation]\n    CalcCorr --&gt; CalcStats[Calculate Mean/Std]\n    CalcStats --&gt; SaveCorr[Save to Correlations]\n    SaveCorr --&gt; UpdateNumeric[Update Entity with Gaussian Params]\n\n    UpdateBinary --&gt; Runtime[Runtime Likelihood Calculation]\n    UpdateNumeric --&gt; Runtime\n    Runtime --&gt; GetState[Get Current Sensor State]\n    GetState --&gt; CheckType2{Is Binary?}\n    CheckType2 -- Yes --&gt; UseStatic[Use Static Probabilities]\n    CheckType2 -- No --&gt; CalcGaussian[Calculate Gaussian Densities]\n    UseStatic --&gt; Bayesian[Use in Bayesian Update]\n    CalcGaussian --&gt; Bayesian</code></pre>"},{"location":"technical/analysis-chain/#phase-by-phase-breakdown","title":"Phase-by-Phase Breakdown","text":""},{"location":"technical/analysis-chain/#phase-1-data-collection-continuous","title":"Phase 1: Data Collection (Continuous)","text":""},{"location":"technical/analysis-chain/#step-11-sync-states-from-recorder","title":"Step 1.1: Sync States from Recorder","text":"<p>What Happens:</p> <ul> <li>Fetches recent state changes from Home Assistant recorder</li> <li>Converts numeric sensor states to <code>NumericSamples</code> records</li> <li>Converts binary sensor states to <code>Intervals</code> records</li> <li>Stores in database tables</li> </ul> <p>Data Stored:</p> <ul> <li><code>NumericSamples</code> table: Raw numeric sensor values with timestamps</li> <li><code>Intervals</code> table: Binary sensor state intervals (on/off periods)</li> </ul>"},{"location":"technical/analysis-chain/#phase-2-hourly-analysis-cycle-scheduled","title":"Phase 2: Hourly Analysis Cycle (Scheduled)","text":"<p>Trigger: Scheduled timer fires every hour</p> <p>Note: The analysis cycle orchestrates the complete analysis chain for all configured areas.</p>"},{"location":"technical/analysis-chain/#step-21-sync-states","title":"Step 2.1: Sync States","text":"<p>Imports latest data from Home Assistant recorder into local database.</p>"},{"location":"technical/analysis-chain/#step-22-database-health-check-pruning","title":"Step 2.2: Database Health Check &amp; Pruning","text":"<p>Ensures database integrity and removes old data beyond retention period.</p>"},{"location":"technical/analysis-chain/#step-23-populate-occupiedintervalscache","title":"Step 2.3: Populate OccupiedIntervalsCache","text":"<p>Calculates occupied intervals from motion sensors (ground truth) and caches them for efficient access during analysis.</p>"},{"location":"technical/analysis-chain/#step-24-interval-aggregation","title":"Step 2.4: Interval Aggregation","text":"<p>Aggregates raw intervals into daily/weekly/monthly aggregates for trend analysis and long-term storage.</p>"},{"location":"technical/analysis-chain/#step-25-prior-analysis","title":"Step 2.5: Prior Analysis","text":"<p>Calculates global prior probability and time-based priors for each area from historical occupancy data.</p>"},{"location":"technical/analysis-chain/#step-26-correlation-analysis","title":"Step 2.6: Correlation Analysis","text":"<p>Runs correlation analysis for all configured sensors (excluding motion sensors) to learn how each sensor correlates with occupancy.</p>"},{"location":"technical/analysis-chain/#step-27-refresh-save","title":"Step 2.7: Refresh &amp; Save","text":"<p>Updates coordinator state and persists all changes to database.</p>"},{"location":"technical/analysis-chain/#phase-3-correlation-analysis-step-6-detail","title":"Phase 3: Correlation Analysis (Step 6 Detail)","text":""},{"location":"technical/analysis-chain/#step-31-get-correlatable-entities","title":"Step 3.1: Get Correlatable Entities","text":"<p>What Happens:</p> <ul> <li>Returns all configured sensors for the area (excluding motion sensors).</li> <li>Identifies if each entity is binary or numeric.</li> </ul>"},{"location":"technical/analysis-chain/#step-32-analyze-each-entity","title":"Step 3.2: Analyze Each Entity","text":"<p>For each entity:</p> <ol> <li> <p>Route by Type:</p> </li> <li> <p>Binary Sensors: Performs duration-based analysis to calculate static probabilities.</p> </li> <li> <p>Numeric Sensors: Performs correlation analysis to learn Gaussian parameters.</p> </li> <li> <p>Update Live Entity:</p> </li> <li> <p>Binary Sensors: Updates entity with learned <code>prob_given_true</code> and <code>prob_given_false</code> values.</p> </li> <li> <p>Numeric Sensors: Updates entity with learned Gaussian parameters (mean, standard deviation) for occupied and unoccupied states.</p> </li> <li> <p>Persist Results:</p> </li> <li>Binary Sensors: Saves binary likelihood results (including <code>analysis_error</code> if present) to the database.</li> <li>Numeric Sensors: Saves correlation results (including <code>analysis_error</code> if present) to the database.</li> </ol>"},{"location":"technical/analysis-chain/#step-33a-binary-sensor-analysis","title":"Step 3.3a: Binary Sensor Analysis","text":"<p>Process:</p> <ol> <li> <p>Get Occupied Intervals:</p> </li> <li> <p>Retrieves occupied intervals from <code>OccupiedIntervalsCache</code> for the analysis period.</p> </li> <li> <p>Get Binary Sensor Intervals:</p> </li> <li> <p>Queries <code>Intervals</code> table for the binary sensor's state changes.</p> </li> <li> <p>Calculate Overlaps:</p> </li> <li> <p>For each binary sensor interval, calculates overlap duration with occupied periods.</p> </li> <li> <p>Calculates overlap duration with unoccupied periods.</p> </li> <li> <p>Calculate Probabilities:</p> </li> <li> <p><code>prob_given_true = active_duration_occupied / total_occupied_duration</code></p> </li> <li> <p><code>prob_given_false = active_duration_unoccupied / total_unoccupied_duration</code></p> </li> <li> <p>Clamp and Return:</p> </li> <li> <p>Clamps probabilities between 0.05 and 0.95.</p> </li> <li> <p>Returns static probability values.</p> </li> <li> <p>Save to Database:</p> </li> <li>Results (including <code>analysis_error</code> if analysis failed) are persisted to the <code>Correlations</code> table with <code>correlation_type=\"binary_likelihood\"</code>.</li> <li>This ensures that <code>analysis_error</code> values are preserved across entity reloads.</li> </ol>"},{"location":"technical/analysis-chain/#step-33b-numeric-sensor-analysis","title":"Step 3.3b: Numeric Sensor Analysis","text":"<p>Process:</p> <ol> <li> <p>Data Retrieval:</p> </li> <li> <p>Queries <code>NumericSamples</code> directly for the analysis period.</p> </li> <li> <p>Map to Occupancy:</p> </li> <li> <p>Checks each sample timestamp against <code>OccupiedIntervalsCache</code>.</p> </li> <li> <p>Creates parallel arrays of values and occupancy flags (0/1).</p> </li> <li> <p>Calculate Pearson Correlation:</p> </li> <li> <p>Determines relationship between value and occupancy.</p> </li> <li> <p>Calculate Statistics:</p> </li> <li> <p>Learns Mean/Std for Occupied state.</p> </li> <li> <p>Learns Mean/Std for Unoccupied state.</p> </li> <li> <p>Save Result:</p> </li> <li>Persists parameters to <code>Correlations</code> table, including <code>analysis_error</code> if analysis failed.</li> <li>This ensures that <code>analysis_error</code> values are preserved across entity reloads.</li> </ol>"},{"location":"technical/analysis-chain/#phase-4-likelihood-calculation-runtime","title":"Phase 4: Likelihood Calculation (Runtime)","text":"<p>This phase occurs at runtime whenever the Bayesian probability calculation needs likelihood values.</p>"},{"location":"technical/analysis-chain/#step-41-get-likelihoods","title":"Step 4.1: Get Likelihoods","text":"<p>What Happens:</p> <ol> <li> <p>Check Sensor Type:</p> </li> <li> <p>Binary Sensors (media, appliances, doors, windows):</p> <ul> <li>If analysis has been run: Returns stored <code>prob_given_true</code> and <code>prob_given_false</code>.</li> <li>If not analyzed: Returns <code>EntityType</code> default probabilities.</li> </ul> </li> <li> <p>Numeric Sensors:</p> <ul> <li>Gets current sensor state value.</li> <li>If state is unavailable: Uses representative value (average of occupied/unoccupied means).</li> <li>Calculates Gaussian densities using learned parameters.</li> </ul> </li> <li> <p>Calculate Probabilities:</p> </li> <li> <p>Binary Sensors: Returns static probabilities directly.</p> </li> <li> <p>Numeric Sensors: Calculates \\(P(value | Occupied)\\) and \\(P(value | Unoccupied)\\) using Gaussian PDF.</p> </li> <li> <p>Return Probabilities:</p> </li> <li>Returns the two probabilities for Bayesian update.</li> </ol>"},{"location":"technical/analysis-chain/#key-operations-reference","title":"Key Operations Reference","text":"<p>This section provides a quick reference to the key operations in the analysis chain.</p>"},{"location":"technical/analysis-chain/#data-collection-operations","title":"Data Collection Operations","text":"<ul> <li>State Synchronization: Syncs state changes from Home Assistant recorder to local database</li> </ul>"},{"location":"technical/analysis-chain/#analysis-operations","title":"Analysis Operations","text":"<ul> <li>Full Analysis Orchestration: Orchestrates the complete analysis chain for all areas</li> <li>Occupied Intervals Cache Population: Populates occupied intervals cache from motion sensors</li> <li>Interval Aggregation: Aggregates raw intervals into daily/weekly/monthly summaries</li> <li>Correlation Analysis: Main correlation analysis entry point for all sensors</li> <li>Entity Identification: Identifies entities eligible for correlation analysis</li> <li>Binary Likelihood Calculation: Calculates duration-based probabilities for binary sensors</li> <li>Numeric Correlation Calculation: Calculates Pearson correlation and Gaussian parameters for numeric sensors</li> </ul>"},{"location":"technical/analysis-chain/#runtime-operations","title":"Runtime Operations","text":"<ul> <li>Likelihood Retrieval: Retrieves likelihood values for Bayesian calculation at runtime based on current sensor state</li> </ul>"},{"location":"technical/analysis-chain/#unified-architecture","title":"Unified Architecture","text":"<p>The analysis chain follows a unified architecture that separates concerns by sensor type while maintaining a consistent data flow:</p>"},{"location":"technical/analysis-chain/#data-flow-architecture","title":"Data Flow Architecture","text":"<ol> <li>Continuous Data Collection: Raw sensor data flows from Home Assistant recorder into local database tables</li> <li>Scheduled Analysis: Hourly analysis cycle processes collected data through multiple stages</li> <li>Type-Specific Analysis: Sensors are routed to appropriate analysis methods based on their type</li> <li>Runtime Calculation: Learned parameters are used for real-time likelihood calculation</li> </ol>"},{"location":"technical/analysis-chain/#analysis-method-architecture","title":"Analysis Method Architecture","text":"<p>The system uses a dual-path architecture for sensor analysis:</p> <ul> <li>Binary Path: Duration-based static probability calculation</li> <li>Suitable for: motion, media, appliances, doors, windows</li> <li>Output: Static <code>prob_given_true</code> and <code>prob_given_false</code> values</li> <li> <p>Storage: <code>Correlations</code> table with <code>correlation_type=\"binary_likelihood\"</code></p> </li> <li> <p>Numeric Path: Correlation analysis with Gaussian PDFs</p> </li> <li>Suitable for: temperature, humidity, illuminance, CO2, sound pressure, etc.</li> <li>Output: Gaussian parameters (mean, std_dev) for occupied/unoccupied states</li> <li>Storage: <code>Correlations</code> table with correlation coefficients and statistics</li> </ul>"},{"location":"technical/analysis-chain/#component-architecture","title":"Component Architecture","text":"<p>The architecture consists of four main layers:</p> <ol> <li>Database Layer: Handles data storage, syncing, and correlation analysis</li> <li>Analysis Layer: Orchestrates analysis cycles and prior calculations</li> <li>Entity Layer: Manages entity state and runtime likelihood calculation</li> <li>Coordinator Layer: Coordinates all components and schedules analysis</li> </ol>"},{"location":"technical/analysis-chain/#architecture-overview","title":"Architecture Overview","text":"<p>The system uses different analysis methods optimized for each sensor type:</p>"},{"location":"technical/analysis-chain/#key-design-decisions","title":"Key Design Decisions","text":"<ol> <li>Numeric Sensors: Use correlation analysis with Gaussian PDFs for dynamic, continuous likelihood calculation.</li> <li>Binary Sensors: Use duration-based analysis for simple, reliable static probabilities.</li> <li>Motion Sensors: Use configured static probabilities (not analyzed).</li> </ol>"},{"location":"technical/analysis-chain/#benefits","title":"Benefits","text":"<ul> <li>Appropriate Methods: Each sensor type uses the analysis method best suited to its data characteristics.</li> <li>Dynamic Likelihoods (Numeric): Continuous values benefit from Gaussian PDF calculation.</li> <li>Simple Reliability (Binary): Binary states benefit from straightforward duration-based probabilities.</li> <li>Maintainability: Clear separation of concerns between analysis methods.</li> <li>Flexibility: Easy to add new sensor types or analysis methods in the future.</li> </ul>"},{"location":"technical/bayesian-calculation/","title":"Bayesian Calculation Deep Dive","text":"<p>This document provides a detailed mathematical explanation of the Bayesian probability calculation used for area occupancy detection.</p>"},{"location":"technical/bayesian-calculation/#mathematical-foundation","title":"Mathematical Foundation","text":""},{"location":"technical/bayesian-calculation/#bayes-theorem","title":"Bayes' Theorem","text":"<p>The calculation is based on Bayes' theorem, which updates prior beliefs with new evidence:</p> \\[ P(Occupied | Evidence) = \\frac{P(Evidence | Occupied) \\times P(Occupied)}{P(Evidence)} \\] <p>Where:</p> <ul> <li><code>P(Occupied | Evidence)</code>: Posterior probability (what we want to calculate)</li> <li><code>P(Evidence | Occupied)</code>: Likelihood (how likely is this evidence if occupied)</li> <li><code>P(Occupied)</code>: Prior probability (baseline belief)</li> <li><code>P(Evidence)</code>: Normalization constant</li> </ul>"},{"location":"technical/bayesian-calculation/#multiple-evidence-sources","title":"Multiple Evidence Sources","text":"<p>With multiple sensors, we combine evidence using the assumption of conditional independence:</p> \\[ P(Occupied | E*1, E_2, ..., E_n) \\propto P(Occupied) \\times \\prod*{i=1}^{n} P(E_i | Occupied) \\] <p>This means we multiply the prior by the likelihoods from all sensors.</p>"},{"location":"technical/bayesian-calculation/#log-space-implementation","title":"Log-Space Implementation","text":""},{"location":"technical/bayesian-calculation/#why-log-space","title":"Why Log Space?","text":"<p>Working in log space provides numerical stability when multiplying many probabilities:</p> <p>Problems with probability space:</p> <ul> <li>Multiplying many small probabilities can underflow to zero</li> <li>Very small probabilities lose precision</li> <li>Division by normalization constant can overflow</li> </ul> <p>Benefits of log space:</p> <ul> <li>Addition instead of multiplication (more stable)</li> <li>Larger dynamic range</li> <li>Better precision for small values</li> </ul>"},{"location":"technical/bayesian-calculation/#log-space-conversion","title":"Log-Space Conversion","text":"<p>The calculation converts probabilities to log space:</p> \\[ \\log P(Occupied | Evidence) = \\log P(Occupied) + \\sum\\_{i=1}^{n} \\log P(E_i | Occupied) \\] \\[ \\log P(Not Occupied | Evidence) = \\log(1 - P(Occupied)) + \\sum\\_{i=1}^{n} \\log P(E_i | Not Occupied) \\]"},{"location":"technical/bayesian-calculation/#normalization","title":"Normalization","text":"<p>After accumulating log probabilities, we normalize back to probability space:</p> \\[ P(Occupied | Evidence) = \\frac{e^{\\log P(Occupied | Evidence)}}{e^{\\log P(Occupied | Evidence)} + e^{\\log P(Not Occupied | Evidence)}} \\] <p>To prevent overflow, we subtract the maximum log value:</p> \\[ \\max_log = \\max(\\log P(Occupied), \\log P(Not Occupied)) \\] \\[ P(Occupied) = \\frac{e^{\\log P(Occupied) - \\max_log}}{e^{\\log P(Occupied) - \\max_log} + e^{\\log P(Not Occupied) - \\max_log}} \\]"},{"location":"technical/bayesian-calculation/#step-by-step-calculation","title":"Step-by-Step Calculation","text":"<p>The Bayesian probability calculation follows these steps:</p>"},{"location":"technical/bayesian-calculation/#step-1-entity-filtering","title":"Step 1: Entity Filtering","text":"<p>Filter out entities that can't contribute:</p> <ol> <li>Empty entities dict: Return prior if no entities</li> <li>Zero weight entities: Exclude entities with <code>weight == 0.0</code></li> <li>Invalid likelihoods: Exclude entities where:</li> <li><code>prob_given_true &lt;= 0.0</code> or <code>&gt;= 1.0</code></li> <li><code>prob_given_false &lt;= 0.0</code> or <code>&gt;= 1.0</code></li> </ol> <p>These would cause <code>log(0)</code> or <code>log(1)</code> errors.</p>"},{"location":"technical/bayesian-calculation/#step-2-prior-clamping","title":"Step 2: Prior Clamping","text":"<p>Ensure prior is in valid range by clamping it to <code>[MIN_PROBABILITY, MAX_PROBABILITY]</code>. This prevents <code>log(0)</code> or <code>log(1)</code> when initializing log probabilities.</p>"},{"location":"technical/bayesian-calculation/#step-3-log-space-initialization","title":"Step 3: Log-Space Initialization","text":"<p>Initialize log probabilities:</p> <p>[ \\log P(Occupied) = \\log(prior) ] [ \\log P(Not Occupied) = \\log(1 - prior) ]</p> <p>These represent the log probabilities for \"occupied\" and \"not occupied\" hypotheses before considering any entity evidence.</p>"},{"location":"technical/bayesian-calculation/#step-4-entity-processing-loop","title":"Step 4: Entity Processing Loop","text":"<p>For each entity:</p>"},{"location":"technical/bayesian-calculation/#4a-get-evidence-and-decay","title":"4a. Get Evidence and Decay","text":"<p>Determine the current evidence state (active, inactive, or unavailable) and whether the entity is currently decaying from previous activity.</p>"},{"location":"technical/bayesian-calculation/#4b-skip-unavailable-entities","title":"4b. Skip Unavailable Entities","text":"<p>Entities with unavailable evidence are skipped unless they're decaying. This prevents unavailable sensors from affecting the calculation.</p>"},{"location":"technical/bayesian-calculation/#4c-determine-effective-evidence","title":"4c. Determine Effective Evidence","text":"<p>An entity provides evidence if it is currently active OR decaying. This ensures that recently active entities continue to contribute even after their state becomes inactive.</p>"},{"location":"technical/bayesian-calculation/#4d-get-likelihoods","title":"4d. Get Likelihoods","text":"<p>If effective evidence is present, use the learned likelihoods directly. If the entity is decaying, interpolate the likelihoods between their learned values and neutral (0.5) based on the decay factor:</p> \\[ p_{adjusted} = 0.5 + (p_{learned} - 0.5) \\times decay\\_factor \\] <p>If no effective evidence (inactive sensor), use inverse likelihoods:</p> <p>[ p_t = 1.0 - prob_given_true \\quad \\text{(P(Inactive | Occupied))} ] [ p_f = 1.0 - prob_given_false \\quad \\text{(P(Inactive | Not Occupied))} ]</p> <p>This ensures inactive sensors provide proper negative evidence. For example, if a sensor is usually active when occupied (<code>prob_given_true = 0.8</code>), then when it's inactive, it suggests the area is likely not occupied (<code>p_t = 0.2</code>).</p>"},{"location":"technical/bayesian-calculation/#4e-clamp-likelihoods","title":"4e. Clamp Likelihoods","text":"<p>Clamp likelihoods to valid range to prevent <code>log(0)</code> or <code>log(1)</code> errors.</p>"},{"location":"technical/bayesian-calculation/#4f-calculate-weighted-log-contributions","title":"4f. Calculate Weighted Log Contributions","text":"<p>Calculate the weighted log contribution for each entity:</p> <p>[ contribution_true = \\log(p_t) \\times weight ] [ contribution_false = \\log(p_f) \\times weight ]</p> <p>Accumulate into log probabilities:</p> <p>[ \\log P(Occupied) += contribution_true ] [ \\log P(Not Occupied) += contribution_false ]</p> <p>The weight multiplies the log contribution, so:</p> <ul> <li>Weight 1.0: Full contribution</li> <li>Weight 0.5: Half contribution</li> <li>Weight 0.0: No contribution (filtered out earlier)</li> </ul>"},{"location":"technical/bayesian-calculation/#step-5-normalization","title":"Step 5: Normalization","text":"<p>Convert back to probability space:</p> <p>[ \\max_log = \\max(\\log P(Occupied), \\log P(Not Occupied)) ] [ P(Occupied) = \\frac{e^{\\log P(Occupied) - \\max_log}}{e^{\\log P(Occupied) - \\max_log} + e^{\\log P(Not Occupied) - \\max_log}} ]</p> <p>The subtraction of <code>max_log</code> prevents overflow when exponentiating. If both probabilities become zero after exponentiation, the calculation returns the prior as a fallback.</p>"},{"location":"technical/bayesian-calculation/#inverse-likelihoods-for-inactive-sensors","title":"Inverse Likelihoods for Inactive Sensors","text":"<p>When a sensor is inactive (not providing evidence), the system uses inverse likelihoods instead of neutral probabilities.</p>"},{"location":"technical/bayesian-calculation/#why-inverse-likelihoods","title":"Why Inverse Likelihoods?","text":"<p>Inactive sensors should provide negative evidence based on their learned behavior:</p> <ul> <li>If a sensor is usually active when occupied (<code>prob_given_true</code> is high), then when it's inactive, it suggests the area is likely not occupied</li> <li>If a sensor is rarely active when not occupied (<code>prob_given_false</code> is low), then when it's inactive, it's consistent with the area being not occupied</li> </ul> <p>Using neutral probabilities (0.5) for inactive sensors would:</p> <ul> <li>Dilute the effect of active sensors</li> <li>Ignore valuable negative evidence</li> <li>Cause incorrect probability calculations when multiple sensors are configured</li> </ul>"},{"location":"technical/bayesian-calculation/#inverse-likelihood-calculation","title":"Inverse Likelihood Calculation","text":"<p>For inactive sensors:</p> <pre><code>p_t = 1.0 - prob_given_true  # P(Inactive | Occupied)\np_f = 1.0 - prob_given_false  # P(Inactive | Not Occupied)\n</code></pre> <p>Example:</p> <ul> <li>Sensor with <code>prob_given_true = 0.8, prob_given_false = 0.1</code></li> <li>When active: uses <code>p_t = 0.8, p_f = 0.1</code> (strong positive evidence)</li> <li>When inactive: uses <code>p_t = 0.2, p_f = 0.9</code> (negative evidence, suggests not occupied)</li> </ul> <p>This ensures inactive sensors contribute meaningful evidence to the calculation rather than being neutral.</p>"},{"location":"technical/bayesian-calculation/#decay-interpolation","title":"Decay Interpolation","text":"<p>When an entity is decaying, its likelihoods are interpolated toward neutral (0.5).</p>"},{"location":"technical/bayesian-calculation/#interpolation-formula","title":"Interpolation Formula","text":"\\[ p*{adjusted} = 0.5 + (p*{learned} - 0.5) \\times decay_factor \\] <p>Where:</p> <ul> <li><code>p_learned</code>: The learned likelihood (either <code>prob_given_true</code> or <code>prob_given_false</code>)</li> <li><code>decay_factor</code>: Ranges from 0.0 (fully decayed) to 1.0 (fresh)</li> <li>0.5: Neutral probability (no evidence either way)</li> </ul>"},{"location":"technical/bayesian-calculation/#effect-of-decay","title":"Effect of Decay","text":"<p>As decay progresses:</p> <ul> <li><code>decay_factor</code> decreases from 1.0 toward 0.0</li> <li>Likelihoods move from learned values toward 0.5 (neutral)</li> <li>Contribution to probability decreases</li> <li>Eventually becomes neutral (no influence)</li> </ul>"},{"location":"technical/bayesian-calculation/#example","title":"Example","text":"<p>Entity with <code>prob_given_true = 0.9</code> (very reliable):</p> <ul> <li>Fresh: <code>p_t = 0.9</code> (full strength)</li> <li>50% decayed: <code>p_t = 0.5 + (0.9 - 0.5) * 0.5 = 0.7</code> (reduced)</li> <li>90% decayed: <code>p_t = 0.5 + (0.9 - 0.5) * 0.1 = 0.54</code> (almost neutral)</li> <li>Expired: <code>p_t = 0.5</code> (no influence)</li> </ul>"},{"location":"technical/bayesian-calculation/#weight-application","title":"Weight Application","text":"<p>Entity weights determine how much each entity's evidence contributes.</p>"},{"location":"technical/bayesian-calculation/#weighted-log-contribution","title":"Weighted Log Contribution","text":"\\[ contribution = \\log(p) \\times weight \\] <p>Where:</p> <ul> <li><code>p</code>: The likelihood probability</li> <li><code>weight</code>: Entity weight (0.0-1.0)</li> </ul>"},{"location":"technical/bayesian-calculation/#weight-impact","title":"Weight Impact","text":"<ul> <li>Weight 1.0: Full contribution (entity fully influences result)</li> <li>Weight 0.5: Half contribution (moderate influence)</li> <li>Weight 0.0: No contribution (excluded from calculation)</li> </ul>"},{"location":"technical/bayesian-calculation/#example_1","title":"Example","text":"<p>Two entities with same likelihoods but different weights:</p> <ul> <li>Entity A: <code>p_t = 0.8</code>, <code>weight = 1.0</code> \u2192 <code>contribution = log(0.8) * 1.0 = -0.223</code></li> <li>Entity B: <code>p_t = 0.8</code>, <code>weight = 0.5</code> \u2192 <code>contribution = log(0.8) * 0.5 = -0.112</code></li> </ul> <p>Entity A has twice the influence of Entity B.</p>"},{"location":"technical/bayesian-calculation/#complete-example-calculation","title":"Complete Example Calculation","text":"<p>Consider an area with:</p> <ul> <li>Prior: 0.3 (30%)</li> <li>Motion sensor: Active, weight 0.85, <code>p_t = 0.9</code>, <code>p_f = 0.1</code></li> <li>Media player: Inactive, weight 0.70, <code>p_t = 0.6</code>, <code>p_f = 0.2</code></li> <li>Door sensor: Active, weight 0.25, <code>p_t = 0.4</code>, <code>p_f = 0.3</code></li> </ul>"},{"location":"technical/bayesian-calculation/#step-1-initialize","title":"Step 1: Initialize","text":"<pre><code>log_true = log(0.3) = -1.204\nlog_false = log(0.7) = -0.357\n</code></pre>"},{"location":"technical/bayesian-calculation/#step-2-process-motion-sensor-active","title":"Step 2: Process Motion Sensor (Active)","text":"<pre><code>p_t = 0.9, p_f = 0.1\nlog_true += log(0.9) * 0.85 = -1.204 + (-0.105) * 0.85 = -1.293\nlog_false += log(0.1) * 0.85 = -0.357 + (-2.303) * 0.85 = -2.315\n</code></pre>"},{"location":"technical/bayesian-calculation/#step-3-process-media-player-inactive","title":"Step 3: Process Media Player (Inactive)","text":"<p>For inactive entities, we use inverse probabilities:</p> <pre><code>p_t = 1 - 0.6 = 0.4  # P(Inactive | Occupied)\np_f = 1 - 0.2 = 0.8  # P(Inactive | Not Occupied)\n\nlog_true += log(0.4) * 0.70 = -1.293 + (-0.916) * 0.70 = -1.934\nlog_false += log(0.8) * 0.70 = -2.315 + (-0.223) * 0.70 = -2.471\n</code></pre>"},{"location":"technical/bayesian-calculation/#step-4-process-door-sensor-active","title":"Step 4: Process Door Sensor (Active)","text":"<pre><code>p_t = 0.4, p_f = 0.3\nlog_true += log(0.4) * 0.25 = -1.934 + (-0.916) * 0.25 = -2.163\nlog_false += log(0.3) * 0.25 = -2.471 + (-1.204) * 0.25 = -2.772\n</code></pre>"},{"location":"technical/bayesian-calculation/#step-5-normalize","title":"Step 5: Normalize","text":"<pre><code>max_log = max(-2.163, -2.772) = -2.163\ntrue_prob = exp(-2.163 - (-2.163)) = exp(0) = 1.0\nfalse_prob = exp(-2.772 - (-2.163)) = exp(-0.609) = 0.544\nprobability = 1.0 / (1.0 + 0.544) = 0.648 (64.8%)\n</code></pre> <p>The motion sensor's strong positive evidence (active with high <code>p_t</code>) significantly increases the probability from 30% to 64.8%.</p>"},{"location":"technical/bayesian-calculation/#numerical-stability-techniques","title":"Numerical Stability Techniques","text":""},{"location":"technical/bayesian-calculation/#clamping-probabilities","title":"Clamping Probabilities","text":"<p>All probabilities are clamped to a valid range <code>[MIN_PROBABILITY, MAX_PROBABILITY]</code> to prevent:</p> <ul> <li><code>log(0)</code> errors (MIN_PROBABILITY &gt; 0)</li> <li><code>log(1)</code> errors (MAX_PROBABILITY &lt; 1)</li> </ul>"},{"location":"technical/bayesian-calculation/#max-log-subtraction","title":"Max Log Subtraction","text":"<p>Subtracting the maximum log value before exponentiation prevents overflow:</p> <p>[ \\max_log = \\max(\\log P(Occupied), \\log P(Not Occupied)) ] [ P(Occupied) = e^{\\log P(Occupied) - \\max_log} ]</p> <p>This ensures at least one exponentiated value is 1.0, preventing overflow.</p>"},{"location":"technical/bayesian-calculation/#edge-case-handling","title":"Edge Case Handling","text":"<p>If both probabilities become zero after exponentiation (shouldn't happen but handled defensively), the calculation returns the prior as a fallback.</p>"},{"location":"technical/bayesian-calculation/#performance-considerations","title":"Performance Considerations","text":""},{"location":"technical/bayesian-calculation/#log-space-efficiency","title":"Log Space Efficiency","text":"<p>Log space calculations are computationally efficient:</p> <ul> <li>Addition instead of multiplication</li> <li>Single normalization step at the end</li> <li>No intermediate probability calculations</li> </ul>"},{"location":"technical/bayesian-calculation/#entity-filtering","title":"Entity Filtering","text":"<p>Early filtering of invalid entities reduces computation:</p> <ul> <li>Zero-weight entities excluded before loop</li> <li>Invalid likelihoods excluded before loop</li> <li>Unavailable entities skipped in loop</li> </ul>"},{"location":"technical/bayesian-calculation/#caching","title":"Caching","text":"<p>Prior values are cached to avoid repeated database queries:</p> <ul> <li>Time-based priors cached by (day, slot)</li> <li>Cache invalidated on update</li> <li>Reduces database load during real-time calculations</li> </ul>"},{"location":"technical/bayesian-calculation/#see-also","title":"See Also","text":"<ul> <li>Complete Calculation Flow - End-to-end process</li> <li>Calculation Feature - User-facing documentation</li> <li>Prior Calculation Deep Dive - How priors are calculated</li> <li>Likelihood Calculation Deep Dive - How likelihoods are learned</li> <li>Entity Evidence Collection - How evidence is determined</li> </ul>"},{"location":"technical/calculation-flow/","title":"Complete Calculation Flow","text":"<p>This document provides a comprehensive end-to-end explanation of how area occupancy probability is calculated, from initial setup through real-time updates.</p>"},{"location":"technical/calculation-flow/#overview","title":"Overview","text":"<p>The area occupancy calculation process operates in two main phases:</p> <ol> <li>Initialization &amp; Learning Phase: Sets up the system, loads historical data, and learns prior probabilities and likelihoods from sensor history</li> <li>Real-Time Calculation Phase: Continuously monitors sensor states and calculates current occupancy probability using Bayesian inference</li> </ol>"},{"location":"technical/calculation-flow/#phase-1-initialization-learning","title":"Phase 1: Initialization &amp; Learning","text":""},{"location":"technical/calculation-flow/#coordinator-setup","title":"Coordinator Setup","text":"<p>The process begins when Home Assistant loads the integration. The system initializes all areas and their components.</p> <p>Key steps:</p> <ol> <li>Load areas from configuration</li> <li>Validate at least one area exists</li> <li>Initialize each area's components</li> <li>Load stored data from database</li> <li>Track entity state changes</li> <li>Start periodic timers (decay, save, analysis)</li> </ol>"},{"location":"technical/calculation-flow/#area-initialization","title":"Area Initialization","text":"<p>Each area is initialized with its configuration and components.</p> <p>Components created:</p> <ul> <li>Config: Area-specific configuration (sensors, thresholds, weights)</li> <li>EntityManager: Manages all sensor entities for the area</li> <li>Prior: Handles prior probability calculations and caching</li> <li>Purpose: Manages area purpose and decay settings</li> </ul>"},{"location":"technical/calculation-flow/#database-loading","title":"Database Loading","text":"<p>Historical data is loaded from the database to restore learned priors and likelihoods.</p> <p>The database stores:</p> <ul> <li>Global priors for each area</li> <li>Time-based priors (day of week \u00d7 time slot)</li> <li>Entity likelihoods (<code>P(Active|Occupied)</code> and <code>P(Active|Not Occupied)</code>)</li> <li>Entity configurations and states</li> </ul>"},{"location":"technical/calculation-flow/#prior-analysis","title":"Prior Analysis","text":"<p>The system learns baseline occupancy probabilities from historical sensor data. This includes calculating both global priors (overall occupancy rate) and time-based priors (occupancy probability for each day-of-week and time-slot combination).</p> <p>See Prior Learning for detailed explanation of how priors are calculated and used.</p>"},{"location":"technical/calculation-flow/#likelihood-analysis","title":"Likelihood Analysis","text":"<p>The system learns how reliable each sensor is as evidence of occupancy by analyzing sensor activity relative to occupied intervals determined from motion sensors.</p> <p>See Likelihood Calculation for detailed explanation of how likelihoods are learned for different sensor types.</p>"},{"location":"technical/calculation-flow/#phase-2-real-time-calculation","title":"Phase 2: Real-Time Calculation","text":""},{"location":"technical/calculation-flow/#entity-state-change-detection","title":"Entity State Change Detection","text":"<p>When any monitored sensor changes state, the system detects the change and triggers recalculation.</p> <p>Flow:</p> <ol> <li>Home Assistant fires state change event</li> <li>System receives the state change event</li> <li>Finds which area(s) contain the changed entity</li> <li>Checks if entity has new evidence</li> <li>If evidence changed, triggers probability recalculation</li> </ol>"},{"location":"technical/calculation-flow/#evidence-collection","title":"Evidence Collection","text":"<p>Each entity determines its current evidence state (active/inactive/unavailable) by checking its current state against configured active criteria. Entities that are decaying from recent activity may still provide evidence.</p> <p>See Entity Evidence Collection for detailed explanation of how evidence is collected and integrated with decay.</p>"},{"location":"technical/calculation-flow/#decay-calculation","title":"Decay Calculation","text":"<p>When evidence transitions from active to inactive, decay gradually reduces its influence.</p> <p>Process:</p> <ol> <li>Decay starts when evidence transitions from active to inactive</li> <li>Decay factor calculated using exponential decay: <code>0.5^(age/half_life)</code></li> <li>Decay stops when:</li> <li>Evidence becomes active again</li> <li>Decay factor drops below 5% (practical zero)</li> </ol> <p>See Decay Feature for user-facing documentation.</p>"},{"location":"technical/calculation-flow/#prior-combination","title":"Prior Combination","text":"<p>The system combines the global prior with the time-based prior for the current time slot.</p> <p>Process:</p> <ol> <li>Gets global prior from database (learned from history)</li> <li>Gets time-based prior for current day-of-week and time-slot</li> <li>Combines using weighted average in logit space</li> <li>Applies prior factor (1.05) to slightly increase baseline probability</li> <li>Clamps to valid range [MIN_PROBABILITY, MAX_PROBABILITY]</li> </ol> <p>The combination uses logit space for better interpolation:</p> <ul> <li>Converts probabilities to logits: <code>logit(p) = log(p / (1-p))</code></li> <li>Weighted combination: <code>combined_logit = area_weight * area_logit + time_weight * time_logit</code></li> <li>Converts back: <code>combined_prior = 1 / (1 + exp(-combined_logit))</code></li> </ul>"},{"location":"technical/calculation-flow/#bayesian-probability-calculation","title":"Bayesian Probability Calculation","text":"<p>The core calculation combines all entity evidence with the prior using Bayesian inference.</p> <p>Process:</p> <ol> <li>Entity Filtering: Removes entities with zero weight or invalid likelihoods</li> <li>Prior Clamping: Ensures prior is in valid range</li> <li>Log-Space Initialization: Starts with log probabilities for occupied and not-occupied hypotheses</li> <li>Entity Processing: For each entity:</li> <li>Determines effective evidence (current or decaying)</li> <li>Gets likelihoods based on evidence state:<ul> <li>Active entities: Uses <code>prob_given_true</code> and <code>prob_given_false</code> directly</li> <li>Inactive entities: Uses inverse likelihoods (<code>1 - prob_given_true</code>, <code>1 - prob_given_false</code>)</li> </ul> </li> <li>Applies decay interpolation if entity is decaying</li> <li>Calculates log contributions weighted by entity weight</li> <li>Accumulates into log probabilities</li> <li>Normalization: Converts log probabilities back to probability space</li> <li>Result: Final probability between 0.0 and 1.0</li> </ol> <p>See Bayesian Calculation Deep Dive for detailed mathematical explanation.</p>"},{"location":"technical/calculation-flow/#final-probability-output","title":"Final Probability Output","text":"<p>The calculated probability is exposed through Home Assistant sensors.</p> <p>Outputs:</p> <ul> <li>Occupancy Probability Sensor: Shows the calculated probability (0.0-1.0)</li> <li>Occupancy Status Binary Sensor: <code>on</code> if probability &gt;= threshold, <code>off</code> otherwise</li> <li>Prior Probability Sensor: Shows the combined prior value</li> <li>Evidence Sensor: Shows which entities are providing evidence</li> <li>Decay Sensor: Shows decay status</li> </ul>"},{"location":"technical/calculation-flow/#complete-flow-diagram","title":"Complete Flow Diagram","text":"<p>See Data Flow Diagrams for visual representations of these processes.</p>"},{"location":"technical/calculation-flow/#key-concepts","title":"Key Concepts","text":""},{"location":"technical/calculation-flow/#log-space-calculation","title":"Log-Space Calculation","text":"<p>All probability calculations use log space for numerical stability. This prevents underflow/overflow when multiplying many small probabilities together.</p>"},{"location":"technical/calculation-flow/#decay-interpolation","title":"Decay Interpolation","text":"<p>When an entity is decaying, its likelihoods are interpolated between their learned values and neutral (0.5) based on the decay factor. This gradually reduces the influence of stale evidence.</p>"},{"location":"technical/calculation-flow/#entity-weights","title":"Entity Weights","text":"<p>Each entity type has a configured weight (0.0-1.0) that determines how much its evidence contributes to the final probability. Higher weights mean stronger influence.</p>"},{"location":"technical/calculation-flow/#prior-factor","title":"Prior Factor","text":"<p>The prior is multiplied by 1.05 before use, slightly increasing the baseline probability. This helps prevent the system from being too conservative.</p>"},{"location":"technical/calculation-flow/#see-also","title":"See Also","text":"<ul> <li>Prior Calculation Deep Dive - Detailed prior learning process</li> <li>Likelihood Calculation Deep Dive - Detailed likelihood learning process</li> <li>Entity Evidence Collection - How evidence is determined</li> <li>Bayesian Calculation Deep Dive - Mathematical details</li> <li>Data Flow Diagrams - Visual flow diagrams</li> <li>Calculation Feature - User-facing documentation</li> <li>Prior Learning Feature - Prior learning overview</li> <li>Decay Feature - Decay mechanism overview</li> </ul>"},{"location":"technical/data-flow/","title":"Data Flow Diagrams","text":"<p>This document provides visual flow diagrams showing how data moves through the area occupancy calculation system.</p>"},{"location":"technical/data-flow/#initialization-flow","title":"Initialization Flow","text":"<p>The initialization sequence diagram shows how the system sets up when Home Assistant starts:</p> <pre><code>sequenceDiagram\n    participant HA as Home Assistant\n    participant Coord as Coordinator\n    participant Area as Area\n    participant DB as Database\n    participant Prior as Prior\n    participant Entities as EntityManager\n    participant Analysis as Analysis\n\n    HA-&gt;&gt;Coord: async_config_entry_first_refresh()\n    Coord-&gt;&gt;Coord: setup()\n    Coord-&gt;&gt;Area: Load areas from config\n    Area-&gt;&gt;Area: Initialize components\n    Coord-&gt;&gt;DB: async_init_database()\n    DB--&gt;&gt;Coord: Database ready\n    Coord-&gt;&gt;DB: load_data()\n    DB-&gt;&gt;Prior: Load global priors\n    DB-&gt;&gt;Entities: Load entity configs\n    DB-&gt;&gt;Entities: Load likelihoods\n    Prior--&gt;&gt;Coord: Priors loaded\n    Entities--&gt;&gt;Coord: Entities loaded\n    Coord-&gt;&gt;Coord: track_entity_state_changes()\n    Coord-&gt;&gt;Coord: Start timers (decay, save, analysis)\n    Coord--&gt;&gt;HA: Setup complete</code></pre>"},{"location":"technical/data-flow/#learning-phase-flow","title":"Learning Phase Flow","text":"<p>The learning phase flowchart shows how priors and likelihoods are learned from historical data:</p> <pre><code>flowchart TD\n    Start([Analysis Timer Fires]) --&gt; Sync[Sync States from Recorder]\n    Sync --&gt; HealthCheck[Database Health Check]\n    HealthCheck --&gt; Prune[Prune Old Intervals]\n    Prune --&gt; PriorAnalysis[Run Prior Analysis]\n\n    PriorAnalysis --&gt; GetMotion[Get Motion Intervals]\n    GetMotion --&gt; CalcPeriod[Calculate Data Period]\n    CalcPeriod --&gt; CalcGlobal[Calculate Global Prior]\n    CalcGlobal --&gt; SetMemory[Set in Prior Object]\n    SetMemory --&gt; SaveGlobal[Save Global Prior to DB]\n    SaveGlobal --&gt; TimePrior[Calculate Time Priors]\n    TimePrior --&gt; Aggregate[Aggregate by Day/Slot]\n    Aggregate --&gt; CalcTime[Calculate Prior per Slot]\n    CalcTime --&gt; SaveTime[Save Time Priors]\n\n    SaveTime --&gt; LikelihoodAnalysis[Run Likelihood Analysis]\n    LikelihoodAnalysis --&gt; GetOccupied[Get Occupied Intervals]\n    GetOccupied --&gt; ForEach[For Each Entity]\n    ForEach --&gt; GetIntervals[Get Entity Intervals]\n    GetIntervals --&gt; Correlate[Correlate with Occupied]\n    Correlate --&gt; CalcLikelihood[Calculate Likelihoods]\n    CalcLikelihood --&gt; SaveLikelihood[Save Likelihoods]\n    SaveLikelihood --&gt; MoreEntities{More Entities?}\n    MoreEntities --&gt;|Yes| ForEach\n    MoreEntities --&gt;|No| Refresh[Refresh Coordinator]\n    Refresh --&gt; Save[Save to Database]\n    Save --&gt; End([Analysis Complete])</code></pre>"},{"location":"technical/data-flow/#real-time-update-flow","title":"Real-Time Update Flow","text":"<p>The real-time update sequence diagram shows what happens when a sensor state changes:</p> <pre><code>sequenceDiagram\n    participant Sensor as Sensor Entity\n    participant HA as Home Assistant\n    participant Coord as Coordinator\n    participant Entity as Entity Object\n    participant Area as Area\n    participant Prior as Prior\n    participant Bayes as Bayesian Calc\n    participant Output as Output Sensors\n\n    Sensor-&gt;&gt;HA: State Change Event\n    HA-&gt;&gt;Coord: State Change Callback\n    Coord-&gt;&gt;Entity: has_new_evidence()\n    Entity-&gt;&gt;HA: Get Current State\n    HA--&gt;&gt;Entity: State Value\n    Entity-&gt;&gt;Entity: Determine Evidence\n    Entity-&gt;&gt;Entity: Check Decay Transition\n\n    alt Evidence Changed\n        Entity-&gt;&gt;Entity: Update Decay State\n        Entity--&gt;&gt;Coord: Transition Detected\n        Coord-&gt;&gt;Coord: async_refresh()\n        Coord-&gt;&gt;Area: probability()\n        Area-&gt;&gt;Prior: value (get combined prior)\n        Prior-&gt;&gt;Prior: Get Global Prior\n        Prior-&gt;&gt;Prior: Get Time Prior\n        Prior-&gt;&gt;Prior: combine_priors()\n        Prior--&gt;&gt;Area: Combined Prior\n        Area-&gt;&gt;Bayes: bayesian_probability()\n        Bayes-&gt;&gt;Entity: Get Evidence &amp; Likelihoods\n        Entity--&gt;&gt;Bayes: Evidence Data\n        Bayes-&gt;&gt;Bayes: Calculate in Log Space\n        Bayes--&gt;&gt;Area: Final Probability\n        Area-&gt;&gt;Output: Update Probability Sensor\n        Area-&gt;&gt;Output: Update Status Binary\n        Area-&gt;&gt;Output: Update Other Sensors\n    end</code></pre>"},{"location":"technical/data-flow/#entity-state-change-to-probability-update-flow","title":"Entity State Change to Probability Update Flow","text":"<p>This flowchart shows the detailed flow from entity state change to final probability:</p> <pre><code>flowchart TD\n    Start([Entity State Changes]) --&gt; GetState[Get State from HA]\n    GetState --&gt; CheckAvailable{State Available?}\n    CheckAvailable --&gt;|No| Skip[Skip Entity]\n    CheckAvailable --&gt;|Yes| CheckActive{State Active?}\n\n    CheckActive --&gt;|Yes| EvidenceTrue[Evidence = True]\n    CheckActive --&gt;|No| EvidenceFalse[Evidence = False]\n\n    EvidenceTrue --&gt; CheckPrevious{Previous Evidence?}\n    EvidenceFalse --&gt; CheckPrevious\n\n    CheckPrevious --&gt;|Was False| Transition[Transition Detected]\n    CheckPrevious --&gt;|Was True| NoTransition[No Transition]\n    CheckPrevious --&gt;|Was None| NoTransition\n\n    Transition --&gt; CheckDirection{Which Direction?}\n    CheckDirection --&gt;|False\u2192True| StopDecay[Stop Decay]\n    CheckDirection --&gt;|True\u2192False| StartDecay[Start Decay]\n\n    StopDecay --&gt; UpdatePrevious[Update Previous Evidence]\n    StartDecay --&gt; UpdatePrevious\n    NoTransition --&gt; UpdatePrevious\n\n    UpdatePrevious --&gt; GetPrior[Get Combined Prior]\n    GetPrior --&gt; GetGlobal[Get Global Prior]\n    GetPrior --&gt; GetTime[Get Time Prior]\n    GetGlobal --&gt; Combine[Combine in Logit Space]\n    GetTime --&gt; Combine\n\n    Combine --&gt; InitLog[Initialize Log Probabilities]\n    InitLog --&gt; FilterEntities[Filter Entities]\n    FilterEntities --&gt; ForEach[For Each Entity]\n\n    ForEach --&gt; GetEvidence[Get Effective Evidence]\n    GetEvidence --&gt; CheckDecay{Is Decaying?}\n    CheckDecay --&gt;|Yes| Interpolate[Interpolate Likelihoods]\n    CheckDecay --&gt;|No| UseLearned[Use Learned Likelihoods]\n\n    Interpolate --&gt; Weight[Apply Entity Weight]\n    UseLearned --&gt; Weight\n    Weight --&gt; Accumulate[Accumulate Log Contributions]\n    Accumulate --&gt; More{More Entities?}\n    More --&gt;|Yes| ForEach\n    More --&gt;|No| Normalize[Normalize to Probability]\n\n    Normalize --&gt; Clamp[Clamp to Valid Range]\n    Clamp --&gt; UpdateOutput[Update Output Sensors]\n    UpdateOutput --&gt; End([Complete])\n\n    Skip --&gt; End</code></pre>"},{"location":"technical/data-flow/#component-interaction-diagram","title":"Component Interaction Diagram","text":"<p>This graph shows how the main components interact:</p> <pre><code>graph TB\n    subgraph \"Home Assistant\"\n        HA[Home Assistant Core]\n        States[State Registry]\n        Recorder[Recorder Database]\n    end\n\n    subgraph \"Area Occupancy Integration\"\n        Coord[AreaOccupancyCoordinator]\n\n        subgraph \"Area Components\"\n            Area[Area]\n            Config[AreaConfig]\n            Prior[Prior]\n            Entities[EntityManager]\n            Purpose[Purpose]\n        end\n\n        subgraph \"Analysis\"\n            PriorAnalysis[PriorAnalyzer]\n            CorrelationAnalysis[Correlation Analysis]\n        end\n\n        subgraph \"Database\"\n            DB[(AreaOccupancyDB)]\n            Tables[Tables: Areas, Entities, Priors, Intervals]\n        end\n\n        subgraph \"Calculation\"\n            Utils[Bayesian Utils]\n            Decay[Decay Model]\n        end\n\n        subgraph \"Output\"\n            Sensors[HA Sensors]\n            Binary[Binary Sensors]\n        end\n    end\n\n    HA --&gt;|State Changes| Coord\n    States --&gt;|Get State| Entities\n    Recorder --&gt;|Sync History| DB\n\n    Coord --&gt;|Manages| Area\n    Area --&gt;|Contains| Config\n    Area --&gt;|Contains| Prior\n    Area --&gt;|Contains| Entities\n    Area --&gt;|Contains| Purpose\n\n    Coord --&gt;|Orchestrates| PriorAnalysis\n    Coord --&gt;|Orchestrates| LikelihoodAnalysis\n    PriorAnalysis --&gt;|Reads/Writes| DB\n    LikelihoodAnalysis --&gt;|Reads/Writes| DB\n\n    Prior --&gt;|Gets Data| DB\n    Entities --&gt;|Gets Data| DB\n    Entities --&gt;|Manages| Decay\n\n    Area --&gt;|Calls| Utils\n    Utils --&gt;|Uses| Prior\n    Utils --&gt;|Uses| Entities\n    Entities --&gt;|Uses| Decay\n\n    Coord --&gt;|Updates| Sensors\n    Area --&gt;|Provides Data| Binary\n\n    DB --&gt;|Stores| Tables</code></pre>"},{"location":"technical/data-flow/#database-data-flow","title":"Database Data Flow","text":"<p>This diagram shows how data flows through the database:</p> <pre><code>flowchart LR\n    subgraph \"Data Sources\"\n        Recorder[HA Recorder]\n        Config[Configuration]\n        Analysis[Analysis Results]\n    end\n\n    subgraph \"Database Operations\"\n        Sync[Sync States]\n        Save[Save Data]\n        Load[Load Data]\n    end\n\n    subgraph \"Database Tables\"\n        Intervals[(Intervals)]\n        Entities[(Entities)]\n        Areas[(Areas)]\n        Priors[(Priors)]\n        GlobalPriors[(GlobalPriors)]\n    end\n\n    subgraph \"In-Memory Objects\"\n        EntityObjs[Entity Objects]\n        PriorObj[Prior Object]\n        AreaObj[Area Object]\n    end\n\n    Recorder --&gt;|State History| Sync\n    Sync --&gt;|Create Intervals| Intervals\n\n    Config --&gt;|Entity Config| Save\n    Save --&gt;|Store Config| Entities\n    Save --&gt;|Store State| Entities\n\n    Analysis --&gt;|Global Prior| Save\n    Analysis --&gt;|Time Priors| Save\n    Save --&gt;|Store Global| GlobalPriors\n    Save --&gt;|Store Time| Priors\n    Analysis --&gt;|Likelihoods| Save\n    Save --&gt;|Update| Entities\n\n    Load --&gt;|Read Config| Entities\n    Load --&gt;|Read Priors| GlobalPriors\n    Load --&gt;|Read Time| Priors\n    Load --&gt;|Read Likelihoods| Entities\n\n    Entities --&gt;|Create| EntityObjs\n    GlobalPriors --&gt;|Set| PriorObj\n    Priors --&gt;|Get| PriorObj\n    Entities --&gt;|Update| EntityObjs\n\n    EntityObjs --&gt;|Used By| AreaObj\n    PriorObj --&gt;|Used By| AreaObj</code></pre>"},{"location":"technical/data-flow/#decay-flow","title":"Decay Flow","text":"<p>This flowchart shows how decay is managed:</p> <pre><code>flowchart TD\n    Start([Entity State Check]) --&gt; GetEvidence[Get Current Evidence]\n    GetEvidence --&gt; Compare{Compare with Previous}\n    Compare --&gt;|Same| NoChange[No Change]\n    Compare --&gt;|Different| Transition[Transition Detected]\n\n    NoChange --&gt; End([Continue])\n\n    Transition --&gt; CheckDirection{Which Direction?}\n    CheckDirection --&gt;|False \u2192 True| Active[Evidence Active]\n    CheckDirection --&gt;|True \u2192 False| Inactive[Evidence Inactive]\n\n    Active --&gt; StopDecay[Stop Decay if Active]\n    StopDecay --&gt; UpdatePrev[Update Previous Evidence]\n    UpdatePrev --&gt; End\n\n    Inactive --&gt; StartDecay[Start Decay]\n    StartDecay --&gt; SetStart[Set Decay Start Time]\n    SetStart --&gt; UpdatePrev\n\n    UpdatePrev --&gt; CalcDecay[Calculate Decay Factor]\n    CalcDecay --&gt; Formula[decay_factor = 0.5^age/half_life]\n    Formula --&gt; CheckExpired{Decay &lt; 5%?}\n    CheckExpired --&gt;|Yes| Expire[Stop Decay]\n    CheckExpired --&gt;|No| ContinueDecay[Continue Decay]\n\n    Expire --&gt; End\n    ContinueDecay --&gt; UseDecay[Use Decay in Calculation]\n    UseDecay --&gt; Interpolate[Interpolate Likelihoods]\n    Interpolate --&gt; End</code></pre>"},{"location":"technical/data-flow/#see-also","title":"See Also","text":"<ul> <li>Complete Calculation Flow - Detailed text explanation</li> <li>Prior Calculation Deep Dive - Prior learning details</li> <li>Global Prior Flow - Complete global prior calculation flow</li> <li>Time Prior Flow - Complete time prior feature documentation</li> <li>Likelihood Calculation Deep Dive - Likelihood learning details</li> <li>Bayesian Calculation Deep Dive - Calculation details</li> <li>Entity Evidence Collection - Evidence collection details</li> </ul>"},{"location":"technical/database-schema/","title":"Database Schema Documentation","text":""},{"location":"technical/database-schema/#overview","title":"Overview","text":"<p>The Area Occupancy Detection integration uses a SQLite database to store sensor data, occupancy intervals, priors, and analytical data. The database is designed to support a single integration instance with multiple areas, enabling efficient cross-area analysis and long-term trend analysis.</p> <p>Database Version: 5 Database File: <code>area_occupancy.db</code> (stored in <code>.storage/</code> directory)</p>"},{"location":"technical/database-schema/#architecture-principles","title":"Architecture Principles","text":"<ol> <li>Single Integration, Multiple Areas: All areas share the same <code>entry_id</code>, but each area has a unique <code>area_name</code> as its primary identifier.</li> <li>Tiered Aggregation: Raw data is kept for a short period, then aggregated into daily, weekly, and monthly summaries to prevent database bloat.</li> <li>Long-term Retention: Aggregated data is retained for years to enable seasonal trend analysis.</li> <li>Cross-Area Support: Relationships between areas and shared sensors are tracked for advanced probability calculations.</li> </ol>"},{"location":"technical/database-schema/#core-tables","title":"Core Tables","text":""},{"location":"technical/database-schema/#areas","title":"<code>areas</code>","text":"<p>Stores area configuration and metadata.</p> Column Type Description <code>entry_id</code> String Integration entry ID (same for all areas) <code>area_name</code> String (PK) Unique area identifier <code>area_id</code> String Home Assistant area ID <code>purpose</code> String Area purpose (e.g., \"social\", \"work\", \"sleep\") <code>threshold</code> Float Occupancy probability threshold (0.0-1.0) <code>adjacent_areas</code> JSON Array of adjacent area names <code>created_at</code> DateTime Creation timestamp <code>updated_at</code> DateTime Last update timestamp <p>Indexes:</p> <ul> <li>Primary key on <code>area_name</code></li> <li>Index on <code>entry_id</code></li> </ul> <p>Relationships:</p> <ul> <li>One-to-many with <code>entities</code></li> <li>One-to-many with <code>priors</code></li> </ul>"},{"location":"technical/database-schema/#entities","title":"<code>entities</code>","text":"<p>Stores entity (sensor) configuration and Bayesian parameters.</p> Column Type Description <code>entry_id</code> String Integration entry ID <code>area_name</code> String (PK, FK) Area this entity belongs to <code>entity_id</code> String (PK) Home Assistant entity ID <code>entity_type</code> String Type (motion, media, appliance, etc.) <code>weight</code> Float Bayesian weight (0.0-1.0) <code>prob_given_true</code> Float P(entity active | area occupied) <code>prob_given_false</code> Float P(entity active | area unoccupied) <code>is_shared</code> Boolean Whether entity is shared across areas <code>shared_with_areas</code> JSON Array of area names this entity is shared with <code>last_updated</code> DateTime Last update timestamp <code>created_at</code> DateTime Creation timestamp <code>is_decaying</code> Boolean Whether probability is currently decaying <code>decay_start</code> DateTime When decay started <code>evidence</code> Boolean Current evidence state <p>Indexes:</p> <ul> <li>Composite primary key on <code>(area_name, entity_id)</code></li> <li>Indexes on <code>entry_id</code>, <code>area_name</code>, <code>entity_type</code>, <code>is_shared</code></li> <li>Composite index on <code>(entry_id, area_name, entity_type)</code></li> </ul> <p>Relationships:</p> <ul> <li>Many-to-one with <code>areas</code></li> <li>One-to-many with <code>intervals</code></li> </ul>"},{"location":"technical/database-schema/#intervals","title":"<code>intervals</code>","text":"<p>Stores state change intervals for all sensors.</p> Column Type Description <code>id</code> Integer (PK) Auto-increment primary key <code>entry_id</code> String Integration entry ID <code>area_name</code> String Area this interval belongs to <code>entity_id</code> String (FK) Entity ID <code>state</code> String Sensor state (e.g., \"on\", \"off\") <code>start_time</code> DateTime Interval start time <code>end_time</code> DateTime Interval end time <code>duration_seconds</code> Float Interval duration <code>aggregation_level</code> String Aggregation level: \"raw\", \"daily\", \"weekly\", \"monthly\" <code>created_at</code> DateTime Creation timestamp <p>Indexes:</p> <ul> <li>Primary key on <code>id</code></li> <li>Unique constraint on <code>(entity_id, start_time, end_time, aggregation_level)</code></li> <li>Indexes on <code>entry_id</code>, <code>area_name</code>, <code>entity_id</code>, <code>start_time</code>, <code>end_time</code>, <code>aggregation_level</code></li> <li>Composite indexes for common query patterns</li> </ul> <p>Relationships:</p> <ul> <li>Many-to-one with <code>entities</code></li> </ul> <p>Retention Policy:</p> <ul> <li>Raw intervals: 60 days</li> <li>Daily aggregates: 90 days</li> <li>Weekly aggregates: 365 days</li> <li>Monthly aggregates: 5 years</li> </ul>"},{"location":"technical/database-schema/#priors","title":"<code>priors</code>","text":"<p>Stores time-slot priors (day of week \u00d7 time slot). These are calculated from historical motion sensor data during the analysis cycle and provide time-of-day and day-of-week specific occupancy probabilities.</p> <p>Purpose: Provides time-of-day and day-of-week specific occupancy probabilities. Each area has 168 time slots (7 days \u00d7 24 hours), allowing the system to learn patterns like \"living room is usually occupied on weekdays at 7 PM\" or \"bedroom is rarely occupied on weekdays at 2 PM\".</p> Column Type Description <code>entry_id</code> String Integration entry ID (same for all priors in the integration) <code>area_name</code> String (PK, FK) Area name (foreign key to <code>areas.area_name</code>) <code>day_of_week</code> Integer (PK) Day of week (0=Monday, 1=Tuesday, ..., 6=Sunday) <code>time_slot</code> Integer (PK) Time slot index (0=00:00-01:00, 1=01:00-02:00, ..., 23=23:00-24:00) <code>prior_value</code> Float Prior probability for this slot (0.0-1.0), clamped to [0.1, 0.9] at runtime <code>data_points</code> Integer Number of data points (weeks) used in calculation <code>confidence</code> Float Confidence in the calculation (0.0-1.0, nullable) <code>last_calculation_date</code> DateTime When prior was last calculated (nullable) <code>sample_period_start</code> DateTime Start of data period used for calculation (nullable) <code>sample_period_end</code> DateTime End of data period used for calculation (nullable) <code>calculation_method</code> String Method used (e.g., \"interval_analysis\", nullable) <code>last_updated</code> DateTime Last update timestamp <p>Primary Key: Composite of <code>(area_name, day_of_week, time_slot)</code></p> <ul> <li>Ensures one prior value per area per time slot</li> <li>Allows efficient lookup by area and time slot</li> </ul> <p>Indexes:</p> <ul> <li><code>idx_priors_entry</code> on <code>entry_id</code>: Fast filtering by integration entry</li> <li><code>idx_priors_area</code> on <code>area_name</code>: Fast filtering by area</li> <li><code>idx_priors_entry_area</code> on <code>(entry_id, area_name)</code>: Composite index for area-based queries</li> <li><code>idx_priors_day_slot</code> on <code>(day_of_week, time_slot)</code>: Fast lookup by time slot pattern</li> <li><code>idx_priors_last_updated</code> on <code>last_updated</code>: For tracking when priors were last recalculated</li> </ul> <p>Relationships:</p> <ul> <li>Many-to-one with <code>areas</code> table via <code>area_name</code> foreign key</li> </ul> <p>Data Model:</p> <ul> <li>Each area has 168 records (7 days \u00d7 24 hours)</li> <li>Records are created/updated during analysis cycles</li> <li>Missing records default to 0.5 (neutral prior) at runtime</li> </ul> <p>Retrieval:</p> <ul> <li>Queried via <code>queries.py:get_time_prior()</code> function</li> <li>Filtered by <code>entry_id</code>, <code>area_name</code>, <code>day_of_week</code>, <code>time_slot</code></li> <li>Returns <code>prior_value</code> or default (0.5) if not found</li> <li>Values are clamped to [0.1, 0.9] range at retrieval time</li> </ul> <p>Current Status:</p> <ul> <li>Schema exists and is fully defined</li> <li>Retrieval mechanism is implemented</li> <li>Calculation and storage logic is fully implemented</li> <li>Time priors are calculated during the analysis cycle and stored automatically</li> <li>See Time Prior Flow for complete implementation details</li> </ul>"},{"location":"technical/database-schema/#new-tables-for-advanced-features","title":"New Tables for Advanced Features","text":""},{"location":"technical/database-schema/#interval_aggregates","title":"<code>interval_aggregates</code>","text":"<p>Stores aggregated interval statistics for efficient querying.</p> Column Type Description <code>id</code> Integer (PK) Auto-increment primary key <code>entry_id</code> String Integration entry ID <code>area_name</code> String Area name <code>entity_id</code> String (FK) Entity ID <code>aggregation_period</code> String Period: \"daily\", \"weekly\", \"monthly\", \"yearly\" <code>period_start</code> DateTime Period start time <code>period_end</code> DateTime Period end time <code>state</code> String Sensor state <code>interval_count</code> Integer Number of intervals in period <code>total_duration_seconds</code> Float Total duration of all intervals <code>min_duration_seconds</code> Float Minimum interval duration <code>max_duration_seconds</code> Float Maximum interval duration <code>avg_duration_seconds</code> Float Average interval duration <code>first_occurrence</code> DateTime First interval start in period <code>last_occurrence</code> DateTime Last interval end in period <code>created_at</code> DateTime Creation timestamp <p>Indexes:</p> <ul> <li>Unique constraint on <code>(entity_id, aggregation_period, period_start, state)</code></li> <li>Composite indexes for area-based and entity-based queries</li> </ul> <p>Purpose: Enables fast queries for prior calculations and trend analysis without scanning raw intervals.</p>"},{"location":"technical/database-schema/#occupied_intervals_cache","title":"<code>occupied_intervals_cache</code>","text":"<p>Stores precomputed occupied intervals for fast prior calculations.</p> Column Type Description <code>id</code> Integer (PK) Auto-increment primary key <code>entry_id</code> String Integration entry ID <code>area_name</code> String Area name <code>start_time</code> DateTime Interval start time <code>end_time</code> DateTime Interval end time <code>duration_seconds</code> Float Interval duration <code>calculation_date</code> DateTime When interval was calculated <code>data_source</code> String Source: \"motion_sensors\", \"merged\" <code>created_at</code> DateTime Creation timestamp <p>Indexes:</p> <ul> <li>Unique constraint on <code>(area_name, start_time, end_time)</code></li> <li>Composite indexes for time-range queries</li> </ul> <p>Purpose: Precomputed occupied intervals eliminate the need to recalculate from raw sensor data for each prior calculation.</p>"},{"location":"technical/database-schema/#global_priors","title":"<code>global_priors</code>","text":"<p>Stores global prior values with calculation metadata and history. This is the only source of truth for global priors - the <code>areas</code> table no longer contains an <code>area_prior</code> field.</p> <p>Purpose: Stores the global prior for each area with full history and metadata. The global prior represents the overall occupancy probability for an area, calculated from historical motion sensor data. It serves as the baseline for Bayesian probability calculations.</p> <p>Calculation Method: The global prior is calculated as the ratio of total occupied time to total period duration:</p> <pre><code>global_prior = total_occupied_seconds / total_period_seconds\n</code></pre> <p>The period is determined from actual data availability (first interval start to last interval end or current time), not a fixed lookback window. Values are clamped to the range <code>[0.01, 0.99]</code> to prevent extreme values.</p> <p>Relationship to Time Priors: The global prior is combined with time priors (stored in <code>priors</code> table) to create a more accurate baseline probability. See Global Prior Flow for complete details.</p> Column Type Description <code>id</code> Integer (PK) Auto-increment primary key <code>entry_id</code> String Integration entry ID <code>area_name</code> String (Unique) Area name <code>prior_value</code> Float Global prior probability (0.01-0.99) <code>calculation_date</code> DateTime When prior was calculated <code>data_period_start</code> DateTime Start of data period used <code>data_period_end</code> DateTime End of data period used <code>total_occupied_seconds</code> Float Total occupied time in period <code>total_period_seconds</code> Float Total period duration <code>interval_count</code> Integer Number of intervals used <code>confidence</code> Float Confidence in calculation (0.0-1.0) <code>calculation_method</code> String Method used (default: \"interval_analysis\") <code>underlying_data_hash</code> String Hash of underlying data (for validation) <code>created_at</code> DateTime Creation timestamp <code>updated_at</code> DateTime Last update timestamp <p>Indexes:</p> <ul> <li>Unique constraint on <code>area_name</code> (ensures one global prior per area)</li> <li>Index on <code>calculation_date</code> (for history tracking and pruning)</li> </ul> <p>Retrieval:</p> <ul> <li>Queried via <code>queries.py:get_global_prior()</code> function</li> <li>Filtered by <code>area_name</code></li> <li>Returns dictionary with prior metadata, or <code>None</code> if not found</li> <li>Loaded during <code>load_data()</code> operation on integration startup</li> </ul> <p>Storage:</p> <ul> <li>Saved via <code>operations.py:save_global_prior()</code> function</li> <li>Called after global prior calculation in <code>PriorAnalyzer.calculate_and_update_prior()</code></li> <li>Updates existing record or creates new one</li> <li>Prunes old history (keeps last 15 calculations per area)</li> </ul> <p>Retention: Last 15 calculations per area are retained. Older calculations are automatically pruned when new ones are saved.</p> <p>See Also:</p> <ul> <li>Global Prior Flow - Complete calculation and data flow documentation</li> <li>Time Prior Flow - Time-of-day specific priors</li> </ul>"},{"location":"technical/database-schema/#numeric_samples","title":"<code>numeric_samples</code>","text":"<p>Stores raw numeric sensor samples for correlation analysis.</p> Column Type Description <code>id</code> Integer (PK) Auto-increment primary key <code>entry_id</code> String Integration entry ID <code>area_name</code> String Area name <code>entity_id</code> String (FK) Entity ID <code>timestamp</code> DateTime Sample timestamp <code>value</code> Float Numeric value <code>unit_of_measurement</code> String Unit (e.g., \"\u00b0C\", \"%\") <code>state</code> String Associated state (if any) <code>created_at</code> DateTime Creation timestamp <p>Indexes:</p> <ul> <li>Unique constraint on <code>(entity_id, timestamp)</code></li> <li>Composite indexes for time-range queries</li> </ul> <p>Retention: 14 days of raw samples.</p> <p>Purpose: Raw samples are used to calculate correlations with occupancy and then aggregated.</p>"},{"location":"technical/database-schema/#numeric_aggregates","title":"<code>numeric_aggregates</code>","text":"<p>Stores aggregated numeric sensor data for trend analysis.</p> Column Type Description <code>id</code> Integer (PK) Auto-increment primary key <code>entry_id</code> String Integration entry ID <code>area_name</code> String Area name <code>entity_id</code> String (FK) Entity ID <code>aggregation_period</code> String Period: \"hourly\", \"daily\", \"weekly\", \"monthly\", \"yearly\" <code>period_start</code> DateTime Period start time <code>period_end</code> DateTime Period end time <code>min_value</code> Float Minimum value in period <code>max_value</code> Float Maximum value in period <code>avg_value</code> Float Average value in period <code>median_value</code> Float Median value in period <code>sample_count</code> Integer Number of samples in period <code>first_value</code> Float First value in period <code>last_value</code> Float Last value in period <code>std_deviation</code> Float Standard deviation <code>created_at</code> DateTime Creation timestamp <p>Indexes:</p> <ul> <li>Unique constraint on <code>(entity_id, aggregation_period, period_start)</code></li> <li>Composite indexes for area-based and entity-based queries</li> </ul> <p>Retention:</p> <ul> <li>Hourly aggregates: 30 days</li> <li>Weekly aggregates: 3 years (for seasonal analysis)</li> </ul> <p>Purpose: Enables trend analysis across seasons (e.g., temperature differences between winter and summer).</p>"},{"location":"technical/database-schema/#correlations","title":"<code>correlations</code>","text":"<p>Stores calculated correlations between numeric sensor values and occupancy, as well as binary likelihood analysis results for binary sensors.</p> Column Type Description <code>id</code> Integer (PK) Auto-increment primary key <code>entry_id</code> String Integration entry ID <code>area_name</code> String Area name <code>entity_id</code> String (FK) Entity ID <code>input_type</code> String Input type identifier. Numeric types: \"temperature\", \"humidity\", \"illuminance\", \"co2\", \"sound_pressure\", \"pressure\" (atmospheric), \"air_quality\", \"voc\", \"pm25\", \"pm10\", \"power\", \"environmental\". Binary types: \"motion\", \"media\", \"appliance\", \"door\", \"window\". Other: \"unknown\". Binary types are flagged with <code>correlation_type=\"binary_likelihood\"</code> and use interval-overlap analysis instead of Pearson correlation. <code>correlation_coefficient</code> Float Pearson correlation (-1.0 to 1.0). <code>None</code> for binary sensors <code>correlation_type</code> String Type: \"strong_positive\", \"strong_negative\", \"none\", or \"binary_likelihood\" <code>analysis_period_start</code> DateTime Start of analysis period <code>analysis_period_end</code> DateTime End of analysis period <code>sample_count</code> Integer Number of samples used <code>confidence</code> Float Confidence in correlation (0.0-1.0). <code>None</code> for binary sensors <code>mean_value_when_occupied</code> Float For numeric sensors: mean value when occupied. For binary sensors: <code>prob_given_true</code> <code>mean_value_when_unoccupied</code> Float For numeric sensors: mean value when unoccupied. For binary sensors: <code>prob_given_false</code> <code>std_dev_when_occupied</code> Float Standard deviation when occupied. <code>None</code> for binary sensors <code>std_dev_when_unoccupied</code> Float Standard deviation when unoccupied. <code>None</code> for binary sensors <code>threshold_active</code> Float Threshold for active state. <code>None</code> for binary sensors <code>threshold_inactive</code> Float Threshold for inactive state. <code>None</code> for binary sensors <code>analysis_error</code> String Reason why analysis failed (e.g., \"no_correlation\", \"too_few_samples\", \"no_occupied_intervals\") or <code>None</code> if successful. Applies to both numeric correlations and binary likelihoods <code>calculation_date</code> DateTime When correlation was calculated <code>created_at</code> DateTime Creation timestamp <code>updated_at</code> DateTime Last update timestamp <p>Binary Likelihood Calculation Methodology:</p> <p>For binary sensors (identified by <code>correlation_type=\"binary_likelihood\"</code>), the <code>mean_value_when_occupied</code> and <code>mean_value_when_unoccupied</code> columns store probability values calculated using an interval-overlap method. This method measures the proportion of time a sensor is active during occupied and unoccupied periods.</p> <p>Calculation Method:</p> <p>The binary likelihood calculation uses interval overlap to determine:</p> <ul> <li><code>mean_value_when_occupied</code>: Probability that the sensor is active given the area is occupied</li> <li><code>mean_value_when_unoccupied</code>: Probability that the sensor is active given the area is unoccupied</li> </ul> <p>Formulas:</p> <pre><code>mean_value_when_occupied = time_active_during_occupied / total_occupied_time\nmean_value_when_unoccupied = time_active_during_unoccupied / total_unoccupied_time\n</code></pre> <p>Interval-Overlap Algorithm:</p> <ol> <li> <p>For each active interval of the binary sensor (where the sensor state matches one of its <code>active_states</code>):</p> </li> <li> <p>Calculate the overlap duration with all occupied intervals</p> </li> <li> <p>Calculate the overlap duration with unoccupied periods (remainder of the interval after occupied overlap)</p> </li> <li> <p>Accumulate durations:</p> </li> <li> <p><code>time_active_during_occupied</code>: Sum of all overlap durations between active sensor intervals and occupied intervals</p> </li> <li><code>time_active_during_unoccupied</code>: Sum of all overlap durations between active sensor intervals and unoccupied periods</li> <li><code>total_occupied_time</code>: Total duration of all occupied intervals in the analysis period</li> <li> <p><code>total_unoccupied_time</code>: Total duration of all unoccupied periods in the analysis period</p> </li> <li> <p>Calculate probabilities by dividing accumulated active durations by total occupied/unoccupied time</p> </li> <li> <p>Clamp probabilities to the range [0.05, 0.95] to avoid extreme \"black hole\" values that could skew Bayesian calculations</p> </li> </ol> <p>Supported Binary Sensor Types:</p> <p>Binary likelihood analysis is performed for sensors with binary states, including:</p> <ul> <li>Motion sensors (<code>input_type=\"motion\"</code>): Detects movement in the area</li> <li>Door/window sensors (<code>input_type=\"door\"</code>, <code>input_type=\"window\"</code>): Detects door or window open/closed states</li> <li>Occupancy sensors (<code>input_type=\"occupancy\"</code>): Binary occupancy detection devices</li> <li>Media devices (<code>input_type=\"media\"</code>): Media players with active/inactive states (playing, paused, standby)</li> <li>Appliances (<code>input_type=\"appliance\"</code>): Binary appliance on/off states</li> <li>Other binary sensors with defined <code>active_states</code> (e.g., <code>[\"on\"]</code>, <code>[\"playing\"]</code>, <code>[\"open\"]</code>)</li> </ul> <p>Indexes:</p> <ul> <li>Unique constraint on <code>(area_name, entity_id, analysis_period_start)</code></li> <li>Composite indexes for querying by correlation type and confidence</li> </ul> <p>Retention: Last 24 months (one per month). Correlations are pruned monthly, keeping one record per month for the last 24 months.</p> <p>Purpose:</p> <ul> <li>Numeric Sensors: Identifies which numeric sensors (temperature, humidity, illuminance, CO2, sound pressure, atmospheric pressure, air quality, VOC, PM2.5, PM10, power, etc.) correlate with occupancy, enabling them to be used as occupancy indicators.</li> <li>Binary Sensors: Stores duration-based probability analysis results (<code>prob_given_true</code> and <code>prob_given_false</code>) calculated from interval overlaps with occupied/unoccupied periods.</li> </ul> <p>Note: Both numeric correlation results and binary likelihood results are stored in this table, distinguished by the <code>correlation_type</code> field. Binary sensors use <code>correlation_type=\"binary_likelihood\"</code> and store their probabilities in the <code>mean_value_when_occupied</code> and <code>mean_value_when_unoccupied</code> fields.</p>"},{"location":"technical/database-schema/#entity_statistics","title":"<code>entity_statistics</code>","text":"<p>Stores per-entity operational and Bayesian statistics.</p> Column Type Description <code>id</code> Integer (PK) Auto-increment primary key <code>entry_id</code> String Integration entry ID <code>area_name</code> String Area name <code>entity_id</code> String (FK) Entity ID <code>statistic_type</code> String Type: \"operational\" or \"bayesian\" <code>statistic_name</code> String Name (e.g., \"total_activations\", \"prob_given_true\") <code>statistic_value</code> Float Statistic value <code>period_start</code> DateTime Period start time <code>period_end</code> DateTime Period end time <code>updated_at</code> DateTime Last update timestamp <p>Indexes:</p> <ul> <li>Unique constraint on <code>(entity_id, statistic_type, statistic_name, period_start)</code></li> <li>Composite indexes for area-based and entity-based queries</li> </ul> <p>Purpose: Tracks operational statistics (counts, durations, frequencies) and Bayesian parameters (probabilities, weights) over time.</p>"},{"location":"technical/database-schema/#area_relationships","title":"<code>area_relationships</code>","text":"<p>Defines and tracks relationships between areas.</p> Column Type Description <code>id</code> Integer (PK) Auto-increment primary key <code>entry_id</code> String Integration entry ID <code>area_name</code> String Source area name <code>related_area_name</code> String Related/adjacent area name <code>relationship_type</code> String Type: \"adjacent\", \"shared_wall\", \"shared_entrance\", etc. <code>influence_weight</code> Float Influence weight (0.0-1.0) <code>distance</code> Float Physical distance (if applicable) <code>created_at</code> DateTime Creation timestamp <code>updated_at</code> DateTime Last update timestamp <p>Indexes:</p> <ul> <li>Unique constraint on <code>(area_name, related_area_name)</code></li> <li>Indexes for bidirectional queries</li> </ul> <p>Purpose: Tracks which areas are adjacent or related, enabling cross-area probability adjustments. The <code>influence_weight</code> determines how much one area's occupancy affects another's probability.</p>"},{"location":"technical/database-schema/#cross_area_stats","title":"<code>cross_area_stats</code>","text":"<p>Stores aggregated statistics that span multiple areas.</p> Column Type Description <code>id</code> Integer (PK) Auto-increment primary key <code>entry_id</code> String Integration entry ID <code>statistic_type</code> String Type (e.g., \"combined_occupancy\", \"shared_sensor_active\") <code>statistic_name</code> String Statistic name <code>involved_areas</code> JSON Array of area names involved <code>aggregation_period</code> String Period: \"hourly\", \"daily\", \"weekly\", \"monthly\" <code>period_start</code> DateTime Period start time <code>period_end</code> DateTime Period end time <code>statistic_value</code> Float Statistic value <code>extra_metadata</code> JSON Additional metadata <code>created_at</code> DateTime Creation timestamp <p>Indexes:</p> <ul> <li>Unique constraint on <code>(statistic_type, statistic_name, aggregation_period, period_start)</code></li> <li>Composite indexes for type and period queries</li> </ul> <p>Purpose: Enables analysis of patterns across multiple areas, such as combined occupancy or shared sensor activity.</p>"},{"location":"technical/database-schema/#metadata","title":"<code>metadata</code>","text":"<p>Stores database metadata (version, last prune time, etc.).</p> Column Type Description <code>key</code> String (PK) Metadata key <code>value</code> String Metadata value <p>Common Keys:</p> <ul> <li><code>db_version</code>: Database schema version</li> <li><code>last_prune_time</code>: Timestamp of last interval prune operation</li> </ul>"},{"location":"technical/database-schema/#data-flow","title":"Data Flow","text":""},{"location":"technical/database-schema/#interval-processing","title":"Interval Processing","text":"<ol> <li>Raw Intervals: State changes from Home Assistant recorder are converted to intervals and stored in <code>intervals</code> table with <code>aggregation_level=\"raw\"</code>.</li> <li>Aggregation: Periodically, raw intervals are aggregated:</li> <li>Raw \u2192 Daily: After 60 days</li> <li>Daily \u2192 Weekly: After 90 days</li> <li>Weekly \u2192 Monthly: After 365 days</li> <li>Monthly aggregates are retained indefinitely</li> <li>Occupied Intervals Cache: Raw intervals are processed to create precomputed occupied intervals stored in <code>occupied_intervals_cache</code>.</li> </ol>"},{"location":"technical/database-schema/#prior-calculation","title":"Prior Calculation","text":"<ol> <li>Time-Slot Priors: Calculated from <code>occupied_intervals_cache</code> and stored in <code>priors</code> table.</li> <li>Global Priors: Calculated from total occupied time and stored in <code>global_priors</code> table with full metadata.</li> </ol>"},{"location":"technical/database-schema/#correlation-analysis","title":"Correlation Analysis","text":"<ol> <li>Numeric Samples: Raw numeric sensor values are stored in <code>numeric_samples</code>.</li> <li>Aggregation: Samples are aggregated into <code>numeric_aggregates</code> for trend analysis.</li> <li>Correlation: Samples are correlated with occupancy intervals to calculate correlations stored in <code>correlations</code>.</li> </ol>"},{"location":"technical/database-schema/#retention-policies","title":"Retention Policies","text":"Data Type Retention Period Aggregation Raw intervals 60 days None Raw numeric samples 14 days None Daily interval aggregates 90 days From raw Weekly interval aggregates 365 days From daily Monthly interval aggregates 5 years From weekly Hourly numeric aggregates 30 days From raw samples Weekly numeric aggregates 3 years From hourly Global priors Last 15 calculations N/A Numeric correlations Last 24 months (one per month) N/A"},{"location":"technical/database-schema/#indexes-and-performance","title":"Indexes and Performance","text":"<p>The database uses extensive indexing to optimize common query patterns:</p> <ul> <li>Time-range queries: Indexes on <code>start_time</code>, <code>end_time</code>, <code>timestamp</code></li> <li>Area-based queries: Indexes on <code>area_name</code> in all relevant tables</li> <li>Entity-based queries: Indexes on <code>entity_id</code> in all relevant tables</li> <li>Composite indexes: Optimize multi-column queries (e.g., area + time range)</li> </ul>"},{"location":"technical/database-schema/#migration-strategy","title":"Migration Strategy","text":"<p>When the database schema version changes:</p> <ol> <li>Database version is checked on startup</li> <li>If version mismatch detected, database is deleted and recreated with new schema</li> <li>All previous data is cleared (no migration scripts for major version changes)</li> </ol> <p>This approach is used for DB_VERSION 5+ due to the fundamental architectural change from multiple integrations to a single integration with multiple areas.</p>"},{"location":"technical/debug/","title":"Debugging","text":"<p>Below are the instructions for debugging the integration.</p> <ol> <li> <p>Enable debug logging</p> <ul> <li>Add the following to the <code>configuration.yaml</code> file <pre><code>logger:\n  logs:\n    custom_components.area_occupancy: DEBUG\n</code></pre></li> <li>Restart Home Assistant</li> </ul> </li> <li> <p>Perform the action you want to debug</p> <ul> <li>For example, if you want to debug the occupancy sensor, you can trigger a motion sensor to change the occupancy state</li> </ul> </li> <li>Check the logs in Home Assistant<ul> <li>Go to Settings</li> <li>Click on \"System\"</li> <li>Click on \"Logs\"</li> <li>Look for the integration name (e.g. <code>area_occupancy or Area Occupancy Detection</code>)</li> <li>Look for the debug messages, there may be warnings or errors. Warnings are not a problem, but errors are. </li> <li>If there are errors, please open an issue on the GitHub repository</li> <li>Open the error in the logs and copy the error message </li> </ul> </li> </ol>"},{"location":"technical/deep-dive/","title":"Area Occupancy Probability Calculation Explained","text":"<p>This document gives a high level overview of how the <code>area_occupancy</code> integration calculates occupancy probability and manages learned data.</p>"},{"location":"technical/deep-dive/#core-concepts","title":"Core Concepts","text":"<ul> <li>Occupancy Probability: Final output value (0.0\u20131.0) indicating the likelihood that the area is currently occupied.</li> <li>Priors: Historical probabilities learned from motion sensors and other configured entities.</li> <li>Likelihoods: For each entity, probabilities <code>P(Active | Occupied)</code> and <code>P(Active | Not Occupied)</code> learned from history.</li> <li>Weights: User-configured values (0.0\u20131.0) assigned per sensor type to influence their contribution.</li> <li>Decay: Exponential reduction in probability when no fresh evidence is present.</li> <li>Threshold: Probability level at which the binary occupancy sensor turns <code>on</code>.</li> </ul>"},{"location":"technical/deep-dive/#complete-calculation-process","title":"Complete Calculation Process","text":"<p>The area occupancy calculation operates in two main phases:</p> <ol> <li>Initialization &amp; Learning Phase: Sets up the system, loads historical data, and learns prior probabilities and likelihoods from sensor history</li> <li>Real-Time Calculation Phase: Continuously monitors sensor states and calculates current occupancy probability using Bayesian inference</li> </ol> <p>For a complete end-to-end explanation of the calculation process, see Complete Calculation Flow.</p>"},{"location":"technical/deep-dive/#data-flow-and-components","title":"Data Flow and Components","text":"<p>The system consists of several conceptual components:</p> <ul> <li>Coordinator: Central orchestrator that tracks entity states, schedules updates, handles decay and stores configuration.</li> <li>Entity Manager: Creates and maintains entity objects with evidence, likelihoods and decay data.</li> <li>Prior Manager: Handles learning priors and likelihoods from historical recorder data and exposes time-based priors.</li> <li>Bayesian Calculator: Performs log-space probability calculations combining evidence with priors.</li> <li>Database: Stores historical state intervals used for learning.</li> <li>Services: Exposes services such as <code>run_analysis</code> for manual analysis triggers.</li> </ul> <p>For visual representations of data flow, see Data Flow Diagrams.</p>"},{"location":"technical/deep-dive/#processing-steps","title":"Processing Steps","text":"<ol> <li>Initialization: System loads configuration, sets up entities and loads any stored priors from the database.</li> <li>State Updates: When a monitored entity changes state, the system updates the corresponding entity object and triggers a probability recalculation.</li> <li>Probability Calculation: Bayesian probability calculation combines entity evidence with the area and time priors in log space, applying the configured weights.</li> <li>Decay Handling: If probability decreases, entity decay gradually reduces their influence until new evidence appears.</li> <li>Learning Priors: Periodically or via <code>run_analysis</code> service, the system analyses recorder history to update priors and likelihoods which are stored in the database.</li> <li>Outputs: The system updates Home Assistant entities (probability, status, priors, evidence, decay, threshold) with the latest values.</li> </ol> <p>This architecture allows the integration to react quickly to new sensor data while continuously refining its understanding of each entity's reliability over time.</p>"},{"location":"technical/deep-dive/#detailed-documentation","title":"Detailed Documentation","text":"<p>For in-depth explanations of specific aspects of the calculation:</p>"},{"location":"technical/deep-dive/#core-calculation-process","title":"Core Calculation Process","text":"<ul> <li>Complete Calculation Flow - End-to-end process from initialization through real-time updates</li> <li>Bayesian Calculation Deep Dive - Detailed mathematical explanation of the Bayesian probability calculation</li> <li>Calculation Feature Documentation - User-facing documentation with examples</li> </ul>"},{"location":"technical/deep-dive/#learning-processes","title":"Learning Processes","text":"<ul> <li>Prior Calculation Deep Dive - How global and time-based priors are calculated from historical data</li> <li>Likelihood Calculation Deep Dive - How sensor reliability likelihoods are learned</li> <li>Prior Learning Feature - User-facing prior learning documentation</li> <li>Likelihood Feature - User-facing likelihood documentation</li> </ul>"},{"location":"technical/deep-dive/#evidence-and-state-management","title":"Evidence and State Management","text":"<ul> <li>Entity Evidence Collection - How evidence is collected from sensors and integrated with decay</li> <li>Decay Feature - User-facing decay documentation</li> </ul>"},{"location":"technical/deep-dive/#visual-guides","title":"Visual Guides","text":"<ul> <li>Data Flow Diagrams - Visual flow diagrams using Mermaid syntax showing initialization, learning, real-time updates, and component interactions</li> </ul>"},{"location":"technical/deep-dive/#key-operations","title":"Key Operations","text":""},{"location":"technical/deep-dive/#initialization","title":"Initialization","text":"<ul> <li>Coordinator Setup: Initializes all areas and loads configuration</li> <li>Area Initialization: Sets up area components (config, entities, priors, purpose)</li> <li>Prior Learning Orchestration: Coordinates the analysis of historical data to learn priors</li> </ul>"},{"location":"technical/deep-dive/#real-time-calculation","title":"Real-Time Calculation","text":"<ul> <li>Entity State Change Detection: Monitors sensor state changes and triggers recalculation</li> <li>Evidence Transition Detection: Identifies when entities transition between active and inactive states</li> <li>Probability Calculation: Core Bayesian calculation combining evidence with priors</li> <li>Prior Combination: Combines global and time-based priors in logit space</li> </ul>"},{"location":"technical/deep-dive/#prior-calculation","title":"Prior Calculation","text":"<ul> <li>Global Prior Calculation: Analyses historical data to determine overall occupancy rate</li> <li>Time-Based Prior Calculation: Calculates occupancy probability for each day-of-week and time-slot combination</li> <li>Prior Retrieval and Combination: Retrieves and combines priors for real-time calculations</li> </ul>"},{"location":"technical/deep-dive/#likelihood-calculation","title":"Likelihood Calculation","text":"<ul> <li>Correlation Analysis: Unified correlation analysis for all sensors (numeric and binary)</li> <li>Dynamic Likelihood Calculation: Calculates likelihoods at runtime based on current sensor state</li> </ul>"},{"location":"technical/deep-dive/#decay","title":"Decay","text":"<ul> <li>Decay Factor Calculation: Calculates exponential decay factor based on time since evidence became inactive</li> <li>Entity Decay Integration: Integrates decay factor with entity evidence for probability calculation</li> </ul>"},{"location":"technical/entity-evidence/","title":"Entity Evidence Collection","text":"<p>This document explains how the system collects and processes evidence from sensor entities for occupancy calculation.</p>"},{"location":"technical/entity-evidence/#overview","title":"Overview","text":"<p>Evidence collection is the process of determining whether each configured sensor entity currently provides evidence of occupancy. The system tracks entity states, determines activity, and integrates decay to provide a complete picture of current evidence.</p>"},{"location":"technical/entity-evidence/#entity-state-tracking","title":"Entity State Tracking","text":"<p>Each entity tracks its current state and evidence.</p>"},{"location":"technical/entity-evidence/#state-retrieval","title":"State Retrieval","text":"<p>Entities retrieve their current state from Home Assistant.</p> <p>The state retrieval process: 1. Gets state from Home Assistant's state registry (<code>hass.states.get(entity_id)</code>) 2. Handles unavailable states: Returns <code>None</code> for <code>\"unknown\"</code>, <code>\"unavailable\"</code>, <code>None</code>, <code>\"\"</code>, or <code>\"NaN\"</code> 3. Returns the state value (string, float, or bool depending on entity type)</p>"},{"location":"technical/entity-evidence/#evidence-determination","title":"Evidence Determination","text":"<p>The system determines if an entity's current state indicates activity.</p> <p>Process: 1. Check Availability: If state is <code>None</code> (unavailable), returns <code>None</code> 2. Binary Sensors: Checks if state is in <code>active_states</code> list    - Returns <code>True</code> if state matches an active state    - Returns <code>False</code> if state doesn't match 3. Numeric Sensors: Checks if state value is in <code>active_range</code>    - Converts state to float    - Returns <code>True</code> if <code>min_val &lt;= state &lt;= max_val</code>    - Returns <code>False</code> otherwise 4. Default: Returns <code>None</code> if no active criteria are defined</p>"},{"location":"technical/entity-evidence/#active-state-calculation","title":"Active State Calculation","text":"<p>The active state combines current evidence with decay state:</p> \\[ active = evidence \\lor decay\\_is\\_active \\] <p>This means an entity is considered \"active\" if: - It currently has evidence (<code>evidence == True</code>), OR - It is decaying (was recently active but is now inactive)</p>"},{"location":"technical/entity-evidence/#decay-integration","title":"Decay Integration","text":"<p>Decay allows entities to continue providing evidence for a period after they become inactive, preventing rapid flickering of occupancy status.</p>"},{"location":"technical/entity-evidence/#decay-startstop-triggers","title":"Decay Start/Stop Triggers","text":"<p>Decay is managed automatically based on evidence transitions.</p> <p>The system detects evidence transitions: 1. Gets current evidence from state 2. Compares with previous evidence 3. Detects transitions:    - FALSE \u2192 TRUE: Stops decay (if active), evidence is now present    - TRUE \u2192 FALSE: Starts decay, evidence was lost 4. Updates previous evidence state for next comparison 5. Triggers recalculation if transition occurred</p>"},{"location":"technical/entity-evidence/#decay-factor-calculation","title":"Decay Factor Calculation","text":"<p>The decay factor represents how \"fresh\" the evidence is, ranging from 1.0 (fresh) to 0.0 (expired).</p> <p>The decay factor is calculated using exponential decay: <pre><code>age = current_time - decay_start_time\ndecay_factor = 0.5^(age / half_life)\n</code></pre></p> <p>The decay factor: - Starts at 1.0 when decay begins - Decreases exponentially over time - Stops automatically when it drops below 0.05 (5%, practical zero)</p> <p>The entity's decay factor returns 1.0 if evidence is currently <code>True</code>, preventing decay from being applied when the entity is actively providing evidence.</p>"},{"location":"technical/entity-evidence/#effective-evidence-calculation","title":"Effective Evidence Calculation","text":"<p>During probability calculation, the system determines \"effective evidence\" - whether the entity should be treated as providing evidence:</p> \\[ effective\\_evidence = current\\_evidence \\lor decay\\_is\\_active \\] <p>Where: - <code>current_evidence</code> is the current evidence state (True/False/None) - <code>decay_is_active</code> is whether the entity's decay is currently active</p> <p>This means an entity provides effective evidence if: - It currently has evidence, OR - It is decaying</p>"},{"location":"technical/entity-evidence/#entity-filtering","title":"Entity Filtering","text":"<p>Before entities are used in probability calculation, they are filtered to exclude invalid or non-contributing entities.</p>"},{"location":"technical/entity-evidence/#zero-weight-exclusion","title":"Zero Weight Exclusion","text":"<p>Entities with zero weight are excluded from the calculation. Entities with <code>weight == 0.0</code> contribute nothing to the calculation, so they are filtered out early.</p>"},{"location":"technical/entity-evidence/#invalid-likelihood-exclusion","title":"Invalid Likelihood Exclusion","text":"<p>Entities with invalid likelihoods are excluded. Invalid likelihoods are: - <code>prob_given_true &lt;= 0.0</code> or <code>&gt;= 1.0</code> - <code>prob_given_false &lt;= 0.0</code> or <code>&gt;= 1.0</code></p> <p>These would cause <code>log(0)</code> or <code>log(1)</code> errors in log-space calculations, so they are excluded.</p>"},{"location":"technical/entity-evidence/#unavailable-entity-handling","title":"Unavailable Entity Handling","text":"<p>Entities with unavailable states are handled specially. Unavailable entities (<code>evidence == None</code>) are skipped unless they are decaying. This prevents unavailable sensors from affecting the calculation while still allowing decaying evidence to contribute.</p>"},{"location":"technical/entity-evidence/#evidence-state-machine","title":"Evidence State Machine","text":"<p>The entity evidence system operates as a state machine:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   INACTIVE  \u2502 (evidence = False, decay not active)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502 evidence becomes True\n       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   ACTIVE    \u2502 (evidence = True, decay stopped)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502 evidence becomes False\n       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   DECAYING  \u2502 (evidence = False, decay active)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502 decay expires OR evidence becomes True\n       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   INACTIVE  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"technical/entity-evidence/#state-transitions","title":"State Transitions","text":"<ol> <li>INACTIVE \u2192 ACTIVE: Evidence transitions from <code>False</code> to <code>True</code></li> <li>Decay is stopped (if active)</li> <li> <p>Entity immediately provides full evidence</p> </li> <li> <p>ACTIVE \u2192 DECAYING: Evidence transitions from <code>True</code> to <code>False</code></p> </li> <li>Decay is started</li> <li> <p>Entity continues to provide evidence (with decreasing strength)</p> </li> <li> <p>DECAYING \u2192 ACTIVE: Evidence becomes <code>True</code> while decaying</p> </li> <li>Decay is stopped</li> <li> <p>Entity immediately provides full evidence</p> </li> <li> <p>DECAYING \u2192 INACTIVE: Decay factor drops below 5%</p> </li> <li>Decay stops automatically</li> <li>Entity no longer provides evidence</li> </ol>"},{"location":"technical/entity-evidence/#example-motion-sensor-evidence","title":"Example: Motion Sensor Evidence","text":"<p>Consider a motion sensor entity:</p>"},{"location":"technical/entity-evidence/#initial-state","title":"Initial State","text":"<ul> <li>State: <code>\"off\"</code></li> <li>Evidence: <code>False</code></li> <li>Decay: Not active</li> <li>Effective evidence: <code>False</code></li> </ul>"},{"location":"technical/entity-evidence/#motion-detected","title":"Motion Detected","text":"<ul> <li>State: <code>\"on\"</code></li> <li>Evidence: <code>True</code> (state is in <code>active_states = [\"on\"]</code>)</li> <li>Decay: Stopped (if was active)</li> <li>Effective evidence: <code>True</code></li> </ul>"},{"location":"technical/entity-evidence/#motion-stops","title":"Motion Stops","text":"<ul> <li>State: <code>\"off\"</code></li> <li>Evidence: <code>False</code></li> <li>Decay: Started (transition detected)</li> <li>Effective evidence: <code>True</code> (decay provides evidence)</li> </ul>"},{"location":"technical/entity-evidence/#decay-progress","title":"Decay Progress","text":"<ul> <li>State: <code>\"off\"</code></li> <li>Evidence: <code>False</code></li> <li>Decay: Active, factor = 0.7 (30% decayed)</li> <li>Effective evidence: <code>True</code> (decay still provides evidence, but with reduced strength)</li> </ul>"},{"location":"technical/entity-evidence/#decay-expires","title":"Decay Expires","text":"<ul> <li>State: <code>\"off\"</code></li> <li>Evidence: <code>False</code></li> <li>Decay: Stopped (factor &lt; 0.05)</li> <li>Effective evidence: <code>False</code></li> </ul>"},{"location":"technical/entity-evidence/#example-numeric-sensor-evidence","title":"Example: Numeric Sensor Evidence","text":"<p>Consider a temperature sensor with <code>active_range = (20.0, 25.0)</code>:</p>"},{"location":"technical/entity-evidence/#normal-temperature","title":"Normal Temperature","text":"<ul> <li>State: <code>22.5</code></li> <li>Evidence: <code>True</code> (22.5 is in range [20.0, 25.0])</li> <li>Effective evidence: <code>True</code></li> </ul>"},{"location":"technical/entity-evidence/#temperature-drops","title":"Temperature Drops","text":"<ul> <li>State: <code>18.0</code></li> <li>Evidence: <code>False</code> (18.0 is below range)</li> <li>Decay: Started (if was previously in range)</li> <li>Effective evidence: <code>True</code> (decay provides evidence)</li> </ul>"},{"location":"technical/entity-evidence/#temperature-rises-back","title":"Temperature Rises Back","text":"<ul> <li>State: <code>23.0</code></li> <li>Evidence: <code>True</code> (23.0 is in range)</li> <li>Decay: Stopped</li> <li>Effective evidence: <code>True</code></li> </ul>"},{"location":"technical/entity-evidence/#entity-manager","title":"Entity Manager","text":"<p>The Entity Manager manages all entities for an area.</p> <p>Responsibilities: - Creates entities from configuration - Loads entities from database - Tracks entity state changes - Provides access to entities by ID or type - Manages entity lifecycle</p> <p>Entities are accessed via: - <code>entities.entities</code>: Dictionary of all entities by entity_id - <code>entities.get_entity(entity_id)</code>: Get specific entity - <code>entities.get_entities_by_input_type(type)</code>: Get entities of specific type</p>"},{"location":"technical/entity-evidence/#see-also","title":"See Also","text":"<ul> <li>Complete Calculation Flow - How evidence is used in calculations</li> <li>Bayesian Calculation Deep Dive - How evidence affects probability</li> <li>Decay Feature - User-facing decay documentation</li> <li>Calculation Feature - User-facing calculation documentation</li> </ul>"},{"location":"technical/global-prior-flow/","title":"Global Prior Calculation Flow","text":""},{"location":"technical/global-prior-flow/#overview","title":"Overview","text":"<p>The global prior represents the baseline probability that an area is occupied, calculated from historical motion sensor data. It serves as the foundation for Bayesian probability calculations, providing a learned estimate of occupancy based on past behavior patterns.</p> <p>Purpose: The global prior captures the overall occupancy rate of an area over time, independent of time-of-day patterns. This is combined with time-specific priors (time priors) to create a more accurate baseline probability.</p>"},{"location":"technical/global-prior-flow/#key-concepts","title":"Key Concepts","text":"<ul> <li>Global Prior: Overall occupancy probability for an area (e.g., \"this room is occupied 30% of the time\")</li> <li>Time Prior: Time-of-day and day-of-week specific occupancy probability (e.g., \"this room is occupied 80% of the time on weekdays at 7 PM\")</li> <li>Combined Prior: The final prior used in Bayesian calculations, combining global and time priors</li> </ul>"},{"location":"technical/global-prior-flow/#calculation-algorithm","title":"Calculation Algorithm","text":"<p>The global prior is calculated using a simple ratio:</p> <pre><code>global_prior = total_occupied_time / total_period_duration\n</code></pre> <p>Where:</p> <ul> <li><code>total_occupied_time</code>: Sum of all occupied interval durations (from motion sensors)</li> <li><code>total_period_duration</code>: Duration from first interval to last interval (or current time)</li> </ul>"},{"location":"technical/global-prior-flow/#period-calculation","title":"Period Calculation","text":"<p>The system uses the actual data period rather than a fixed lookback window:</p> <ol> <li>First Interval Start: Earliest motion sensor interval start time</li> <li>Last Interval End: Latest motion sensor interval end time</li> <li>Period End Determination:</li> <li>If last interval is more than 1 hour old: Use <code>last_interval_end</code></li> <li>Otherwise: Use current time (<code>now</code>)</li> </ol> <p>This approach ensures the prior reflects the actual data available, not an arbitrary time window.</p>"},{"location":"technical/global-prior-flow/#clamping","title":"Clamping","text":"<p>The calculated prior is clamped to the range <code>[0.01, 0.99]</code> to prevent extreme values that could skew Bayesian calculations:</p> <pre><code>global_prior = max(0.01, min(0.99, occupied_duration / actual_period_duration))\n</code></pre>"},{"location":"technical/global-prior-flow/#complete-flow","title":"Complete Flow","text":""},{"location":"technical/global-prior-flow/#entry-points","title":"Entry Points","text":"<p>The global prior calculation can be triggered from several entry points:</p> <ol> <li>Scheduled Analysis (<code>run_full_analysis()</code>)</li> <li>Location: <code>custom_components/area_occupancy/data/analysis.py:25</code></li> <li>Triggered by analysis timer (typically every 24 hours)</li> <li> <p>Runs for all configured areas</p> </li> <li> <p>Area-Level Analysis (<code>area.run_prior_analysis()</code>)</p> </li> <li>Location: <code>custom_components/area_occupancy/area/area.py:151</code></li> <li> <p>Can be called directly for a specific area</p> </li> <li> <p>Manual Trigger (<code>start_prior_analysis()</code>)</p> </li> <li>Location: <code>custom_components/area_occupancy/data/analysis.py:155</code></li> <li>Wrapper function for async execution</li> </ol>"},{"location":"technical/global-prior-flow/#step-by-step-calculation-process","title":"Step-by-Step Calculation Process","text":"<pre><code>flowchart TD\n    Start([Prior Analysis Triggered]) --&gt; GetIntervals[Get Occupied Intervals]\n    GetIntervals --&gt; CheckEmpty{Intervals Found?}\n    CheckEmpty --&gt;|No| ReturnEarly[Return Early]\n    CheckEmpty --&gt;|Yes| CalcPeriod[Calculate Data Period]\n\n    CalcPeriod --&gt; FindFirst[Find First Interval Start]\n    FindFirst --&gt; FindLast[Find Last Interval End]\n    FindLast --&gt; CheckAge{Last Interval &gt; 1hr old?}\n    CheckAge --&gt;|Yes| UseLast[Use Last Interval End]\n    CheckAge --&gt;|No| UseNow[Use Current Time]\n\n    UseLast --&gt; CalcDuration[Calculate Period Duration]\n    UseNow --&gt; CalcDuration\n\n    CalcDuration --&gt; CheckValid{Duration &gt; 0?}\n    CheckValid --&gt;|No| Fallback[Set Fallback Prior 0.01]\n    CheckValid --&gt;|Yes| SumOccupied[Sum Occupied Duration]\n\n    Fallback --&gt; ReturnEarly\n    SumOccupied --&gt; CalcPrior[Calculate Global Prior]\n    CalcPrior --&gt; Clamp[Clamp to 0.01-0.99]\n    Clamp --&gt; SetMemory[Set in Prior Object]\n    SetMemory --&gt; SaveDB[Save to Database]\n    SaveDB --&gt; CalcTimePriors[Calculate Time Priors]\n    CalcTimePriors --&gt; End([Complete])\n    ReturnEarly --&gt; End</code></pre>"},{"location":"technical/global-prior-flow/#detailed-steps","title":"Detailed Steps","text":""},{"location":"technical/global-prior-flow/#step-1-get-occupied-intervals","title":"Step 1: Get Occupied Intervals","text":"<p>Location: <code>custom_components/area_occupancy/data/analysis.py:217</code></p> <pre><code>occupied_intervals = self.get_occupied_intervals(days)\n</code></pre> <ul> <li>Queries motion sensor intervals from the database</li> <li>Intervals are already merged and extended with motion timeout</li> <li>Uses <code>OccupiedIntervalsCache</code> when available for performance</li> <li>Returns list of <code>(start_time, end_time)</code> tuples</li> </ul> <p>Data Source: <code>Intervals</code> table filtered by:</p> <ul> <li>Motion sensor entities only (<code>entity_type == \"motion\"</code>)</li> <li>State == \"on\"</li> <li>Within lookback period (default: 90 days)</li> </ul>"},{"location":"technical/global-prior-flow/#step-2-calculate-data-period","title":"Step 2: Calculate Data Period","text":"<p>Location: <code>custom_components/area_occupancy/data/analysis.py:247-264</code></p> <pre><code>first_interval_start = min(start for start, end in occupied_intervals)\nlast_interval_end = max(end for start, end in occupied_intervals)\nnow = dt_util.utcnow()\n\nif (now - last_interval_end).total_seconds() &gt; 3600:\n    actual_period_end = last_interval_end\nelse:\n    actual_period_end = now\n\nactual_period_duration = (actual_period_end - first_interval_start).total_seconds()\n</code></pre> <p>Rationale: Using actual data period instead of fixed lookback ensures:</p> <ul> <li>Prior reflects actual data availability</li> <li>No artificial inflation from empty periods</li> <li>More accurate representation of occupancy patterns</li> </ul> <p>Edge Case Handling: If duration is zero or negative (bad timestamps or clock skew), the system sets a safe fallback prior of 0.01 and returns early.</p>"},{"location":"technical/global-prior-flow/#step-3-calculate-global-prior","title":"Step 3: Calculate Global Prior","text":"<p>Location: <code>custom_components/area_occupancy/data/analysis.py:285-296</code></p> <pre><code>occupied_duration = sum(\n    (end - start).total_seconds()\n    for start, end in occupied_intervals\n)\n\nglobal_prior = max(\n    0.01, min(0.99, occupied_duration / actual_period_duration)\n)\n</code></pre> <p>Calculation: Simple ratio of occupied time to total period duration.</p> <p>Clamping: Values are clamped to <code>[0.01, 0.99]</code> to prevent:</p> <ul> <li>Zero priors (would make Bayesian calculation impossible)</li> <li>Extreme priors (would dominate Bayesian updates)</li> </ul>"},{"location":"technical/global-prior-flow/#step-4-update-in-memory-prior","title":"Step 4: Update In-Memory Prior","text":"<p>Location: <code>custom_components/area_occupancy/data/analysis.py:299</code></p> <pre><code>self.area.prior.set_global_prior(global_prior)\n</code></pre> <ul> <li>Updates the <code>Prior</code> object's <code>global_prior</code> attribute</li> <li>Invalidates time prior cache (forces reload on next access)</li> <li>Updates <code>_last_updated</code> timestamp</li> </ul>"},{"location":"technical/global-prior-flow/#step-5-save-to-database","title":"Step 5: Save to Database","text":"<p>Location: <code>custom_components/area_occupancy/data/analysis.py:309-320</code></p> <pre><code>success = self.db.save_global_prior(\n    area_name=self.area_name,\n    prior_value=global_prior,\n    data_period_start=first_interval_start,\n    data_period_end=actual_period_end,\n    total_occupied_seconds=occupied_duration,\n    total_period_seconds=actual_period_duration,\n    interval_count=len(occupied_intervals),\n    calculation_method=\"interval_analysis\",\n)\n</code></pre> <p>Storage: Saves to <code>GlobalPriors</code> table with full metadata:</p> <ul> <li>Prior value</li> <li>Calculation date</li> <li>Data period (start/end)</li> <li>Total occupied seconds</li> <li>Total period seconds</li> <li>Interval count</li> <li>Calculation method</li> </ul> <p>Persistence: Only the most recent calculation is kept per area (older calculations are pruned, keeping last 15).</p>"},{"location":"technical/global-prior-flow/#storage-and-retrieval","title":"Storage and Retrieval","text":""},{"location":"technical/global-prior-flow/#database-schema","title":"Database Schema","text":"<p>Table: <code>GlobalPriors</code> (<code>custom_components/area_occupancy/db/schema.py:424</code>)</p> Column Type Description <code>id</code> Integer (PK) Auto-increment primary key <code>entry_id</code> String Integration entry ID <code>area_name</code> String (Unique) Area name <code>prior_value</code> Float Global prior probability <code>calculation_date</code> DateTime When prior was calculated <code>data_period_start</code> DateTime Start of data period used <code>data_period_end</code> DateTime End of data period used <code>total_occupied_seconds</code> Float Total occupied time in period <code>total_period_seconds</code> Float Total period duration <code>interval_count</code> Integer Number of intervals used <code>confidence</code> Float Confidence in calculation (0.0-1.0) <code>calculation_method</code> String Method used <code>underlying_data_hash</code> String Hash of underlying data (for validation) <code>created_at</code> DateTime Creation timestamp <code>updated_at</code> DateTime Last update timestamp <p>Indexes:</p> <ul> <li>Unique constraint on <code>area_name</code> (one global prior per area)</li> <li>Index on <code>calculation_date</code> (for history tracking)</li> </ul>"},{"location":"technical/global-prior-flow/#loading-from-database","title":"Loading from Database","text":"<p>Location: <code>custom_components/area_occupancy/db/operations.py:223-228</code></p> <pre><code>global_prior_data = await db.hass.async_add_executor_job(\n    db.get_global_prior, area_name\n)\nif global_prior_data:\n    area_data.prior.set_global_prior(global_prior_data[\"prior_value\"])\n</code></pre> <p>Query Function: <code>get_global_prior()</code> (<code>custom_components/area_occupancy/db/queries.py:348</code>)</p> <ul> <li>Queries <code>GlobalPriors</code> table by <code>area_name</code></li> <li>Returns dictionary with prior metadata</li> <li>Returns <code>None</code> if no prior found (prior defaults to <code>MIN_PRIOR</code>)</li> </ul> <p>When Loaded: During <code>load_data()</code> call on integration startup or reload.</p>"},{"location":"technical/global-prior-flow/#saving-to-database","title":"Saving to Database","text":"<p>Location: <code>custom_components/area_occupancy/db/operations.py:905</code></p> <p>Function: <code>save_global_prior()</code></p> <ul> <li>Updates existing record or creates new one</li> <li>Prunes old history (keeps last 15 calculations per area)</li> <li>Creates data hash for validation</li> <li>Handles errors gracefully (returns False on failure)</li> </ul>"},{"location":"technical/global-prior-flow/#integration-with-time-priors","title":"Integration with Time Priors","text":"<p>The global prior is combined with time priors to create a more accurate baseline:</p> <p>Location: <code>custom_components/area_occupancy/data/prior.py:66-103</code></p> <pre><code>@property\ndef value(self) -&gt; float:\n    if self.global_prior is None:\n        result = MIN_PRIOR\n    else:\n        if self.time_prior is None:\n            prior = self.global_prior\n        else:\n            prior = combine_priors(self.global_prior, self.time_prior)\n\n        # Apply PRIOR_FACTOR (1.05) and clamp\n        adjusted_prior = prior * PRIOR_FACTOR\n        result = max(MIN_PRIOR, min(MAX_PRIOR, adjusted_prior))\n\n    # Apply min_prior_override if configured\n    if self.config.min_prior_override &gt; 0.0:\n        result = max(result, self.config.min_prior_override)\n\n    return result\n</code></pre> <p>Combination Method: Uses logit space combination (<code>combine_priors()</code> function) to properly combine probabilities.</p> <p>PRIOR_FACTOR: Multiplier of 1.05 applied to slightly increase prior (accounts for sensor limitations).</p>"},{"location":"technical/global-prior-flow/#usage-in-probability-calculations","title":"Usage in Probability Calculations","text":"<p>The global prior (combined with time prior) is used as the baseline in Bayesian probability calculations:</p> <p>Location: <code>custom_components/area_occupancy/area/area.py:183-196</code></p> <pre><code>def probability(self) -&gt; float:\n    entities = self.entities.entities\n    if not entities:\n        return MIN_PROBABILITY\n\n    return bayesian_probability(\n        entities=entities,\n        prior=self.prior.value,  # Uses combined prior (global + time)\n    )\n</code></pre> <p>Bayesian Update: Each entity's evidence updates the prior probability using Bayes' theorem.</p>"},{"location":"technical/global-prior-flow/#data-flow-diagram","title":"Data Flow Diagram","text":"<pre><code>sequenceDiagram\n    participant Timer as Analysis Timer\n    participant Analysis as PriorAnalyzer\n    participant DB as Database\n    participant Prior as Prior Object\n    participant Area as Area Object\n\n    Timer-&gt;&gt;Analysis: calculate_and_update_prior()\n    Analysis-&gt;&gt;DB: get_occupied_intervals()\n    DB--&gt;&gt;Analysis: Motion intervals\n\n    Analysis-&gt;&gt;Analysis: Calculate period\n    Analysis-&gt;&gt;Analysis: Calculate global_prior\n    Analysis-&gt;&gt;Prior: set_global_prior()\n    Prior--&gt;&gt;Analysis: Updated\n\n    Analysis-&gt;&gt;DB: save_global_prior()\n    DB--&gt;&gt;Analysis: Saved\n\n    Analysis-&gt;&gt;Analysis: calculate_time_priors()\n    Analysis-&gt;&gt;DB: save_time_priors()\n\n    Note over Area,Prior: On probability calculation\n    Area-&gt;&gt;Prior: value (property)\n    Prior-&gt;&gt;Prior: Combine global + time prior\n    Prior--&gt;&gt;Area: Combined prior\n    Area-&gt;&gt;Area: bayesian_probability()</code></pre>"},{"location":"technical/global-prior-flow/#troubleshooting","title":"Troubleshooting","text":""},{"location":"technical/global-prior-flow/#global-prior-not-persisting","title":"Global Prior Not Persisting","text":"<p>Symptom: Global prior is lost on Home Assistant restart.</p> <p>Cause: Prior was calculated but not saved to database.</p> <p>Solution: Ensure <code>save_global_prior()</code> is called after calculation. Check logs for save errors.</p>"},{"location":"technical/global-prior-flow/#prior-always-default-value","title":"Prior Always Default Value","text":"<p>Symptom: Prior always returns <code>MIN_PRIOR</code> (0.01).</p> <p>Possible Causes:</p> <ol> <li>No motion sensor intervals found</li> <li>Intervals not synced from recorder</li> <li>Database query failing</li> </ol> <p>Solution:</p> <ul> <li>Check motion sensors are configured</li> <li>Verify intervals exist in database</li> <li>Check logs for query errors</li> </ul>"},{"location":"technical/global-prior-flow/#invalid-period-duration","title":"Invalid Period Duration","text":"<p>Symptom: Warning about invalid period duration, fallback prior used.</p> <p>Cause: Bad timestamps or clock skew causing negative/zero duration.</p> <p>Solution: Check system clock synchronization, verify interval timestamps.</p>"},{"location":"technical/global-prior-flow/#prior-not-loading-on-startup","title":"Prior Not Loading on Startup","text":"<p>Symptom: Prior defaults to <code>MIN_PRIOR</code> even though it was calculated.</p> <p>Possible Causes:</p> <ol> <li><code>load_data()</code> not called</li> <li>Database query failing</li> <li>Prior not saved previously</li> </ol> <p>Solution: Check <code>load_data()</code> is called during setup, verify database connection.</p>"},{"location":"technical/global-prior-flow/#known-issues-and-limitations","title":"Known Issues and Limitations","text":"<ol> <li> <p>Period Calculation Edge Case: The 1-hour threshold for determining <code>actual_period_end</code> may cause issues if last interval is exactly 1 hour old (uses last interval end instead of current time).</p> </li> <li> <p>No Validation of Loaded Prior: Loaded prior from database is set without validation that it's still valid or within expected bounds.</p> </li> <li> <p>Race Conditions: If multiple areas calculate priors simultaneously, database operations may conflict (though SQLite handles this gracefully).</p> </li> <li> <p>Missing Error Handling: If <code>save_global_prior()</code> fails, calculation continues but prior is lost (should log warning).</p> </li> </ol>"},{"location":"technical/global-prior-flow/#related-documentation","title":"Related Documentation","text":"<ul> <li>Time Prior Flow - Time-of-day specific priors</li> <li>Database Schema - Complete database structure</li> <li>Data Flow - Overall data flow through system</li> <li>Prior Learning - User-facing prior learning documentation</li> <li>Bayesian Calculation - How priors are used in calculations</li> </ul>"},{"location":"technical/ha-config-flow-ui-reference/","title":"Home Assistant Config Flow &amp; Options Flow \u2014 Complete UI Reference","text":"<p>Research document covering all interface options available for building config flows and options flows in Home Assistant integrations.</p>"},{"location":"technical/ha-config-flow-ui-reference/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Flow Result Types (Core Methods)</li> <li>Forms (<code>async_show_form</code>)</li> <li>All 40 Selectors (UI Input Types)</li> <li>Multi-Step Wizards</li> <li>Menu Navigation (<code>async_show_menu</code>)</li> <li>Progress / Long-Running Tasks (<code>async_show_progress</code>)</li> <li>External Step Flows (OAuth2)</li> <li>Collapsible Sections</li> <li>Suggested Values vs Defaults</li> <li>Read-Only Fields</li> <li>Error Handling</li> <li>Description Placeholders &amp; Translations</li> <li>Specialized Flow Types</li> <li>Config Subentry Flows (HA 2025.3+)</li> <li>Schema-Based Flow Helper (Declarative)</li> <li>Preview Support</li> <li>Browser Autofill</li> <li>Icons</li> <li>Discovery Flows</li> <li>Entry Lifecycle Helpers</li> <li>Summary of All UI Patterns</li> <li>Relevance to Area Occupancy Detection</li> <li>Sources</li> </ul>"},{"location":"technical/ha-config-flow-ui-reference/#flow-result-types-core-methods","title":"Flow Result Types (Core Methods)","text":"<p>Every flow handler has these methods, each producing a different UI outcome:</p> Method UI Result <code>async_show_form()</code> Input form dialog <code>async_show_menu()</code> Clickable navigation menu <code>async_show_progress()</code> Spinner/progress bar <code>async_external_step()</code> Redirect to external site (OAuth) <code>async_create_entry()</code> Success, flow ends <code>async_abort()</code> Error/info message, flow ends"},{"location":"technical/ha-config-flow-ui-reference/#complete-method-signatures","title":"Complete Method Signatures","text":"<pre><code># Show a form to gather user input\nasync def async_show_form(\n    self,\n    *,\n    step_id: str | None = None,\n    data_schema: vol.Schema | None = None,\n    errors: dict[str, str] | None = None,\n    description_placeholders: Mapping[str, str] | None = None,\n    last_step: bool | None = None,\n    preview: str | None = None,\n) -&gt; FlowResultT\n\n# Create a config entry (finish the flow)\nasync def async_create_entry(\n    self,\n    *,\n    title: str | None = None,\n    data: Mapping[str, Any],\n    description: str | None = None,\n    description_placeholders: Mapping[str, str] | None = None,\n) -&gt; FlowResultT\n\n# Abort the flow with a reason\nasync def async_abort(\n    self,\n    *,\n    reason: str,\n    description_placeholders: Mapping[str, str] | None = None,\n) -&gt; FlowResultT\n\n# Redirect user to an external URL (OAuth2 etc.)\nasync def async_external_step(\n    self,\n    *,\n    step_id: str | None = None,\n    url: str,\n    description_placeholders: Mapping[str, str] | None = None,\n) -&gt; FlowResultT\n\n# Mark external step as complete\nasync def async_external_step_done(\n    self,\n    *,\n    next_step_id: str,\n) -&gt; FlowResultT\n\n# Show a progress spinner for long-running tasks\nasync def async_show_progress(\n    self,\n    *,\n    step_id: str | None = None,\n    progress_action: str,\n    description_placeholders: Mapping[str, str] | None = None,\n    progress_task: asyncio.Task[Any] | None = None,\n) -&gt; FlowResultT\n\n# Update progress percentage (0.0 to 1.0)\nasync def async_update_progress(\n    self,\n    progress: float,\n) -&gt; None\n\n# Mark progress as done, advance to next step\nasync def async_show_progress_done(\n    self,\n    *,\n    next_step_id: str,\n) -&gt; FlowResultT\n\n# Show a menu of navigational options\nasync def async_show_menu(\n    self,\n    *,\n    step_id: str | None = None,\n    menu_options: Container[str],\n    sort: bool = False,\n    description_placeholders: Mapping[str, str] | None = None,\n) -&gt; FlowResultT\n\n# Called when a flow is removed/cancelled\nasync def async_remove(self) -&gt; None\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#forms-async_show_form","title":"Forms (<code>async_show_form</code>)","text":"<p>The primary UI method. Shows a dialog with input fields defined by <code>data_schema</code>.</p>"},{"location":"technical/ha-config-flow-ui-reference/#parameters","title":"Parameters","text":"<ul> <li><code>step_id</code>: Identifies the current step. Determines which translation keys to use.</li> <li><code>data_schema</code>: A <code>vol.Schema</code> defining form fields. Can use raw Voluptuous types or Selectors.</li> <li><code>errors</code>: Dict mapping field names to translation error keys. Use <code>\"base\"</code> for form-level errors not tied to a specific field.</li> <li><code>description_placeholders</code>: Dict of <code>{placeholder: value}</code> for substitution into translated title/description strings.</li> <li><code>last_step</code>: Controls the submit button text. <code>True</code> = \"Submit\", <code>False</code> = \"Next\", <code>None</code> = auto-detect (HA guesses based on whether more steps follow).</li> <li><code>preview</code>: String identifying a frontend preview component to load alongside the form.</li> </ul>"},{"location":"technical/ha-config-flow-ui-reference/#what-the-user-sees","title":"What the User Sees","text":"<p>A modal dialog with:</p> <ul> <li>A title (from <code>strings.json</code> <code>step.&lt;step_id&gt;.title</code>)</li> <li>An optional description paragraph (from <code>step.&lt;step_id&gt;.description</code>)</li> <li>Labeled form fields with optional field-level descriptions</li> <li>Error messages (red text) on individual fields or at the top</li> <li>A \"Submit\" or \"Next\" button (controlled by <code>last_step</code>)</li> </ul>"},{"location":"technical/ha-config-flow-ui-reference/#all-40-selectors-ui-input-types","title":"All 40 Selectors (UI Input Types)","text":"<p>Selectors define the UI widget rendered for each form field. They are used in <code>data_schema</code> like:</p> <pre><code>vol.Required(\"my_entity\"): EntitySelector(\n    EntitySelectorConfig(domain=\"sensor\", multiple=True)\n)\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#complete-selector-reference","title":"Complete Selector Reference","text":"# Selector Type String Purpose Key Config Options 1 <code>ActionSelector</code> <code>\"action\"</code> Automation action sequence editor \u2014 2 <code>AppSelector</code> <code>\"app\"</code> HA OS installed apps picker <code>name</code>, <code>slug</code> 3 <code>AddonSelector</code> <code>\"addon\"</code> HA supervisor add-on picker <code>name</code>, <code>slug</code> 4 <code>AreaSelector</code> <code>\"area\"</code> Area picker from area registry <code>multiple</code>, <code>device</code> filter, <code>entity</code> filter 5 <code>AssistPipelineSelector</code> <code>\"assist_pipeline\"</code> Voice assistant pipeline picker \u2014 6 <code>AttributeSelector</code> <code>\"attribute\"</code> Entity attribute picker <code>entity_id</code> (required), <code>hide_attributes</code> 7 <code>BackupLocationSelector</code> <code>\"backup_location\"</code> Backup destination picker (HA OS) \u2014 8 <code>BooleanSelector</code> <code>\"boolean\"</code> Toggle switch (on/off) \u2014 9 <code>ChooseSelector</code> <code>\"choose\"</code> Conditional input: show different fields based on choice <code>choices</code> (required), <code>translation_key</code> 10 <code>ColorRGBSelector</code> <code>\"color_rgb\"</code> Color picker wheel \u2014 11 <code>ColorTempSelector</code> <code>\"color_temp\"</code> Color temperature slider <code>unit</code> (mired/kelvin), <code>min</code>, <code>max</code> 12 <code>ConditionSelector</code> <code>\"condition\"</code> Automation condition editor \u2014 13 <code>ConfigEntrySelector</code> <code>\"config_entry\"</code> Pick an existing config entry <code>integration</code> (optional domain filter) 14 <code>ConstantSelector</code> <code>\"constant\"</code> Toggle that returns a fixed value when enabled <code>value</code> (required), <code>label</code>, <code>translation_key</code> 15 <code>ConversationAgentSelector</code> <code>\"conversation_agent\"</code> Pick a conversation/AI agent <code>language</code> 16 <code>CountrySelector</code> <code>\"country\"</code> Country dropdown (ISO 3166) <code>countries</code> (filter list), <code>no_sort</code> 17 <code>DateSelector</code> <code>\"date\"</code> Calendar date picker \u2014 18 <code>DateTimeSelector</code> <code>\"datetime\"</code> Date + time picker \u2014 19 <code>DeviceSelector</code> <code>\"device\"</code> Device picker from device registry <code>multiple</code>, <code>filter</code> (integration/manufacturer/model), <code>entity</code> filter 20 <code>DurationSelector</code> <code>\"duration\"</code> Hours:minutes:seconds input <code>enable_day</code>, <code>enable_millisecond</code>, <code>allow_negative</code> 21 <code>EntitySelector</code> <code>\"entity\"</code> Entity picker from entity registry <code>multiple</code>, <code>reorder</code>, <code>filter</code> (domain/integration/device_class), <code>include_entities</code>, <code>exclude_entities</code> 22 <code>FileSelector</code> <code>\"file\"</code> File upload input <code>accept</code> (required, MIME types e.g. <code>\"image/*\"</code>) 23 <code>FloorSelector</code> <code>\"floor\"</code> Floor picker <code>multiple</code>, <code>device</code> filter, <code>entity</code> filter 24 <code>IconSelector</code> <code>\"icon\"</code> MDI icon picker <code>placeholder</code> (default icon) 25 <code>LabelSelector</code> <code>\"label\"</code> HA label picker <code>multiple</code> 26 <code>LanguageSelector</code> <code>\"language\"</code> Language dropdown (RFC 5646) <code>languages</code> (filter list), <code>native_name</code>, <code>no_sort</code> 27 <code>LocationSelector</code> <code>\"location\"</code> Map pin selector <code>radius</code> (enable radius circle), <code>icon</code> 28 <code>MediaSelector</code> <code>\"media\"</code> Media browser/picker <code>accept</code> (MIME filter), <code>multiple</code> 29 <code>NumberSelector</code> <code>\"number\"</code> Numeric input (box or slider) <code>min</code>, <code>max</code>, <code>step</code>, <code>unit_of_measurement</code>, <code>mode</code> (\"box\"/\"slider\"), <code>translation_key</code> 30 <code>ObjectSelector</code> <code>\"object\"</code> Arbitrary YAML/dict input <code>fields</code>, <code>multiple</code>, <code>label_field</code>, <code>description_field</code>, <code>translation_key</code> 31 <code>QrCodeSelector</code> <code>\"qr_code\"</code> Displays a QR code (output-only) <code>data</code> (required), <code>scale</code>, <code>error_correction_level</code> 32 <code>SelectSelector</code> <code>\"select\"</code> Dropdown or list of options <code>options</code> (required), <code>multiple</code>, <code>custom_value</code>, <code>mode</code> (\"list\"/\"dropdown\"), <code>sort</code>, <code>translation_key</code> 33 <code>StateSelector</code> <code>\"state\"</code> Entity state picker <code>entity_id</code>, <code>hide_states</code>, <code>multiple</code> 34 <code>StatisticSelector</code> <code>\"statistic\"</code> Long-term statistic ID picker <code>multiple</code> 35 <code>TargetSelector</code> <code>\"target\"</code> Entity/device/area target (like action targets) <code>entity</code> filter, <code>device</code> filter 36 <code>TemplateSelector</code> <code>\"template\"</code> Jinja2 template text input \u2014 37 <code>TextSelector</code> <code>\"text\"</code> Text input field <code>multiline</code>, <code>prefix</code>, <code>suffix</code>, <code>type</code> (text/email/password/url/tel/search), <code>autocomplete</code>, <code>multiple</code> 38 <code>ThemeSelector</code> <code>\"theme\"</code> HA theme picker <code>include_default</code> 39 <code>TimeSelector</code> <code>\"time\"</code> Time-of-day picker \u2014 40 <code>TriggerSelector</code> <code>\"trigger\"</code> Automation trigger editor \u2014"},{"location":"technical/ha-config-flow-ui-reference/#selector-filtering-entitydevicearea","title":"Selector Filtering (Entity/Device/Area)","text":"<p>Entity, device, and area selectors support powerful filtering:</p> <pre><code>EntitySelector(EntitySelectorConfig(\n    domain=[\"sensor\", \"binary_sensor\"],       # One or multiple domains\n    device_class=\"temperature\",               # Device class filter\n    integration=\"mqtt\",                       # Integration filter\n    supported_features=4,                     # Feature bitmask\n    multiple=True,                            # Allow multi-select\n    reorder=True,                             # Allow drag reorder (requires multiple)\n    exclude_entities=[\"sensor.excluded\"],      # Exclude specific entities\n    include_entities=[\"sensor.specific_one\"],  # Only show these entities\n))\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#read-only-mode","title":"Read-Only Mode","text":"<p>Any selector can be made read-only:</p> <pre><code>EntitySelector(EntitySelectorConfig(read_only=True))\n</code></pre> <p>This displays the value but prevents user modification. Useful in options flows to show immutable settings.</p>"},{"location":"technical/ha-config-flow-ui-reference/#multi-step-wizards","title":"Multi-Step Wizards","text":"<p>Multi-step flows are created by having each step method return the next step's call.</p>"},{"location":"technical/ha-config-flow-ui-reference/#pattern","title":"Pattern","text":"<pre><code>class MyConfigFlow(ConfigFlow, domain=DOMAIN):\n    VERSION = 1\n\n    async def async_step_user(self, user_input=None):\n        if user_input is not None:\n            self._host = user_input[\"host\"]\n            return await self.async_step_credentials()\n        return self.async_show_form(\n            step_id=\"user\",\n            data_schema=vol.Schema({vol.Required(\"host\"): str}),\n            last_step=False,  # Shows \"Next\" button\n        )\n\n    async def async_step_credentials(self, user_input=None):\n        if user_input is not None:\n            return self.async_create_entry(\n                title=self._host,\n                data={\"host\": self._host, **user_input},\n            )\n        return self.async_show_form(\n            step_id=\"credentials\",\n            data_schema=vol.Schema({\n                vol.Required(\"username\"): str,\n                vol.Required(\"password\"): str,\n            }),\n            last_step=True,  # Shows \"Submit\" button\n        )\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#navigation-behavior","title":"Navigation Behavior","text":"<ul> <li><code>last_step=True</code>: Button reads \"Submit\"</li> <li><code>last_step=False</code>: Button reads \"Next\"</li> <li><code>last_step=None</code> (default): HA auto-detects based on whether subsequent steps exist</li> <li>Back button: The HA frontend automatically shows a back button on step 2+. No Python code needed.</li> <li>No explicit \"back\" handler: The frontend manages back navigation via its own step history stack. You cannot programmatically control back behavior.</li> </ul>"},{"location":"technical/ha-config-flow-ui-reference/#menu-navigation-async_show_menu","title":"Menu Navigation (<code>async_show_menu</code>)","text":"<p>Shows a list of clickable options that navigate to different steps. Each option maps to a step method.</p>"},{"location":"technical/ha-config-flow-ui-reference/#api","title":"API","text":"<pre><code>async def async_show_menu(\n    self,\n    *,\n    step_id: str | None = None,\n    menu_options: Container[str],  # list of step_id strings or dict\n    sort: bool = False,            # alphabetize by label\n    description_placeholders: Mapping[str, str] | None = None,\n) -&gt; FlowResultT\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#usage","title":"Usage","text":"<pre><code>async def async_step_init(self, user_input=None):\n    return self.async_show_menu(\n        step_id=\"init\",\n        menu_options=[\"add_area\", \"edit_area\", \"remove_area\"],\n    )\n\n# Each option maps to an async_step_&lt;option&gt; method:\nasync def async_step_add_area(self, user_input=None):\n    ...\nasync def async_step_edit_area(self, user_input=None):\n    ...\nasync def async_step_remove_area(self, user_input=None):\n    ...\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#what-the-user-sees_1","title":"What the User Sees","text":"<p>A dialog with a title, optional description, and a list of clickable menu items (styled as buttons/links). Clicking one navigates to that step.</p>"},{"location":"technical/ha-config-flow-ui-reference/#translations-stringsjson","title":"Translations (strings.json)","text":"<pre><code>{\n  \"config\": {\n    \"step\": {\n      \"init\": {\n        \"title\": \"Configuration\",\n        \"description\": \"What would you like to do?\",\n        \"menu_options\": {\n          \"add_area\": \"Add a new area\",\n          \"edit_area\": \"Edit an existing area\",\n          \"remove_area\": \"Remove an area\"\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#real-world-example-zha","title":"Real-World Example (ZHA)","text":"<p>The ZHA integration uses <code>async_show_menu</code> to let users choose between recommended and advanced setup strategies.</p>"},{"location":"technical/ha-config-flow-ui-reference/#progress-long-running-tasks-async_show_progress","title":"Progress / Long-Running Tasks (<code>async_show_progress</code>)","text":"<p>For long-running background operations (network scanning, firmware updates, etc.).</p>"},{"location":"technical/ha-config-flow-ui-reference/#api_1","title":"API","text":"<pre><code>async def async_show_progress(\n    self,\n    *,\n    step_id: str | None = None,\n    progress_action: str,                     # Translation key for progress text\n    description_placeholders: Mapping[str, str] | None = None,\n    progress_task: asyncio.Task[Any] | None = None,  # REQUIRED since 2024.8\n) -&gt; FlowResultT\n\nasync def async_update_progress(self, progress: float) -&gt; None\n    # progress is 0.0 to 1.0\n\nasync def async_show_progress_done(self, *, next_step_id: str) -&gt; FlowResultT\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#pattern_1","title":"Pattern","text":"<pre><code>async def async_step_setup(self, user_input=None):\n    if not hasattr(self, \"_setup_task\"):\n        self._setup_task = self.hass.async_create_task(\n            self._do_setup()\n        )\n\n    if not self._setup_task.done():\n        return self.async_show_progress(\n            step_id=\"setup\",\n            progress_action=\"configuring_device\",\n            progress_task=self._setup_task,\n        )\n\n    try:\n        result = self._setup_task.result()\n    except Exception:\n        return self.async_abort(reason=\"setup_failed\")\n\n    return self.async_show_progress_done(next_step_id=\"finish\")\n\nasync def async_step_finish(self, user_input=None):\n    return self.async_create_entry(title=\"Device\", data={...})\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#what-the-user-sees_2","title":"What the User Sees","text":"<p>A spinner/progress bar with translated text. If <code>async_update_progress(float)</code> is called, a percentage progress bar is shown. The dialog auto-advances when the task completes.</p>"},{"location":"technical/ha-config-flow-ui-reference/#limitations","title":"Limitations","text":"<ul> <li><code>progress_task</code> is required since HA 2024.8 (previously optional)</li> <li>The task must be an <code>asyncio.Task</code> object</li> <li>The step method is called repeatedly while the task runs (polling pattern)</li> </ul>"},{"location":"technical/ha-config-flow-ui-reference/#external-step-flows-oauth2","title":"External Step Flows (OAuth2)","text":"<p>For flows that redirect users to external websites (OAuth2 authorization, third-party linking).</p>"},{"location":"technical/ha-config-flow-ui-reference/#api_2","title":"API","text":"<pre><code>async def async_external_step(\n    self,\n    *,\n    step_id: str | None = None,\n    url: str,                                  # External URL to redirect to\n    description_placeholders: Mapping[str, str] | None = None,\n) -&gt; FlowResultT\n\nasync def async_external_step_done(\n    self,\n    *,\n    next_step_id: str,                         # Step to advance to after external completion\n) -&gt; FlowResultT\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#flow","title":"Flow","text":"<ol> <li>HA shows a dialog telling the user to visit the external URL</li> <li>User completes authorization on external site</li> <li>External site redirects back to an HA webhook endpoint</li> <li>Webhook calls <code>async_external_step_done(next_step_id=\"finish\")</code></li> <li>HA closes the external window and continues the flow</li> </ol>"},{"location":"technical/ha-config-flow-ui-reference/#collapsible-sections","title":"Collapsible Sections","text":"<p>Groups form fields into collapsible sections. Available since HA 2024.x.</p>"},{"location":"technical/ha-config-flow-ui-reference/#api_3","title":"API","text":"<pre><code>from homeassistant.data_entry_flow import section\n\ndata_schema = vol.Schema({\n    vol.Required(\"name\"): str,\n    vol.Required(\"host\"): str,\n    # Collapsible section:\n    vol.Required(\"advanced_options\"): section(\n        vol.Schema({\n            vol.Optional(\"timeout\", default=30): int,\n            vol.Optional(\"retry_count\", default=3): int,\n        }),\n        {\"collapsed\": True},  # Start collapsed\n    ),\n})\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#parameters_1","title":"Parameters","text":"<ul> <li>First argument: a <code>vol.Schema</code> with the fields in this section</li> <li>Second argument: a dict with <code>{\"collapsed\": bool}</code> (whether section starts collapsed)</li> </ul>"},{"location":"technical/ha-config-flow-ui-reference/#data-structure","title":"Data Structure","text":"<p>User input nests section data:</p> <pre><code>{\n    \"name\": \"My Device\",\n    \"host\": \"192.168.1.100\",\n    \"advanced_options\": {\n        \"timeout\": 30,\n        \"retry_count\": 3,\n    }\n}\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#translations-stringsjson_1","title":"Translations (strings.json)","text":"<pre><code>{\n  \"config\": {\n    \"step\": {\n      \"user\": {\n        \"data\": {\n          \"name\": \"Name\",\n          \"host\": \"Host\"\n        },\n        \"sections\": {\n          \"advanced_options\": {\n            \"name\": \"Advanced Options\",\n            \"description\": \"Configure advanced settings\",\n            \"data\": {\n              \"timeout\": \"Timeout (seconds)\",\n              \"retry_count\": \"Retry Count\"\n            },\n            \"data_description\": {\n              \"timeout\": \"How long to wait before timing out\",\n              \"retry_count\": \"Number of retries on failure\"\n            }\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#icons-iconsjson","title":"Icons (icons.json)","text":"<pre><code>{\n  \"config\": {\n    \"step\": {\n      \"user\": {\n        \"sections\": {\n          \"advanced_options\": \"mdi:cog-outline\"\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#limitations_1","title":"Limitations","text":"<ul> <li>Only a single level of sections is allowed (no nesting sections within sections)</li> <li>The section key in the schema becomes part of the data structure</li> </ul>"},{"location":"technical/ha-config-flow-ui-reference/#suggested-values-vs-defaults","title":"Suggested Values vs Defaults","text":"<p>Two distinct mechanisms for pre-populating form fields.</p>"},{"location":"technical/ha-config-flow-ui-reference/#default-value","title":"Default Value","text":"<pre><code>vol.Optional(\"field_name\", default=\"my_default\"): str\n</code></pre> <ul> <li>Pre-fills the field with the value</li> <li>If user clears the field and submits, <code>default</code> is used as the value</li> <li>The value is baked into the schema</li> </ul>"},{"location":"technical/ha-config-flow-ui-reference/#suggested-value","title":"Suggested Value","text":"<pre><code>vol.Optional(\n    \"field_name\",\n    description={\"suggested_value\": \"my_suggestion\"}\n): str\n</code></pre> <ul> <li>Pre-fills the field with the value</li> <li>If user clears the field and submits, the value is <code>None</code> / omitted</li> <li>Useful for edit forms where you want to show current values but allow clearing</li> </ul>"},{"location":"technical/ha-config-flow-ui-reference/#add_suggested_values_to_schema-helper","title":"add_suggested_values_to_schema Helper","text":"<p>For options flows where you want to populate a static schema with existing values:</p> <pre><code>OPTIONS_SCHEMA = vol.Schema({\n    vol.Optional(\"scan_interval\", default=30): int,\n    vol.Optional(\"name\"): str,\n})\n\nreturn self.async_show_form(\n    step_id=\"init\",\n    data_schema=self.add_suggested_values_to_schema(\n        OPTIONS_SCHEMA,\n        self.config_entry.options,  # Existing values become suggestions\n    ),\n)\n</code></pre> <p>This merges each key from the dict into the schema as <code>description={\"suggested_value\": ...}</code>, so the form shows current values but the user can clear them.</p>"},{"location":"technical/ha-config-flow-ui-reference/#read-only-fields","title":"Read-Only Fields","text":"<p>Display values that the user cannot modify (useful for showing immutable configuration in options flows).</p>"},{"location":"technical/ha-config-flow-ui-reference/#usage_1","title":"Usage","text":"<pre><code>vol.Optional(CONF_ENTITY_ID): EntitySelector(\n    EntitySelectorConfig(read_only=True)\n)\n</code></pre> <p>Any selector type supports the <code>read_only=True</code> config flag. The field is rendered but grayed out / non-interactive.</p>"},{"location":"technical/ha-config-flow-ui-reference/#error-handling","title":"Error Handling","text":""},{"location":"technical/ha-config-flow-ui-reference/#field-level-errors","title":"Field-Level Errors","text":"<pre><code>errors = {}\nif not valid_host(user_input[\"host\"]):\n    errors[\"host\"] = \"invalid_host\"\n\nreturn self.async_show_form(\n    step_id=\"user\",\n    data_schema=schema,\n    errors=errors,\n)\n</code></pre> <p>The error appears as red text below the specific field.</p>"},{"location":"technical/ha-config-flow-ui-reference/#form-level-errors-base","title":"Form-Level Errors (base)","text":"<pre><code>errors[\"base\"] = \"cannot_connect\"\n</code></pre> <p>Use the key <code>\"base\"</code> for errors not tied to a specific field. Shown at the top of the form.</p>"},{"location":"technical/ha-config-flow-ui-reference/#translations","title":"Translations","text":"<pre><code>{\n  \"config\": {\n    \"error\": {\n      \"invalid_host\": \"Invalid hostname or IP address\",\n      \"cannot_connect\": \"Unable to connect to the device\"\n    }\n  }\n}\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#description-placeholders-translations","title":"Description Placeholders &amp; Translations","text":""},{"location":"technical/ha-config-flow-ui-reference/#stringsjson-structure","title":"strings.json Structure","text":"<pre><code>{\n  \"title\": \"My Integration\",\n  \"config\": {\n    \"flow_title\": \"Configure {name}\",\n    \"step\": {\n      \"user\": {\n        \"title\": \"Set up {name}\",\n        \"description\": \"Enter the details for {name} at {host}\",\n        \"data\": {\n          \"host\": \"Hostname\",\n          \"port\": \"Port\"\n        },\n        \"data_description\": {\n          \"host\": \"The IP address or hostname of your device\",\n          \"port\": \"TCP port number (default: 8080)\"\n        }\n      }\n    },\n    \"error\": {\n      \"cannot_connect\": \"Failed to connect to {host}\",\n      \"invalid_auth\": \"Invalid credentials\"\n    },\n    \"abort\": {\n      \"already_configured\": \"This device is already configured\",\n      \"not_supported\": \"This device is not supported\"\n    }\n  }\n}\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#placeholder-substitution","title":"Placeholder Substitution","text":"<pre><code>return self.async_show_form(\n    step_id=\"user\",\n    description_placeholders={\n        \"name\": device_name,\n        \"host\": device_host,\n    },\n)\n</code></pre> <p>Placeholders in curly braces (<code>{name}</code>) in strings.json are replaced with values from <code>description_placeholders</code>.</p>"},{"location":"technical/ha-config-flow-ui-reference/#title-placeholders","title":"Title Placeholders","text":"<p>For the config flow title shown in the UI list:</p> <pre><code>self.context[\"title_placeholders\"] = {\"name\": \"My Device\"}\n</code></pre> <p>Priority for flow title resolution:</p> <ol> <li><code>title_placeholders</code> (non-empty) + localized <code>flow_title</code> string</li> <li><code>name</code> key from <code>title_placeholders</code></li> <li>Localized integration <code>title</code></li> <li>Manifest <code>name</code></li> <li>Domain name</li> </ol>"},{"location":"technical/ha-config-flow-ui-reference/#specialized-flow-types","title":"Specialized Flow Types","text":"Flow Type Purpose Entry Point Config Flow Initial setup <code>async_step_user()</code> Options Flow Modify settings post-setup <code>async_step_init()</code> Reconfigure Flow Change connection/host settings <code>async_step_reconfigure()</code> Reauth Flow Fix expired credentials <code>async_step_reauth()</code> Config Subentry Flow (2025.3+) Nested config under parent entry <code>async_step_user()</code> Discovery Flows Auto-discovered devices <code>async_step_zeroconf()</code>, <code>_dhcp()</code>, <code>_mqtt()</code>, etc."},{"location":"technical/ha-config-flow-ui-reference/#reconfigure-flows","title":"Reconfigure Flows","text":"<p>Allow users to reconfigure an existing config entry without removing and re-adding:</p> <pre><code>async def async_step_reconfigure(self, user_input=None):\n    entry = self._get_reconfigure_entry()\n\n    if user_input is not None:\n        return self.async_update_reload_and_abort(\n            entry,\n            data_updates=user_input,\n        )\n\n    return self.async_show_form(\n        step_id=\"reconfigure\",\n        data_schema=self.add_suggested_values_to_schema(\n            vol.Schema({vol.Required(\"host\"): str}),\n            entry.data,\n        ),\n    )\n</code></pre> <p>A \"Reconfigure\" button appears on the config entry's settings page.</p>"},{"location":"technical/ha-config-flow-ui-reference/#reauth-flows","title":"Reauth Flows","text":"<p>Triggered when authentication fails (token expired, password changed):</p> <pre><code>async def async_step_reauth(self, entry_data: Mapping[str, Any]):\n    return await self.async_step_reauth_confirm()\n\nasync def async_step_reauth_confirm(self, user_input=None):\n    if user_input is not None:\n        entry = self._get_reauth_entry()\n        return self.async_update_reload_and_abort(\n            entry,\n            data_updates=user_input,\n        )\n    return self.async_show_form(\n        step_id=\"reauth_confirm\",\n        data_schema=vol.Schema({vol.Required(\"password\"): str}),\n    )\n</code></pre> <p>A notification banner appears on the integration page with a button to start the reauth flow.</p>"},{"location":"technical/ha-config-flow-ui-reference/#options-flows","title":"Options Flows","text":"<p>Allow users to modify mutable settings after initial setup:</p> <pre><code># In your ConfigFlow class:\n@staticmethod\n@callback\ndef async_get_options_flow(config_entry: ConfigEntry) -&gt; OptionsFlowHandler:\n    return MyOptionsFlow()\n\nclass MyOptionsFlow(OptionsFlow):\n    async def async_step_init(self, user_input=None):\n        if user_input is not None:\n            return self.async_create_entry(data=user_input)\n\n        return self.async_show_form(\n            step_id=\"init\",\n            data_schema=self.add_suggested_values_to_schema(\n                OPTIONS_SCHEMA,\n                self.config_entry.options,\n            ),\n        )\n</code></pre> <p>Key differences from config flows:</p> <ul> <li>Entry point is <code>async_step_init</code> (not <code>async_step_user</code>)</li> <li>Access current entry via <code>self.config_entry</code></li> <li><code>async_create_entry(data=...)</code> updates <code>config_entry.options</code> (does not create a new entry)</li> <li>Same UI capabilities: forms, menus, progress, sections, all selectors</li> </ul>"},{"location":"technical/ha-config-flow-ui-reference/#auto-reload-optionsflowwithreload","title":"Auto-Reload (OptionsFlowWithReload)","text":"<pre><code>from homeassistant.config_entries import OptionsFlowWithReload\n\nclass MyOptionsFlow(OptionsFlowWithReload):\n    async def async_step_init(self, user_input=None):\n        if user_input is not None:\n            return self.async_create_entry(data=user_input)\n        ...\n</code></pre> <p>Automatically reloads the integration when options change.</p>"},{"location":"technical/ha-config-flow-ui-reference/#config-subentry-flows-ha-20253","title":"Config Subentry Flows (HA 2025.3+)","text":"<p>A newer feature for nested configuration under a parent config entry. Designed for integrations that need multiple configurations sharing one connection/authentication.</p>"},{"location":"technical/ha-config-flow-ui-reference/#use-cases","title":"Use Cases","text":"<ul> <li>Multiple AI conversation agents sharing one API key (OpenAI)</li> <li>Multiple weather locations sharing one API subscription</li> <li>Multiple MQTT entity definitions sharing one broker connection</li> <li>Multiple notification targets sharing one gateway</li> </ul>"},{"location":"technical/ha-config-flow-ui-reference/#data-hierarchy","title":"Data Hierarchy","text":"<pre><code>Config Entry (authentication, connection)\n  -&gt; Config Subentry (individual configuration, typed)\n       -&gt; Device Registry Entry\n            -&gt; Entity\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#implementation","title":"Implementation","text":"<pre><code>class MyConfigFlow(ConfigFlow, domain=DOMAIN):\n    @classmethod\n    @callback\n    def async_get_supported_subentry_types(\n        cls, config_entry: ConfigEntry\n    ) -&gt; dict[str, type[ConfigSubentryFlow]]:\n        return {\"location\": LocationSubentryFlowHandler}\n\nclass LocationSubentryFlowHandler(ConfigSubentryFlow):\n    async def async_step_user(self, user_input=None):\n        if user_input is not None:\n            return self.async_create_entry(\n                title=\"My Location\",\n                data=user_input,\n            )\n        return self.async_show_form(\n            step_id=\"user\",\n            data_schema=LOCATION_SCHEMA,\n        )\n\n    async def async_step_reconfigure(self, user_input=None):\n        subentry = self._get_reconfigure_subentry()\n        if user_input is not None:\n            return self.async_update_and_abort(\n                self._get_entry(),\n                subentry,\n                data=user_input,\n            )\n        return self.async_show_form(\n            step_id=\"reconfigure\",\n            data_schema=self.add_suggested_values_to_schema(\n                LOCATION_SCHEMA, subentry.data\n            ),\n        )\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#key-apis","title":"Key APIs","text":"<ul> <li><code>self._get_entry()</code> \u2014 Access the parent config entry</li> <li><code>self._get_reconfigure_subentry()</code> \u2014 Access the subentry being reconfigured</li> </ul>"},{"location":"technical/ha-config-flow-ui-reference/#translations-stringsjson_2","title":"Translations (strings.json)","text":"<pre><code>{\n  \"config_subentries\": {\n    \"location\": {\n      \"title\": \"Weather Location\",\n      \"step\": {\n        \"user\": {\n          \"title\": \"Add Location\",\n          \"data\": {\"city\": \"City\"}\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#limitations_2","title":"Limitations","text":"<ul> <li>Only <code>user</code> and <code>reconfigure</code> steps are supported (no discovery, reauth, import)</li> <li>Unique IDs are scoped to the parent entry (not globally unique)</li> <li>Deleting a subentry cascades to associated devices and entities</li> <li>Does not apply to automations or scripts</li> </ul>"},{"location":"technical/ha-config-flow-ui-reference/#schema-based-flow-helper-declarative","title":"Schema-Based Flow Helper (Declarative)","text":"<p>For simple integrations, <code>SchemaConfigFlowHandler</code> provides a declarative approach without writing individual step methods.</p>"},{"location":"technical/ha-config-flow-ui-reference/#classes","title":"Classes","text":"<pre><code>from homeassistant.helpers.schema_config_entry_flow import (\n    SchemaConfigFlowHandler,\n    SchemaFlowFormStep,\n    SchemaFlowMenuStep,\n    SchemaFlowError,\n)\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#usage_2","title":"Usage","text":"<pre><code>CONFIG_FLOW = {\n    \"user\": SchemaFlowFormStep(\n        schema=vol.Schema({vol.Required(\"name\"): str}),\n        next_step=\"options\",\n    ),\n    \"options\": SchemaFlowFormStep(\n        schema=vol.Schema({vol.Optional(\"interval\", default=30): int}),\n        validate_user_input=validate_input,\n    ),\n}\n\nOPTIONS_FLOW = {\n    \"init\": SchemaFlowMenuStep(options=[\"general\", \"advanced\"]),\n    \"general\": SchemaFlowFormStep(schema=GENERAL_SCHEMA),\n    \"advanced\": SchemaFlowFormStep(schema=ADVANCED_SCHEMA),\n}\n\nclass MyConfigFlow(SchemaConfigFlowHandler, domain=DOMAIN):\n    config_flow = CONFIG_FLOW\n    options_flow = OPTIONS_FLOW\n    options_flow_reloads = True     # Auto-reload on options change\n\n    def async_config_entry_title(self, options):\n        return options[\"name\"]\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#schemaflowformstep-fields","title":"SchemaFlowFormStep Fields","text":"<pre><code>@dataclass\nclass SchemaFlowFormStep:\n    schema: vol.Schema | Callable | None = None\n    validate_user_input: Callable | None = None    # Async validator\n    next_step: str | Callable | None = None         # Next step or callable returning step name\n    suggested_values: Callable | None | UNDEFINED = UNDEFINED\n    preview: str | None = None\n    description_placeholders: Callable | UNDEFINED = UNDEFINED\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#validation-with-schemaflowerror","title":"Validation with SchemaFlowError","text":"<pre><code>async def validate_input(handler, user_input):\n    if user_input[\"interval\"] &lt; 5:\n        raise SchemaFlowError(\"interval_too_small\")\n    return user_input\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#limitation","title":"Limitation","text":"<p>All input is saved to <code>config_entry.options</code>, not <code>config_entry.data</code>. This makes <code>SchemaConfigFlowHandler</code> unsuitable for storing credentials or connection details.</p>"},{"location":"technical/ha-config-flow-ui-reference/#preview-support","title":"Preview Support","text":"<p>Allows displaying a live preview alongside the form that updates as the user changes inputs.</p>"},{"location":"technical/ha-config-flow-ui-reference/#backend","title":"Backend","text":"<pre><code>return self.async_show_form(\n    step_id=\"user\",\n    data_schema=schema,\n    preview=\"my_preview\",  # Name of the preview component\n)\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#frontend","title":"Frontend","text":"<p>The frontend dynamically loads a component at <code>./previews/flow-preview-my_preview</code>. This is primarily used by core integrations. Custom integrations would need custom frontend components.</p>"},{"location":"technical/ha-config-flow-ui-reference/#browser-autofill","title":"Browser Autofill","text":"<p>Two approaches for enabling browser password managers to auto-fill credentials.</p>"},{"location":"technical/ha-config-flow-ui-reference/#voluptuous-key-names-limited","title":"Voluptuous Key Names (Limited)","text":"<p>The frontend automatically maps these specific key names:</p> <ul> <li><code>\"username\"</code> -&gt; HTML <code>autocomplete=\"username\"</code></li> <li><code>\"password\"</code> -&gt; HTML <code>autocomplete=\"current-password\"</code></li> </ul>"},{"location":"technical/ha-config-flow-ui-reference/#textselector-with-autocomplete-full-control","title":"TextSelector with autocomplete (Full Control)","text":"<pre><code>from homeassistant.helpers.selector import (\n    TextSelector, TextSelectorConfig, TextSelectorType\n)\n\nvol.Schema({\n    vol.Required(\"username\"): TextSelector(\n        TextSelectorConfig(\n            type=TextSelectorType.EMAIL,\n            autocomplete=\"username\",\n        )\n    ),\n    vol.Required(\"password\"): TextSelector(\n        TextSelectorConfig(\n            type=TextSelectorType.PASSWORD,\n            autocomplete=\"current-password\",\n        )\n    ),\n})\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#icons","title":"Icons","text":""},{"location":"technical/ha-config-flow-ui-reference/#integration-icon","title":"Integration Icon","text":"<p>Place a <code>icon.png</code> (256x256) or <code>icon@2x.png</code> in the integration directory.</p>"},{"location":"technical/ha-config-flow-ui-reference/#section-icons-iconsjson","title":"Section Icons (icons.json)","text":"<pre><code>{\n  \"config\": {\n    \"step\": {\n      \"user\": {\n        \"sections\": {\n          \"advanced_options\": \"mdi:cog-outline\",\n          \"network_settings\": \"mdi:network\"\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>Icons appear next to the collapsible section headers.</p>"},{"location":"technical/ha-config-flow-ui-reference/#discovery-flows","title":"Discovery Flows","text":"<p>Special step methods for auto-discovery. When a device is discovered, HA calls the appropriate step method directly.</p>"},{"location":"technical/ha-config-flow-ui-reference/#supported-discovery-sources","title":"Supported Discovery Sources","text":"Step Method Discovery Source Manifest Key <code>async_step_dhcp</code> DHCP discovery <code>dhcp</code> <code>async_step_bluetooth</code> Bluetooth discovery <code>bluetooth</code> <code>async_step_homekit</code> HomeKit discovery <code>homekit</code> <code>async_step_mqtt</code> MQTT discovery <code>mqtt</code> <code>async_step_ssdp</code> SSDP/UPnP discovery <code>ssdp</code> <code>async_step_zeroconf</code> mDNS/Zeroconf <code>zeroconf</code> <code>async_step_usb</code> USB device discovery <code>usb</code> <code>async_step_hassio</code> Supervisor add-on <code>hassio</code>"},{"location":"technical/ha-config-flow-ui-reference/#unique-id-management","title":"Unique ID Management","text":"<pre><code>async def async_step_zeroconf(self, discovery_info):\n    await self.async_set_unique_id(discovery_info.serial)\n    self._abort_if_unique_id_configured()  # Abort if already set up\n    # Show confirmation form...\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#entry-lifecycle-helpers","title":"Entry Lifecycle Helpers","text":""},{"location":"technical/ha-config-flow-ui-reference/#async_update_reload_and_abort","title":"async_update_reload_and_abort","text":"<p>Used in reconfigure and reauth flows to update an entry and reload:</p> <pre><code>return self.async_update_reload_and_abort(\n    self._get_reconfigure_entry(),\n    data_updates={\"host\": new_host},         # Merge into entry.data\n    options_updates={\"interval\": 60},        # Merge into entry.options\n)\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#unique-id-helpers","title":"Unique ID Helpers","text":"<pre><code>await self.async_set_unique_id(\"unique_device_id\")\nself._abort_if_unique_id_configured()         # Abort if ID exists\nself._abort_if_unique_id_configured(\n    updates={\"host\": new_host}                # Update existing entry data\n)\nself._abort_if_unique_id_mismatch()           # For reauth/reconfigure safety\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#matching-flows","title":"Matching Flows","text":"<pre><code>if hass.config_entries.flow.async_has_matching_flow(self):\n    return self.async_abort(reason=\"already_in_progress\")\n\ndef is_matching(self, other_flow: Self) -&gt; bool:\n    return other_flow.context.get(\"unique_id\") == self.context.get(\"unique_id\")\n</code></pre>"},{"location":"technical/ha-config-flow-ui-reference/#summary-of-all-ui-patterns","title":"Summary of All UI Patterns","text":"Pattern Method/API What User Sees Form <code>async_show_form()</code> Input fields dialog with Submit/Next Menu <code>async_show_menu()</code> Clickable list of navigation options Progress <code>async_show_progress()</code> Spinner/progress bar during background work External <code>async_external_step()</code> Redirect to external site (OAuth) Abort <code>async_abort()</code> Error/info message, flow ends Create Entry <code>async_create_entry()</code> Success message, flow ends Collapsible Sections <code>section()</code> in schema Expandable/collapsible field groups Read-Only Fields <code>SelectorConfig(read_only=True)</code> Grayed-out display-only fields QR Code Display <code>QrCodeSelector</code> Non-interactive QR code display Multi-Select <code>Selector(multiple=True)</code> Tags/chips multi-select Drag Reorder <code>EntitySelector(reorder=True)</code> Reorderable entity list Map/Location <code>LocationSelector(radius=True)</code> Interactive map with pin and radius Color Picker <code>ColorRGBSelector</code> Color wheel Slider <code>NumberSelector(mode=\"slider\")</code> Horizontal slider Dropdown <code>SelectSelector(mode=\"dropdown\")</code> Dropdown menu Radio List <code>SelectSelector(mode=\"list\")</code> Vertically listed radio buttons Custom Value <code>SelectSelector(custom_value=True)</code> Dropdown with free-text input File Upload <code>FileSelector(accept=\"image/*\")</code> File upload button Template Editor <code>TemplateSelector</code> Jinja2 code editor Icon Picker <code>IconSelector</code> MDI icon browser Duration Input <code>DurationSelector</code> H:M:S multi-field input Date/Time Pickers <code>DateSelector</code>, <code>TimeSelector</code>, <code>DateTimeSelector</code> Calendar/clock pickers Conditional Fields <code>ChooseSelector</code> Different fields based on choice Password Input <code>TextSelector(type=PASSWORD)</code> Masked text input Multiline Text <code>TextSelector(multiline=True)</code> Textarea Preview <code>preview=\"name\"</code> on form Live preview panel next to form"},{"location":"technical/ha-config-flow-ui-reference/#relevance-to-area-occupancy-detection","title":"Relevance to Area Occupancy Detection","text":"<p>Given this integration's multi-area architecture with complex per-area configuration, the most relevant patterns are:</p> <ol> <li>Menu flow for the options flow init (add/edit/remove area)</li> <li>Multi-step wizard for area configuration (sensors -&gt; weights -&gt; thresholds -&gt; decay)</li> <li>Collapsible sections for grouping related settings (sensor selection, weights, advanced)</li> <li>EntitySelector with filters (<code>domain=[\"binary_sensor\"]</code>, <code>device_class=\"motion\"</code>, <code>multiple=True</code>, <code>reorder=True</code>)</li> <li>NumberSelector with slider mode for weights and thresholds</li> <li>SelectSelector for room purpose/type</li> <li>BooleanSelector for feature toggles (Wasp in Box, decay enabled)</li> <li>Config Subentry Flows (2025.3+) \u2014 the ideal architecture for multi-area: parent entry holds global config, each area is a subentry with its own device</li> </ol>"},{"location":"technical/ha-config-flow-ui-reference/#sources","title":"Sources","text":"<ul> <li>Data Entry Flow | HA Developer Docs</li> <li>Config Flow | HA Developer Docs</li> <li>Options Flow | HA Developer Docs</li> <li>Selectors | HA Docs</li> <li>data_entry_flow.py source (HA Core)</li> <li>selector.py source (HA Core)</li> <li>schema_config_entry_flow.py source (HA Core)</li> <li>Config Subentries Architecture Discussion</li> <li>ConfigSubentryFlow Changes Blog</li> </ul>"},{"location":"technical/likelihood-calculation/","title":"Likelihood Calculation","text":"<p>This document explains how the system learns and uses likelihood probabilities for each sensor entity.</p>"},{"location":"technical/likelihood-calculation/#overview","title":"Overview","text":"<p>Likelihoods represent how reliable each sensor is as evidence of occupancy. The system uses different analysis methods depending on sensor type:</p> <ul> <li>Numeric Sensors (temperature, humidity, CO2, etc.): Learn statistical distributions using correlation analysis with Gaussian PDFs.</li> <li>Binary Sensors (media players, appliances, doors, windows): Calculate static probabilities from duration-based interval overlap analysis.</li> <li>Motion Sensors: Use user-configurable static probabilities (not learned).</li> </ul> <p>Important: Motion sensors do not have learned likelihoods. Instead, they use user-configurable likelihoods that can be set per area during configuration (defaults: <code>prob_given_true=0.95</code>, <code>prob_given_false=0.02</code>). This is because motion sensors are used as ground truth to determine occupied intervals. Learning motion sensor likelihoods would create a circular dependency.</p>"},{"location":"technical/likelihood-calculation/#likelihood-analysis-process","title":"Likelihood Analysis Process","text":"<p>The analysis process runs periodically (typically hourly) as part of the analysis cycle.</p> <p>See Sensor Correlation Analysis Chain for the detailed flow.</p>"},{"location":"technical/likelihood-calculation/#analysis-methods-by-sensor-type","title":"Analysis Methods by Sensor Type:","text":"<ol> <li> <p>Numeric Sensors: Use correlation analysis to learn Gaussian distributions (Mean and Standard Deviation) for occupied and unoccupied states. Likelihoods are calculated dynamically at runtime using Gaussian PDFs.</p> </li> <li> <p>Binary Sensors: Use duration-based analysis to calculate static probabilities directly from interval overlap durations. These are stored as <code>prob_given_true</code> and <code>prob_given_false</code> values.</p> </li> <li> <p>Motion Sensors: Use configured static probabilities (not analyzed).</p> </li> </ol>"},{"location":"technical/likelihood-calculation/#how-likelihoods-are-used-in-real-time-calculation","title":"How Likelihoods Are Used in Real-Time Calculation","text":"<p>During real-time probability calculation, likelihoods are retrieved differently based on sensor type.</p>"},{"location":"technical/likelihood-calculation/#numeric-sensors-dynamic-pdf-calculation","title":"Numeric Sensors: Dynamic PDF Calculation","text":"<p>For numeric sensors with learned Gaussian parameters, the system calculates two probability densities dynamically:</p> \\[ f(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{-\\frac{1}{2}(\\frac{x-\\mu}{\\sigma})^2} \\] <ol> <li>\\(P(x | Occupied)\\): Likelihood of current value \\(x\\) given the \"Occupied\" distribution.</li> <li>\\(P(x | Unoccupied)\\): Likelihood of current value \\(x\\) given the \"Unoccupied\" distribution.</li> </ol> <p>If the sensor state is unavailable (e.g., \"unknown\"), the system uses a representative value (average of occupied and unoccupied means) to calculate probabilities.</p>"},{"location":"technical/likelihood-calculation/#binary-sensors-static-probabilities","title":"Binary Sensors: Static Probabilities","text":"<p>For binary sensors (media, appliances, doors, windows), the system uses static probabilities calculated from duration-based analysis:</p> <ul> <li>\\(P(Active | Occupied)\\): Probability that the sensor is active when the area is occupied.</li> <li>\\(P(Active | Unoccupied)\\): Probability that the sensor is active when the area is unoccupied.</li> </ul> <p>These values are stored directly and used regardless of the current sensor state.</p>"},{"location":"technical/likelihood-calculation/#motion-sensors-configured-probabilities","title":"Motion Sensors: Configured Probabilities","text":"<p>Motion sensors use the user-configured static probabilities set during area configuration.</p>"},{"location":"technical/likelihood-calculation/#decay-adjusted-likelihoods","title":"Decay-Adjusted Likelihoods","text":"<p>When an entity is decaying (e.g., motion sensor that just turned off), its likelihoods are interpolated toward neutral (0.5). This gradually reduces the influence of stale evidence as decay progresses.</p>"},{"location":"technical/likelihood-calculation/#weight-application","title":"Weight Application","text":"<p>The likelihoods are weighted by the entity's configured weight:</p> <pre><code>contribution_true = log(p_t) * entity.weight\ncontribution_false = log(p_f) * entity.weight\n</code></pre> <p>Higher weights mean the entity's evidence has more influence on the final probability.</p>"},{"location":"technical/likelihood-calculation/#database-schema","title":"Database Schema","text":""},{"location":"technical/likelihood-calculation/#correlations-table","title":"Correlations Table","text":"<p>Stores analysis results for both numeric sensors and binary sensors:</p> <p>For Numeric Sensors (Gaussian parameters):</p> <ul> <li><code>area_name</code>, <code>entity_id</code></li> <li><code>correlation_type</code>: \"strong_positive\", \"strong_negative\", or \"none\"</li> <li><code>mean_value_when_occupied</code>, <code>std_dev_when_occupied</code></li> <li><code>mean_value_when_unoccupied</code>, <code>std_dev_when_unoccupied</code></li> <li><code>correlation_coefficient</code>, <code>confidence</code></li> </ul> <p>For Binary Sensors (static probabilities):</p> <ul> <li><code>area_name</code>, <code>entity_id</code></li> <li><code>correlation_type</code>: \"binary_likelihood\"</li> <li><code>mean_value_when_occupied</code>: Stores <code>prob_given_true</code></li> <li><code>mean_value_when_unoccupied</code>: Stores <code>prob_given_false</code></li> <li><code>correlation_coefficient</code>: <code>None</code> (not applicable for binary sensors)</li> </ul> <p>For Both Types:</p> <ul> <li><code>analysis_error</code>: Reason why analysis failed or was not performed (e.g., \"no_correlation\", \"too_few_samples\", \"no_occupied_intervals\"). This value is persisted and restored when entities are reloaded.</li> </ul>"},{"location":"technical/likelihood-calculation/#entities-table","title":"Entities Table","text":"<p>Stores current entity state and configuration:</p> <ul> <li><code>prob_given_true</code>: Probability sensor is active when occupied (for binary sensors, loaded from Correlations table)</li> <li><code>prob_given_false</code>: Probability sensor is active when unoccupied (for binary sensors, loaded from Correlations table)</li> <li><code>learned_gaussian_params</code>: JSON field storing Gaussian parameters (for numeric sensors, loaded from Correlations table)</li> <li><code>analysis_error</code>: Reason why analysis failed or was not performed (loaded from Correlations table)</li> </ul>"},{"location":"technical/likelihood-calculation/#numericsamples-table","title":"NumericSamples Table","text":"<p>Stores raw numeric sensor values with timestamps.</p>"},{"location":"technical/likelihood-calculation/#intervals-table","title":"Intervals Table","text":"<p>Stores binary sensor state intervals (on/off periods) used for duration-based analysis.</p>"},{"location":"technical/likelihood-calculation/#default-likelihoods","title":"Default Likelihoods","text":"<p>If history-based learning is disabled, insufficient data is available, or correlation fails, the system uses default static likelihoods from the entity type definition.</p> <p>Default values vary by entity type:</p> <ul> <li>Motion sensors: High <code>P(Active | Occupied)</code>, low <code>P(Active | Not Occupied)</code> (configured per area)</li> <li>Media players: Medium <code>P(Active | Occupied)</code>, very low <code>P(Active | Not Occupied)</code></li> <li>Environmental sensors: Low <code>P(Active | Occupied)</code>, low <code>P(Active | Not Occupied)</code></li> </ul> <p>Note: These defaults are used directly from <code>EntityType</code> when Gaussian parameters are unavailable. The system does not store fallback values in the database for non-motion sensors.</p> <p>For non-motion sensors, these defaults are replaced by learned values once sufficient historical data is available.</p>"},{"location":"technical/likelihood-calculation/#see-also","title":"See Also","text":"<ul> <li>Sensor Correlation Analysis Chain - End-to-end process</li> <li>Sensor Correlation Feature - User-facing documentation</li> <li>Prior Calculation Deep Dive - Related learning process</li> <li>Bayesian Calculation Deep Dive - How likelihoods are used</li> </ul>"},{"location":"technical/prerelease/","title":"Pre-Releases","text":"<p>You are always welcome and encouraged to contribute to the project. Trying out the pre-releases and submitting feedback/issues is a great way to help.</p>"},{"location":"technical/prerelease/#installing-pre-releases","title":"Installing Pre-releases","text":"<p>You can try out the pre-releases by downloading them via HACS. You can find the available pre-releases on the releases page.</p> <ol> <li>Go to HACS</li> <li>Search for \"Area Occupancy Detection\"     </li> <li>Select the integration</li> <li>Use the \"three dots\" menu and select \"Redownload\"     </li> <li>Select the version you want to install after expanding the \"Need a different version?\" section (e.g. <code>2025.8.1-pre2</code>) and click on \"Download\"     </li> <li>Restart Home Assistant</li> </ol>"},{"location":"technical/prerelease/#issues","title":"Issues","text":"<p>If you find any issues, please report them in the issue tracker.</p>"},{"location":"technical/prerelease/#discussions","title":"Discussions","text":"<p>If you have any feedback, please share it in the discussions section.</p>"},{"location":"technical/time-prior-flow/","title":"Time Prior Feature - Complete Code Flow Documentation","text":""},{"location":"technical/time-prior-flow/#overview","title":"Overview","text":"<p>The time prior feature provides time-of-day and day-of-week specific occupancy probabilities. This document provides a comprehensive deep dive into how time priors work, including data sources, calculation, storage, retrieval, and usage in probability calculations.</p> <p>Implementation Status: Time priors are fully implemented. The system calculates time priors from historical data during the analysis cycle and stores them in the database for efficient retrieval at runtime.</p>"},{"location":"technical/time-prior-flow/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Data Sources and Input Flow</li> <li>Time Prior Calculation</li> <li>Storage Mechanism</li> <li>Retrieval at Runtime</li> <li>Usage in Probability Calculation</li> <li>Code Flow Diagrams</li> <li>Implementation Notes</li> </ol>"},{"location":"technical/time-prior-flow/#data-sources-and-input-flow","title":"Data Sources and Input Flow","text":""},{"location":"technical/time-prior-flow/#11-historical-data-collection","title":"1.1 Historical Data Collection","text":"<p>Source: Home Assistant Recorder database</p> <p>Process: <code>sync_states()</code> in <code>db/sync.py</code> imports state history from Home Assistant's recorder</p> <p>Storage: Raw intervals stored in <code>intervals</code> table with:</p> <ul> <li><code>entity_id</code>: The sensor entity ID</li> <li><code>state</code>: The sensor state (e.g., \"on\", \"off\")</li> <li><code>start_time</code>: When the state change occurred</li> <li><code>end_time</code>: When the next state change occurred</li> <li><code>duration_seconds</code>: Duration of this interval</li> <li><code>area_name</code>: The area this interval belongs to</li> </ul> <p>Ground Truth: Motion sensors exclusively (see <code>queries.py:get_occupied_intervals()</code>)</p> <p>The system uses motion sensors as the \"ground truth\" for occupancy because they are the most direct indicator of human presence and rarely generate false positives.</p>"},{"location":"technical/time-prior-flow/#12-occupied-intervals-calculation","title":"1.2 Occupied Intervals Calculation","text":"<p>Location: <code>db/queries.py:get_occupied_intervals()</code></p> <p>Method:</p> <ol> <li>Queries motion sensor intervals from <code>intervals</code> table filtered by:</li> <li><code>entry_id</code>: Integration entry ID</li> <li><code>area_name</code>: Specific area</li> <li><code>entity_type == InputType.MOTION.value</code>: Only motion sensors</li> <li><code>state == \"on\"</code>: Only active motion intervals</li> <li> <p><code>start_time &gt;= lookback_date</code>: Within lookback period</p> </li> <li> <p>Merges overlapping intervals using <code>utils.py:merge_overlapping_intervals()</code></p> </li> <li>Combines intervals that overlap or are adjacent</li> <li> <p>Prevents double-counting of occupied time</p> </li> <li> <p>Applies motion timeout extension using <code>utils.py:apply_motion_timeout()</code></p> </li> <li>Extends intervals by the motion timeout period (default: 5 minutes)</li> <li>Accounts for time after motion stops when area may still be occupied</li> </ol> <p>Output: List of <code>(start_time, end_time)</code> tuples representing occupied periods</p> <p>Example:</p> <pre><code>intervals = [\n    (datetime(2024, 1, 1, 9, 0), datetime(2024, 1, 1, 9, 15)),\n    (datetime(2024, 1, 1, 9, 12), datetime(2024, 1, 1, 9, 30)),  # Overlaps with first\n    (datetime(2024, 1, 1, 14, 0), datetime(2024, 1, 1, 14, 5)),\n]\n# After merging and timeout extension:\nmerged = [\n    (datetime(2024, 1, 1, 9, 0), datetime(2024, 1, 1, 9, 35)),  # Merged + timeout\n    (datetime(2024, 1, 1, 14, 0), datetime(2024, 1, 1, 14, 10)),  # Extended by timeout\n]\n</code></pre>"},{"location":"technical/time-prior-flow/#13-caching-layer","title":"1.3 Caching Layer","text":"<p>Table: <code>occupied_intervals_cache</code> (see <code>schema.py:OccupiedIntervalsCache</code>)</p> <p>Purpose: Precomputed occupied intervals to avoid recalculation</p> <p>Population: <code>operations.py:save_occupied_intervals_cache()</code></p> <ul> <li>Called during analysis cycle</li> <li>Stores merged and extended intervals</li> <li>Includes <code>calculation_date</code> for cache validity checking</li> </ul> <p>Validity Check: <code>queries.py:is_occupied_intervals_cache_valid()</code></p> <ul> <li>Checks if cache is less than 24 hours old (default)</li> <li>Returns <code>False</code> if cache is stale or missing</li> </ul> <p>Usage: The cache is used by prior analysis to avoid recalculating occupied intervals from raw sensor data.</p>"},{"location":"technical/time-prior-flow/#time-prior-calculation","title":"Time Prior Calculation","text":""},{"location":"technical/time-prior-flow/#21-implementation-overview","title":"2.1 Implementation Overview","text":"<p>Time priors are calculated during the analysis cycle by the <code>PriorAnalyzer</code> class. The calculation occurs automatically after global prior calculation, using the same occupied intervals data.</p> <p>Location: <code>data/analysis.py:PriorAnalyzer.calculate_time_priors()</code></p> <p>Grid: 168 time slots (24 hours \u00d7 7 days)</p> <ul> <li>Each slot represents one hour on a specific day of week</li> <li>Day of week: 0=Monday, 1=Tuesday, ..., 6=Sunday</li> <li>Time slot: 0=00:00-01:00, 1=01:00-02:00, ..., 23=23:00-24:00</li> </ul>"},{"location":"technical/time-prior-flow/#22-calculation-process","title":"2.2 Calculation Process","text":"<p>The calculation follows these steps:</p> <ol> <li> <p>Get Occupied Intervals: Uses the same occupied intervals calculated for global prior analysis (from motion sensors, merged and extended with motion timeout).</p> </li> <li> <p>Process Each Interval: For each occupied interval:</p> </li> <li>Iterates through all time slots the interval overlaps with</li> <li>Calculates the overlap duration for each slot</li> <li> <p>Tracks which week each overlap belongs to (for data point counting)</p> </li> <li> <p>Calculate Per-Slot Statistics:</p> </li> <li>Occupied Seconds: Sum of all overlap durations for each slot</li> <li>Data Points: Number of unique weeks with data for each slot</li> <li> <p>Total Slot Seconds: <code>data_points \u00d7 3600</code> (seconds per hour)</p> </li> <li> <p>Calculate Prior Values:</p> </li> <li>For each slot: <code>prior_value = occupied_seconds / total_slot_seconds</code></li> <li>Applies safety bounds: clamps to [0.1, 0.9] range</li> <li> <p>Only calculates priors for slots with data (missing slots default to 0.5 at retrieval)</p> </li> <li> <p>Save to Database: Calls <code>save_time_priors()</code> to store all calculated priors with metadata:</p> </li> <li><code>prior_value</code>: The calculated probability</li> <li><code>data_points</code>: Number of weeks with data</li> <li><code>confidence</code>: Calculated as <code>min(1.0, data_points / 4.0)</code> (4 weeks = full confidence)</li> <li><code>sample_period_start/end</code>: The data period used</li> <li><code>calculation_method</code>: \"interval_analysis\"</li> </ol> <p>Note: Only motion sensors are used for time prior calculation (no media/appliance fallback).</p> <p>Safety Bounds: The system bounds time-specific probabilities between 10% and 90% to prevent extreme values from dominating the calculation.</p>"},{"location":"technical/time-prior-flow/#23-integration-point","title":"2.3 Integration Point","text":"<p>Called From: <code>data/analysis.py:PriorAnalyzer.calculate_and_update_prior()</code> (line 303-337)</p> <p>Timing: After global prior calculation completes successfully</p> <p>Error Handling: If time prior calculation fails, it logs a warning but does not prevent global prior from being saved. The system continues to function using only the global prior until the next analysis cycle.</p>"},{"location":"technical/time-prior-flow/#storage-mechanism","title":"Storage Mechanism","text":""},{"location":"technical/time-prior-flow/#31-database-schema","title":"3.1 Database Schema","text":"<p>Table: <code>priors</code> (see <code>schema.py:176-247</code>)</p> <p>Primary Key: Composite of <code>(area_name, day_of_week, time_slot)</code></p> <ul> <li>Ensures one prior value per area per time slot</li> <li>Allows efficient lookup by area and time slot</li> </ul> <p>Columns:</p> Column Type Description <code>entry_id</code> String Integration entry ID (same for all priors) <code>area_name</code> String (PK, FK) Area name (foreign key to <code>areas</code> table) <code>day_of_week</code> Integer (PK) Day of week (0=Monday, 6=Sunday) <code>time_slot</code> Integer (PK) Time slot (0-23 for hourly slots) <code>prior_value</code> Float Prior probability for this slot (0.0-1.0) <code>data_points</code> Integer Number of data points used in calculation <code>confidence</code> Float Confidence in calculation (0.0-1.0, nullable) <code>last_calculation_date</code> DateTime When prior was last calculated (nullable) <code>sample_period_start</code> DateTime Start of data period used (nullable) <code>sample_period_end</code> DateTime End of data period used (nullable) <code>calculation_method</code> String Method used (e.g., \"interval_analysis\", nullable) <code>last_updated</code> DateTime Last update timestamp <p>Indexes:</p> <ul> <li><code>idx_priors_entry</code> on <code>entry_id</code>: Fast filtering by integration</li> <li><code>idx_priors_area</code> on <code>area_name</code>: Fast filtering by area</li> <li><code>idx_priors_entry_area</code> on <code>(entry_id, area_name)</code>: Composite index for area queries</li> <li><code>idx_priors_day_slot</code> on <code>(day_of_week, time_slot)</code>: Fast lookup by time slot</li> <li><code>idx_priors_last_updated</code> on <code>last_updated</code>: For tracking recalculations</li> </ul> <p>Relationships:</p> <ul> <li>Many-to-one with <code>areas</code> table via <code>area_name</code> foreign key</li> </ul>"},{"location":"technical/time-prior-flow/#32-storage-operations","title":"3.2 Storage Operations","text":"<p>Location: <code>db/operations.py:save_time_priors()</code> (line 1000)</p> <p>Function Signature:</p> <pre><code>def save_time_priors(\n    db: AreaOccupancyDB,\n    area_name: str,\n    time_priors: dict[tuple[int, int], float],  # (day_of_week, time_slot) -&gt; prior_value\n    data_period_start: datetime,\n    data_period_end: datetime,\n    data_points_per_slot: dict[tuple[int, int], int],  # (day_of_week, time_slot) -&gt; weeks\n    calculation_method: str = \"interval_analysis\",\n) -&gt; bool:\n</code></pre> <p>Implementation Details:</p> <ul> <li>Processes all time priors in a single database transaction</li> <li>For each slot, checks if a record exists:</li> <li>If exists: Updates <code>prior_value</code>, <code>data_points</code>, <code>confidence</code>, <code>last_calculation_date</code>, <code>sample_period_start/end</code>, <code>calculation_method</code></li> <li>If new: Creates a new <code>Priors</code> record with all fields populated</li> <li>Calculates confidence as <code>min(1.0, data_points / 4.0)</code> where 4 weeks = full confidence</li> <li>Uses bulk operations for efficiency</li> <li>Returns <code>True</code> on success, <code>False</code> on error</li> <li>Logs debug information about number of slots saved/updated</li> </ul>"},{"location":"technical/time-prior-flow/#retrieval-at-runtime","title":"Retrieval at Runtime","text":""},{"location":"technical/time-prior-flow/#41-retrieval-flow","title":"4.1 Retrieval Flow","text":"<p>The time prior retrieval follows this path:</p> <ol> <li>Entry Point: <code>prior.py:Prior.time_prior</code> property (line 115)</li> <li>Called when calculating combined prior</li> <li> <p>Property getter that triggers retrieval if needed</p> </li> <li> <p>Cache Check: Checks if <code>_cached_time_priors</code> dictionary is populated (line 118)</p> </li> <li>If <code>None</code>, triggers <code>_load_time_priors()</code> to load all 168 slots from database</li> <li> <p>Cache stores all time priors as a dictionary: <code>(day_of_week, time_slot) -&gt; prior_value</code></p> </li> <li> <p>Load All Time Priors: <code>prior.py:_load_time_priors()</code> (line 161)</p> </li> <li>Calls <code>db.get_all_time_priors()</code> to retrieve all time priors for the area</li> <li>Loads all 168 slots in a single database query for efficiency</li> <li>Applies safety bounds [0.1, 0.9] to all values during loading</li> <li> <p>Falls back to default values if database query fails</p> </li> <li> <p>Database Method: <code>db/core.py:get_all_time_priors()</code> (line 304)</p> </li> <li>Wrapper that adds <code>entry_id</code> parameter</li> <li> <p>Calls query function</p> </li> <li> <p>Query Function: <code>queries.py:get_all_time_priors()</code> (line 111)</p> </li> <li>Queries <code>Priors</code> table filtered by:<ul> <li><code>entry_id</code>: Integration entry ID</li> <li><code>area_name</code>: Area name</li> </ul> </li> <li>Returns dictionary mapping <code>(day_of_week, time_slot)</code> to <code>prior_value</code></li> <li> <p>Fills in missing slots with <code>default_prior</code> (0.5) to ensure all 168 slots are present</p> </li> <li> <p>Get Current Slot: After cache is loaded, retrieves value for current day/slot (line 121-126)</p> </li> <li>Gets current <code>day_of_week</code> and <code>time_slot</code></li> <li>Looks up value in cached dictionary</li> <li> <p>Returns <code>DEFAULT_TIME_PRIOR</code> (0.5) if slot not found (shouldn't happen after <code>get_all_time_priors()</code>)</p> </li> <li> <p>Safety Bounds: Applied during <code>_load_time_priors()</code> (line 173-177)</p> </li> <li>Clamps all values to [TIME_PRIOR_MIN_BOUND, TIME_PRIOR_MAX_BOUND] = [0.1, 0.9]</li> <li>Prevents extreme values from affecting calculations</li> </ol>"},{"location":"technical/time-prior-flow/#42-time-slot-calculation","title":"4.2 Time Slot Calculation","text":"<p>Day of Week: <code>prior.py:day_of_week</code> property (line 156)</p> <ul> <li>Uses <code>dt_util.utcnow().weekday()</code></li> <li>Returns 0=Monday, 1=Tuesday, ..., 6=Sunday</li> </ul> <p>Time Slot: <code>prior.py:time_slot</code> property (line 161)</p> <ul> <li>Calculates: <code>(now.hour * 60 + now.minute) // DEFAULT_SLOT_MINUTES</code></li> <li><code>DEFAULT_SLOT_MINUTES = 60</code> (line 39)</li> <li>Returns 0-23 for hourly slots</li> </ul> <p>Example:</p> <pre><code># Monday at 14:30\nday_of_week = 0  # Monday\ntime_slot = (14 * 60 + 30) // 60 = 14  # 14:00-15:00 slot\n</code></pre>"},{"location":"technical/time-prior-flow/#43-caching-strategy","title":"4.3 Caching Strategy","text":"<p>Cache Structure: <code>_cached_time_priors</code> dictionary</p> <ul> <li>Stores all 168 time priors: <code>dict[tuple[int, int], float]</code></li> <li>Key: <code>(day_of_week, time_slot)</code> tuple</li> <li>Value: <code>prior_value</code> (already clamped to [0.1, 0.9])</li> <li>Loaded once per <code>Prior</code> instance lifecycle</li> </ul> <p>Cache Population:</p> <ul> <li>Loaded lazily on first access to <code>time_prior</code> property</li> <li>Loads all 168 slots in a single database query for efficiency</li> <li>Applied safety bounds during loading</li> </ul> <p>Cache Invalidation: <code>_invalidate_time_prior_cache()</code> (line 157)</p> <ul> <li>Called when global prior changes (<code>set_global_prior()</code>)</li> <li>Sets <code>_cached_time_priors = None</code> to force reload on next access</li> <li>Also called by <code>clear_cache()</code> method</li> </ul> <p>TTL: No time-based expiration</p> <ul> <li>Cache persists until invalidated (when global prior changes)</li> <li>Since all 168 slots are cached, no need to check day/slot on each access</li> <li>Simply looks up current slot in the cached dictionary</li> </ul> <p>Rationale: Loading all time priors at once is more efficient than individual queries. Time priors don't change frequently (only during analysis cycles), so caching all slots is safe and provides fast access.</p>"},{"location":"technical/time-prior-flow/#usage-in-probability-calculation","title":"Usage in Probability Calculation","text":""},{"location":"technical/time-prior-flow/#51-prior-combination","title":"5.1 Prior Combination","text":"<p>Location: <code>utils.py:combine_priors()</code> (line 329)</p> <p>Method: Weighted averaging in logit space</p> <p>Default Weight: <code>time_weight=0.2</code> (20% time prior, 80% global prior)</p> <p>Process:</p> <ol> <li>Handle edge cases (time_weight == 0.0 or 1.0)</li> <li>Handle extreme values (0.0 or 1.0) by converting to MIN/MAX_PROBABILITY</li> <li>Convert both priors to logit space: <code>logit(p) = log(p / (1-p))</code></li> <li>Calculate weighted average: <code>combined_logit = area_weight * area_logit + time_weight * time_logit</code></li> <li><code>area_weight = 1.0 - time_weight</code></li> <li>Convert back to probability: <code>combined_prior = 1 / (1 + exp(-combined_logit))</code></li> <li>Clamp to valid range [MIN_PROBABILITY, MAX_PROBABILITY]</li> </ol> <p>Why Logit Space?</p> <ul> <li>Logit space provides better interpolation for probabilities</li> <li>Prevents issues with extreme values</li> <li>More mathematically principled than linear interpolation</li> </ul> <p>Example:</p> <pre><code>area_prior = 0.3  # 30% occupancy overall\ntime_prior = 0.7  # 70% occupancy for this time slot\ntime_weight = 0.2  # 20% weight to time prior\n\n# Convert to logit space\narea_logit = log(0.3 / 0.7) \u2248 -0.847\ntime_logit = log(0.7 / 0.3) \u2248 0.847\n\n# Weighted average\ncombined_logit = 0.8 * (-0.847) + 0.2 * 0.847 \u2248 -0.508\n\n# Convert back\ncombined_prior = 1 / (1 + exp(0.508)) \u2248 0.375\n</code></pre>"},{"location":"technical/time-prior-flow/#52-integration-point","title":"5.2 Integration Point","text":"<p>Location: <code>prior.py:Prior.value</code> property (line 82)</p> <p>Flow:</p> <ol> <li>Gets <code>global_prior</code> from memory (<code>self.global_prior</code>)</li> <li>Gets <code>time_prior</code> via property (triggers retrieval if needed)</li> <li>Combines using <code>combine_priors()</code> if both exist:</li> <li>If <code>time_prior</code> is <code>None</code>, uses <code>global_prior</code> directly</li> <li>Otherwise combines: <code>combine_priors(global_prior, time_prior)</code></li> <li>Applies <code>PRIOR_FACTOR</code> (1.05) multiplier</li> <li>Slight bias towards occupancy (\"better safe than sorry\")</li> <li>Applies <code>min_prior_override</code> if configured</li> <li>Ensures minimum prior doesn't drop too low</li> </ol> <p>Code Flow:</p> <pre><code>@property\ndef value(self) -&gt; float:\n    if self.global_prior is None:\n        result = MIN_PRIOR\n    else:\n        if self.time_prior is None:\n            prior = self.global_prior\n        else:\n            prior = combine_priors(self.global_prior, self.time_prior)\n        # Apply factor and clamping\n        adjusted_prior = prior * PRIOR_FACTOR\n        result = max(MIN_PRIOR, min(MAX_PRIOR, adjusted_prior))\n\n    # Apply minimum override\n    if self.config.min_prior_override &gt; 0.0:\n        result = max(result, self.config.min_prior_override)\n\n    return result\n</code></pre>"},{"location":"technical/time-prior-flow/#code-flow-diagrams","title":"Code Flow Diagrams","text":""},{"location":"technical/time-prior-flow/#61-time-prior-retrieval-sequence","title":"6.1 Time Prior Retrieval Sequence","text":"<pre><code>sequenceDiagram\n    participant Area as Area Object\n    participant Prior as Prior Object\n    participant Cache as Cache Dict\n    participant DB as Database\n    participant Query as Query Function\n\n    Area-&gt;&gt;Prior: probability() calculation\n    Prior-&gt;&gt;Prior: value property\n    Prior-&gt;&gt;Prior: time_prior property\n    Prior-&gt;&gt;Cache: Check if _cached_time_priors is None\n\n    alt Cache Populated\n        Cache--&gt;&gt;Prior: Dictionary with all 168 slots\n        Prior-&gt;&gt;Prior: Get current (day, slot)\n        Prior-&gt;&gt;Cache: Lookup (day, slot)\n        Cache--&gt;&gt;Prior: prior_value for current slot\n    else Cache Empty (First Access)\n        Prior-&gt;&gt;Prior: _load_time_priors()\n        Prior-&gt;&gt;DB: get_all_time_priors(area_name)\n        DB-&gt;&gt;Query: get_all_time_priors(entry_id, area_name)\n        Query-&gt;&gt;Query: Query all Priors for area\n        Query--&gt;&gt;DB: Dictionary of all 168 slots\n        DB--&gt;&gt;Prior: Dictionary of all slots\n        Prior-&gt;&gt;Prior: Apply safety bounds [0.1, 0.9]\n        Prior-&gt;&gt;Cache: Store all 168 slots\n        Prior-&gt;&gt;Prior: Get current (day, slot)\n        Prior-&gt;&gt;Cache: Lookup (day, slot)\n        Cache--&gt;&gt;Prior: prior_value for current slot\n    end\n\n    Prior-&gt;&gt;Prior: combine_priors(global, time)\n    Prior--&gt;&gt;Area: Combined prior</code></pre>"},{"location":"technical/time-prior-flow/#62-time-prior-calculation-flow-when-implemented","title":"6.2 Time Prior Calculation Flow (When Implemented)","text":"<pre><code>flowchart TD\n    Start([Analysis Cycle]) --&gt; GetIntervals[Get Occupied Intervals]\n    GetIntervals --&gt; GroupSlots[Group by Day/Slot]\n    GroupSlots --&gt; ForEachSlot{For Each Slot&lt;br/&gt;168 total}\n\n    ForEachSlot --&gt; CalcOccupied[Calculate Occupied Seconds]\n    CalcOccupied --&gt; CalcTotal[Calculate Total Slot Seconds]\n    CalcTotal --&gt; CalcPercent[Calculate Percentage]\n    CalcPercent --&gt; ApplyBounds[Apply Safety Bounds&lt;br/&gt;[0.1, 0.9]]\n    ApplyBounds --&gt; StorePrior[Store in Priors Table]\n\n    StorePrior --&gt; MoreSlots{More Slots?}\n    MoreSlots --&gt;|Yes| ForEachSlot\n    MoreSlots --&gt;|No| Complete([Calculation Complete])</code></pre>"},{"location":"technical/time-prior-flow/#63-complete-prior-calculation-flow","title":"6.3 Complete Prior Calculation Flow","text":"<pre><code>flowchart TD\n    Start([Prior Calculation]) --&gt; GetIntervals[Get Occupied Intervals&lt;br/&gt;from Motion Sensors]\n    GetIntervals --&gt; CalcGlobal[Calculate Global Prior]\n    CalcGlobal --&gt; SaveGlobal[Save to GlobalPriors Table]\n\n    SaveGlobal --&gt; CalcTime[Calculate Time Priors]\n    CalcTime --&gt; GroupSlots[Group Intervals by&lt;br/&gt;Day of Week &amp; Time Slot]\n    GroupSlots --&gt; CalcSlots[Calculate Prior per Slot]\n    CalcSlots --&gt; SaveTime[Save to Priors Table]\n\n    SaveTime --&gt; Complete([Prior Calculation Complete])</code></pre>"},{"location":"technical/time-prior-flow/#implementation-notes","title":"Implementation Notes","text":""},{"location":"technical/time-prior-flow/#71-cache-invalidation-logic","title":"7.1 Cache Invalidation Logic","text":"<p>Issue: Cache only invalidated when global prior changes, not on time slot change</p> <p>Impact: Cache persists across time slots if global prior unchanged</p> <p>Current Behavior: Cache checked against current day/slot on each access, so cache is automatically refreshed when day/slot changes</p> <p>Analysis: This is actually correct behavior - the cache check ensures we always get the right value for the current time slot, even if the global prior hasn't changed.</p> <p>Recommendation: No change needed - current implementation is correct</p>"},{"location":"technical/time-prior-flow/#73-default-value-handling","title":"7.3 Default Value Handling","text":"<p>Issue: Missing time priors return <code>DEFAULT_TIME_PRIOR</code> (0.5) without metadata</p> <p>Impact: No way to distinguish \"no data\" from \"50% occupancy\"</p> <p>Current Behavior: Returns 0.5 for missing slots, which is reasonable default</p> <p>Recommendation: Consider adding metadata flag or logging when default is used, but current behavior is acceptable</p>"},{"location":"technical/time-prior-flow/#74-time-slot-granularity","title":"7.4 Time Slot Granularity","text":"<p>Issue: Fixed 60-minute slots may not match user schedules</p> <p>Impact: Less granular than ideal for precise time-based learning</p> <p>Current Behavior: 1-hour slots (24 slots per day \u00d7 7 days = 168 slots)</p> <p>Recommendation: Consider configurable slot duration in future, but 1-hour slots are reasonable default</p>"},{"location":"technical/time-prior-flow/#75-data-period-tracking","title":"7.5 Data Period Tracking","text":"<p>Status: <code>sample_period_start/end</code> fields are populated by <code>save_time_priors()</code> function</p> <p>Implementation: The calculation function passes the data period used for analysis, which is stored in the database for tracking and verification purposes.</p>"},{"location":"technical/time-prior-flow/#related-documentation","title":"Related Documentation","text":"<ul> <li>Database Schema - Complete database schema documentation</li> <li>Prior Learning - User-facing prior learning documentation</li> <li>Data Flow - Overall data flow diagrams</li> <li>Bayesian Calculation - How priors are used in calculations</li> </ul>"}]}