---
alwaysApply: true
---

All tests are written using pytest.

All tests are written in the `tests` directory.

The `conftest.py` file is used to configure the tests and contains the fixtures for the tests.

All fixtures should be defined in the conftest.py file.

Each module has its own test file. e.g. `tests/test_coordinator.py`.

Testing is done by running the command `pytest --cov=custom_components/area_occupancy --cov-report=xml --cov-report=term-missing`.

Test coverage is expected to be over 85%.

# Testing Guide for Area Occupancy Detection

This guide explains how to write and maintain tests for the Area Occupancy Detection component, with a focus on the multi-area architecture.

## Table of Contents

- [Architecture Overview](#architecture-overview)
- [Using pytest-homeassistant-custom-component](#using-pytest-homeassistant-custom-component)
- [Choosing the Right Fixtures](#choosing-the-right-fixtures)
- [Common Patterns](#common-patterns)
- [Area-Based Access](#area-based-access)
- [Database Connection Management](#database-connection-management)
- [Migration Guide](#migration-guide)
- [Examples](#examples)

## Architecture Overview

The component uses a **multi-area architecture** where:

- `AreaOccupancyCoordinator` manages multiple `Area` objects
- Each `Area` has its own `config`, `entities`, `prior`, and `purpose`
- Properties like `probability()`, `threshold()`, `device_info()` now take `area_name` parameter
- Access patterns: `coordinator.get_area_or_default(area_name).entities` instead of `coordinator.entities`

## Using pytest-homeassistant-custom-component

This project uses the [`pytest-homeassistant-custom-component`](https://pypi.org/project/pytest-homeassistant-custom-component/) package to provide proper Home Assistant test infrastructure. This package automatically provides fixtures for testing custom components.

### Key Fixtures from the Package

**`hass`** - Real Home Assistant instance for testing:

```python
def test_with_hass(hass: HomeAssistant):
    """Test using real Home Assistant instance."""
    # hass is a real HomeAssistant instance, not a mock
    assert hass is not None
    assert hass.states is not None
    assert hass.config_entries is not None
```

**`device_registry`** - Device registry fixture:

```python
async def test_device_registry(hass: HomeAssistant, device_registry):
    """Test using device registry."""
    # Create a device in the registry
    device_entry = device_registry.async_get_or_create(
        config_entry_id="test_entry_id",
        identifiers={("domain", "identifier")},
        name="Test Device",
    )
    assert device_entry is not None
```

**`entity_registry`** - Entity registry fixture:

```python
async def test_entity_registry(hass: HomeAssistant, entity_registry):
    """Test using entity registry."""
    # Access entity registry
    entities = entity_registry.entities
    assert entities is not None
```

**`enable_custom_integrations`** - Automatically enables custom integrations (autouse fixture):

This fixture is automatically applied to all tests, so you don't need to explicitly request it. It ensures that custom components can be loaded during tests.

### Import Requirements

When using the `hass` fixture, import `HomeAssistant` from `homeassistant.core`:

```python
from homeassistant.core import HomeAssistant

def test_something(hass: HomeAssistant):
    """Test using hass fixture."""
    # Use hass here
```

### Benefits of Using the Package

1. **Real Home Assistant Infrastructure** - Tests run against real Home Assistant components, not mocks
2. **Automatic Setup** - The package handles all the complex setup required for testing custom components
3. **Standard Fixtures** - Uses the same fixtures that Home Assistant core uses for testing
4. **Better Integration Testing** - Tests catch real-world issues that mocks might miss
5. **Device and Entity Registry Support** - Provides real registry fixtures for testing device/entity interactions

### Migration from Custom mock_hass

**We no longer use a custom `mock_hass` fixture.** All tests should use the `hass` fixture from `pytest-homeassistant-custom-component`:

```python
# OLD - Don't use this anymore
def test_something(mock_hass: Mock):
    mock_hass.states = Mock()
    # ...

# NEW - Use this instead
def test_something(hass: HomeAssistant):
    # hass already has states, config_entries, etc.
    # No need to mock them
```

## Choosing the Right Fixtures

### Real Coordinators vs Mock Coordinators

**We now prefer using real coordinators and databases in tests.** This provides better integration testing and catches real-world issues.

**Use `coordinator` when:**

- Integration-style tests that need real coordinator behavior
- Testing area loading and initialization
- You need areas to be automatically loaded from config
- Testing coordinator methods that interact with areas
- **This is the recommended default for most tests**

**Use `test_db` when:**

- Testing database operations directly
- Testing data persistence and loading
- Testing migration logic
- Testing database schema and models
- **This is the recommended primary fixture for database testing**

**Use `coordinator_with_db` when:**

- Testing database operations that need coordinator access
- Testing integration between coordinator and database
- You prefer accessing database via `coordinator.db`
- **This is a wrapper around `test_db` that returns the coordinator**

### Database Fixtures

**`test_db`** - Primary fixture for database testing (recommended):

```python
def test_db_operation(test_db: AreaOccupancyDB):
    """Test with real database instance."""
    db = test_db  # Real AreaOccupancyDB instance
    area_name = db.coordinator.get_area_names()[0]

    # Save data to database
    db.save_area_data(area_name)

    # Load data back
    await db.load_data()

    # Verify data persisted
    area_data = db.get_area_data(db.coordinator.entry_id)
    assert area_data is not None
```

**`db_test_session`** - Per-test database session with automatic rollback:

```python
def test_with_session(test_db: AreaOccupancyDB, db_test_session):
    """Test with direct session access."""
    session = db_test_session
    # Use session for direct database operations
    session.add(...)
    session.commit()
    # Changes are automatically rolled back after test
```

**`coordinator_with_db`** - Wrapper around `test_db` that returns the coordinator:

```python
def test_db_operation(coordinator_with_db: AreaOccupancyCoordinator):
    """Test with real coordinator and real database."""
    coordinator = coordinator_with_db
    db = coordinator.db  # Real AreaOccupancyDB instance
    area_name = coordinator.get_area_names()[0]

    # Save data to database
    db.save_area_data(area_name)

    # Load data back
    await db.load_data()

    # Verify data persisted
    area_data = db.get_area_data(coordinator.entry_id)
    assert area_data is not None
```

**`db_engine`** - In-memory SQLite engine for low-level database tests:

```python
def test_database_schema(db_engine):
    """Test database schema operations."""
    from sqlalchemy import inspect
    inspector = inspect(db_engine)
    tables = inspector.get_table_names()
    assert "areas" in tables
    assert "entities" in tables
```

**`db_session`** - Low-level database session (for tests that don't need AreaOccupancyDB):

```python
def test_low_level_operations(db_session):
    """Test with direct SQLAlchemy session."""
    # Use for testing ORM models directly
    session = db_session
    session.add(AreaOccupancyDB.Areas(...))
    session.commit()
```

### Database Connection Management

The database fixtures are designed to properly manage SQLite connections and prevent ResourceWarnings. All fixtures automatically handle connection cleanup:

**Connection Cleanup in Fixtures:**

- **`db_engine`**: Uses `StaticPool` for shared cache support and explicitly disposes of all connections in teardown
- **`test_db`**: Immediately disposes of the original engine created by `AreaOccupancyDB` to prevent connection leaks
- **`db_test_session`**: Properly closes sessions and invalidates connections after each test
- **`db_session`**: Closes sessions and invalidates connections with proper cleanup
- **`transactional_db_session`**: Ensures proper cleanup order (session → transaction → connection)

**ResourceWarnings in Python 3.13:**

Python 3.13 has stricter resource tracking and may emit `ResourceWarning` messages about unclosed SQLite connections. These warnings are handled in two ways:

1. **Fixture-level cleanup**: All database fixtures explicitly close connections and dispose of engines
2. **Pytest filterwarnings**: The `pyproject.toml` configuration includes filters to suppress remaining warnings that SQLAlchemy handles through its connection pooling

The warnings don't indicate actual connection leaks - SQLAlchemy's connection pooling properly manages connections, but Python 3.13's resource tracker is more aggressive about detecting unclosed resources.

**Best Practices:**

- Always use the provided fixtures - they handle connection cleanup automatically
- Don't manually create database engines or sessions in tests - use the fixtures
- If you need a custom session, use `db_test_session` which provides proper cleanup
- The fixtures ensure connections are closed even if tests fail

### Coordinator Fixtures

**`coordinator`** - Primary fixture for coordinator testing (recommended):

```python
def test_coordinator_method(coordinator: AreaOccupancyCoordinator):
    """Test coordinator with real areas."""
    area_name = coordinator.get_area_names()[0]
    area = coordinator.get_area_or_default(area_name)

    # Test coordinator methods that require area_name
    prob = coordinator.probability(area_name)
    assert 0.0 <= prob <= 1.0
```

**`coordinator_with_areas`** - Alias for `coordinator` fixture (backward compatibility):

```python
def test_coordinator_method(coordinator_with_areas: AreaOccupancyCoordinator):
    """Test coordinator with real areas."""
    # DEPRECATED: Use `coordinator` fixture instead.
    # This fixture is kept for backward compatibility.
    area_name = coordinator_with_areas.get_area_names()[0]
    area = coordinator_with_areas.get_area_or_default(area_name)

    # Test coordinator methods that require area_name
    prob = coordinator_with_areas.probability(area_name)
    assert 0.0 <= prob <= 1.0
```

**`coordinator_with_sensors`** - Real coordinator with mock entities set up:

```python
def test_sensor_entities(coordinator_with_sensors: AreaOccupancyCoordinator):
    """Test sensor entities with pre-configured mock entities."""
    area_name = coordinator_with_sensors.get_area_names()[0]
    area = coordinator_with_sensors.get_area_or_default(area_name)

    # Mock entities are already set up on the area
    assert "binary_sensor.motion" in area.entities.entities
    assert "media_player.tv" in area.entities.entities
```

**`coordinator_with_areas_with_sensors`** - Alias for `coordinator_with_sensors` fixture (backward compatibility):

```python
def test_sensor_entities(coordinator_with_areas_with_sensors: AreaOccupancyCoordinator):
    """Test sensor entities with pre-configured mock entities."""
    # DEPRECATED: Use `coordinator_with_sensors` fixture instead.
    # This fixture is kept for backward compatibility.
    area_name = coordinator_with_areas_with_sensors.get_area_names()[0]
    area = coordinator_with_areas_with_sensors.get_area_or_default(area_name)

    # Mock entities are already set up on the area
    assert "binary_sensor.motion" in area.entities.entities
```

### Area Fixtures

**`default_area`** - Easy access to the first area:

```python
def test_something(default_area):
    """Test using default area fixture."""
    assert default_area.area_name is not None
    assert default_area.config is not None
    assert default_area.entities is not None
```

This eliminates boilerplate like `coordinator.get_area_or_default()`.

**`mock_area`** - Standalone mock area (use sparingly):

```python
def test_area_behavior(mock_area):
    """Test area-specific logic with mock."""
    mock_area.config.threshold = 0.7
    # Test area-specific logic
```

## Common Patterns

### Pattern 1: Testing with Real Coordinator and Database

**Recommended pattern for most tests:**

```python
def test_db_operation(coordinator_with_db: AreaOccupancyCoordinator):
    """Test database operations with real coordinator and database."""
    coordinator = coordinator_with_db
    area_name = coordinator.get_area_names()[0]
    area = coordinator.get_area_or_default(area_name)

    # Use real database
    db = coordinator.db
    db.save_area_data(area_name)

    # Verify data persisted
    area_data = db.get_area_data(coordinator.entry_id)
    assert area_data is not None
    assert area_data["area_name"] == area_name
```

### Pattern 2: Testing with Real Coordinator (No Database)

```python
def test_coordinator_method(
    hass: HomeAssistant,
    coordinator: AreaOccupancyCoordinator
):
    """Test coordinator method with real areas loaded."""
    area_name = coordinator.get_area_names()[0]
    area = coordinator.get_area_or_default(area_name)

    # Test coordinator methods
    prob = coordinator.probability(area_name)
    assert 0.0 <= prob <= 1.0

    threshold = coordinator.threshold(area_name)
    assert threshold == area.config.threshold
```

### Pattern 2a: Testing Device Registry Interactions

```python
async def test_device_registry_interaction(
    hass: HomeAssistant,
    device_registry,
    config_flow_options_flow
):
    """Test config flow with device registry."""
    flow = config_flow_options_flow

    # Create a device in the registry
    device_entry = device_registry.async_get_or_create(
        config_entry_id=flow.config_entry.entry_id,
        identifiers={(DOMAIN, "Test Area")},
        name="Test Area",
    )

    # Use device_id in flow
    flow._device_id = device_entry.id
    result = await flow.async_step_init()
    assert result["type"] == FlowResultType.FORM
```

### Pattern 3: Testing with Default Area

```python
def test_area_properties(default_area):
    """Test area properties using default_area fixture."""
    assert default_area.config.threshold == 0.5
    assert default_area.entities is not None
    assert default_area.prior is not None
```

### Pattern 4: Testing Sensor Entities

```python
def test_sensor_with_mock_entities(coordinator_with_sensors: AreaOccupancyCoordinator):
    """Test sensors with pre-configured mock entities."""
    area_name = coordinator_with_sensors.get_area_names()[0]
    area = coordinator_with_sensors.get_area_or_default(area_name)

    # Mock entities are already set up
    assert "binary_sensor.motion" in area.entities.entities
    motion_entity = area.entities.get_entity("binary_sensor.motion")
    assert motion_entity.evidence is True
```

### Pattern 5: Testing Database Operations

**Using `test_db` (recommended):**

```python
async def test_load_data(test_db: AreaOccupancyDB):
    """Test loading data from database."""
    db = test_db
    area_name = db.coordinator.get_area_names()[0]
    area = db.coordinator.get_area_or_default(area_name)

    # Save some test data
    db.save_area_data(area_name)

    # Load data back
    await db.load_data()

    # Verify data was loaded
    assert area.prior.global_prior is not None
```

**Using `coordinator_with_db` (alternative):**

```python
async def test_load_data(coordinator_with_db: AreaOccupancyCoordinator):
    """Test loading data from database."""
    coordinator = coordinator_with_db
    db = coordinator.db
    area_name = coordinator.get_area_names()[0]

    # Save some test data
    db.save_area_data(area_name)

    # Load data back
    await db.load_data()

    # Verify data was loaded
    area = coordinator.get_area_or_default(area_name)
    assert area.prior.global_prior is not None
```

**Using `db_test_session` for direct session access:**

```python
def test_direct_session_operations(test_db: AreaOccupancyDB, db_test_session):
    """Test with direct database session access."""
    session = db_test_session

    # Direct ORM operations
    area = AreaOccupancyDB.Areas(
        entry_id=test_db.coordinator.entry_id,
        area_name="Test Area",
        threshold=0.5
    )
    session.add(area)
    session.commit()

    # Verify
    retrieved = session.query(AreaOccupancyDB.Areas).first()
    assert retrieved.area_name == "Test Area"
    # Changes automatically rolled back after test
```

### Pattern 6: Creating Custom Areas

```python
def test_custom_area(coordinator: AreaOccupancyCoordinator):
    """Create a custom area for testing."""
    area = create_test_area(
        coordinator,
        area_name="Kitchen",
        entity_ids=["binary_sensor.motion1"],
        threshold=0.6
    )
    assert area.area_name == "Kitchen"
    assert area.config.threshold == 0.6
```

### Pattern 7: Patching Area Methods That Survive Reloads

```python
def test_async_update_options(coordinator: AreaOccupancyCoordinator):
    """Test async_update_options which reloads areas."""
    from custom_components.area_occupancy.area.area import Area

    with patch_area_method(Area, "async_cleanup", AsyncMock()) as mock_cleanup:
        await coordinator.async_update_options({"threshold": 0.7})
        mock_cleanup.assert_called()
```

### Pattern 8: Mocking Coordinator Methods

When using real coordinators, you can still mock specific methods:

```python
def test_with_mocked_method(coordinator: AreaOccupancyCoordinator):
    """Test with specific coordinator method mocked."""
    area_name = coordinator.get_area_names()[0]

    # Mock a specific method
    with patch.object(
        coordinator,
        "probability",
        return_value=0.75
    ) as mock_prob:
        prob = coordinator.probability(area_name)
        assert prob == 0.75
        mock_prob.assert_called_once_with(area_name)
```

## Area-Based Access

### Always Use Area-Based Access

**Correct:**

```python
area = coordinator.get_area_or_default("Test Area")
entities = area.entities.entities
config = area.config
prior = area.prior
```

**Incorrect:**

```python
# DON'T: Direct coordinator access (deprecated)
entities = coordinator.entities.entities  # May not work in all cases
config = coordinator.config  # Deprecated, use area.config
```

### Accessing Multiple Areas

```python
def test_multiple_areas(coordinator_with_areas: AreaOccupancyCoordinator):
    """Test with multiple areas."""
    area_names = coordinator_with_areas.get_area_names()
    for area_name in area_names:
        area = coordinator_with_areas.get_area_or_default(area_name)
        assert area is not None
        assert area.area_name == area_name
```

## Database Connection Management

### Overview

Python 3.13 has stricter resource tracking and may emit `ResourceWarning` messages about unclosed SQLite connections during test execution. The database fixtures are designed to properly manage connections and prevent these warnings.

### How Fixtures Handle Connections

**`db_engine` fixture:**

- Uses `StaticPool` for shared cache support (required for in-memory SQLite with multiple connections)
- Explicitly disposes of all connections in teardown with `engine.dispose(close=True)`
- Closes pool connections before disposing

**`test_db` fixture:**

- Immediately disposes of the original engine created by `AreaOccupancyDB.__init__` to prevent connection leaks
- Overrides the engine with the test engine before any operations
- Ensures no connections are opened on the original engine

**Session fixtures (`db_test_session`, `db_session`, `transactional_db_session`):**

- Properly rollback and close sessions
- Expunge all objects before closing to ensure cleanup
- Invalidate bound connections when available
- Maintain proper cleanup order (session → transaction → connection)

### ResourceWarnings Configuration

The `pyproject.toml` includes pytest filterwarnings to suppress SQLite connection warnings:

```toml
filterwarnings = [
  # -- SQLite connection warnings in tests
  # Python 3.13 is very strict about unclosed resources. SQLite connections
  # created during test setup/teardown may not be immediately closed, but
  # they are properly cleaned up by SQLAlchemy's connection pooling.
  "ignore::ResourceWarning:.*sqlite3.Connection",
  "ignore:unclosed.*database.*sqlite3.Connection:ResourceWarning",
  "ignore:unclosed database:ResourceWarning",
  # ...
]
```

**Why suppress these warnings?**

- SQLAlchemy's connection pooling properly manages connections
- Python 3.13's resource tracker detects connections before SQLAlchemy's cleanup runs
- The fixtures ensure all connections are properly closed, but the warnings may appear during test execution
- These warnings don't indicate actual connection leaks

### Best Practices

1. **Always use the provided fixtures** - They handle connection cleanup automatically
2. **Don't manually create engines or sessions** - Use the fixtures instead
3. **Use context managers** - When accessing database directly, use `with db.get_session()` to ensure proper cleanup
4. **Trust the fixtures** - The fixtures are designed to prevent connection leaks

### Troubleshooting Connection Warnings

If you see ResourceWarnings despite using the fixtures:

1. **Verify fixture usage** - Ensure you're using `test_db` or `coordinator_with_db` for database tests
2. **Check for manual engine creation** - Don't create engines or sessions outside the fixtures
3. **Use context managers** - Always use `with db.get_session()` when accessing the database directly
4. **Review pytest configuration** - The `pyproject.toml` should include the ResourceWarning filters

## Migration Guide

### Migrating from Mock Coordinators to Real Coordinators

**We now prefer real coordinators and databases in tests.** Here's how to migrate:

### Step-by-Step Migration

1. **Use `coordinator` fixture for all coordinator tests:**

   ```python
   def test_something(coordinator: AreaOccupancyCoordinator):
       area_name = coordinator.get_area_names()[0]
       area = coordinator.get_area_or_default(area_name)
       area.entities.entities = {...}
       area.config.threshold = 0.5
       # Test code
   ```

2. **Replace coordinator property access with area-based access:**

   ```python
   # Before
   coordinator.entities.entities
   coordinator.config.threshold
   coordinator.probability  # Direct property access

   # After
   area_name = coordinator.get_area_names()[0]
   area = coordinator.get_area_or_default(area_name)
   area.entities.entities
   area.config.threshold
   coordinator.probability(area_name)  # Method call with area_name
   ```

3. **Use `default_area` fixture to reduce boilerplate:**

   ```python
   # Before
   def test_something(coordinator: AreaOccupancyCoordinator):
       area_name = coordinator.get_area_names()[0]
       area = coordinator.get_area_or_default(area_name)
       # Test code

   # After
   def test_something(default_area):
       # area is already available as default_area
       # Test code
   ```

4. **Replace mock database with real database:**

   ```python
   # Before
   def test_db_operation(mock_db: Mock):
       mock_db.save_data.return_value = None
       # Test code

   # After (using test_db - recommended)
   async def test_db_operation(test_db: AreaOccupancyDB):
       db = test_db  # Real database
       area_name = db.coordinator.get_area_names()[0]
       db.save_area_data(area_name)
       # Test code

   # After (using coordinator_with_db - alternative)
   async def test_db_operation(coordinator_with_db: AreaOccupancyCoordinator):
       coordinator = coordinator_with_db
       db = coordinator.db  # Real database
       area_name = coordinator.get_area_names()[0]
       db.save_area_data(area_name)
       # Test code
   ```

5. **Update coordinator method calls to include `area_name`:**

   ```python
   # Before
   prob = coordinator.probability  # Property access
   threshold = coordinator.threshold  # Property access

   # After
   area_name = coordinator.get_area_names()[0]
   prob = coordinator.probability(area_name)  # Method call
   threshold = coordinator.threshold(area_name)  # Method call
   ```

6. **Update mocks for coordinator methods:**

   ```python
   # For coordinator methods, patch the area methods they delegate to
   area_name = coordinator.get_area_names()[0]
   area = coordinator.get_area_or_default(area_name)
   with patch.object(area, "probability", return_value=0.5):
       prob = coordinator.probability(area_name)
   # Or patch coordinator methods directly
   with patch.object(coordinator, "threshold", return_value=0.6):
       threshold = coordinator.threshold(area_name)
   ```

### Common Migration Patterns

**Pattern 1: Entity Access**

```python
# Before
coordinator.entities.entities["binary_sensor.motion"] = mock_entity

# After
area_name = coordinator_with_areas.get_area_names()[0]
area = coordinator_with_areas.get_area_or_default(area_name)
area.entities.entities["binary_sensor.motion"] = mock_entity
# Or use default_area fixture:
# default_area.entities.entities["binary_sensor.motion"] = mock_entity
```

**Pattern 2: Config Access**

```python
# Before
coordinator.config.threshold = 0.7

# After
area_name = coordinator_with_areas.get_area_names()[0]
area = coordinator_with_areas.get_area_or_default(area_name)
area.config.threshold = 0.7
```

**Pattern 3: Database Operations**

```python
# Before
mock_db.save_data.return_value = None
mock_db.load_data = AsyncMock(return_value=None)

# After (using test_db - recommended)
async def test_db(test_db: AreaOccupancyDB):
    db = test_db
    area_name = db.coordinator.get_area_names()[0]
    db.save_area_data(area_name)
    await db.load_data()

# After (using coordinator_with_db - alternative)
async def test_db(coordinator_with_db: AreaOccupancyCoordinator):
    coordinator = coordinator_with_db
    db = coordinator.db
    area_name = coordinator.get_area_names()[0]
    db.save_area_data(area_name)
    await db.load_data()
```

## Examples

### Example 1: Testing Coordinator Setup

```python
async def test_setup_loads_areas(
    hass: HomeAssistant,
    coordinator: AreaOccupancyCoordinator
):
    """Test that setup loads areas correctly."""
    area_names = coordinator.get_area_names()
    assert len(area_names) > 0

    for area_name in area_names:
        area = coordinator.get_area_or_default(area_name)
        assert area is not None
        assert area.config is not None
        assert area.entities is not None
```

### Example 2: Testing Database Operations

**Using `test_db` (recommended):**

```python
async def test_save_and_load_data(test_db: AreaOccupancyDB):
    """Test saving and loading data from database."""
    db = test_db
    area_name = db.coordinator.get_area_names()[0]
    area = db.coordinator.get_area_or_default(area_name)

    # Set some test data
    area.prior.set_global_prior(0.75)

    # Save to database
    db.save_area_data(area_name)

    # Clear area prior to simulate reload
    area.prior.global_prior = None

    # Load data back
    await db.load_data()

    # Verify data was restored
    assert area.prior.global_prior == 0.75
```

**Using `coordinator_with_db` (alternative):**

```python
async def test_save_and_load_data(coordinator_with_db: AreaOccupancyCoordinator):
    """Test saving and loading data from database."""
    coordinator = coordinator_with_db
    db = coordinator.db
    area_name = coordinator.get_area_names()[0]
    area = coordinator.get_area_or_default(area_name)

    # Set some test data
    area.prior.set_global_prior(0.75)

    # Save to database
    db.save_area_data(area_name)

    # Clear area prior to simulate reload
    area.prior.global_prior = None

    # Load data back
    await db.load_data()

    # Verify data was restored
    assert area.prior.global_prior == 0.75
```

### Example 3: Testing Area-Specific Properties

```python
def test_area_threshold(default_area):
    """Test area threshold property."""
    default_area.config.threshold = 0.7
    assert default_area.config.threshold == 0.7

    # Test coordinator method reflects area config
    area_name = default_area.area_name
    coordinator = default_area.coordinator
    assert coordinator.threshold(area_name) == 0.7
```

### Example 4: Testing Entity Management

```python
def test_entity_access(default_area):
    """Test accessing entities through area."""
    # Add a test entity
    mock_entity = Mock()
    mock_entity.entity_id = "binary_sensor.test"
    default_area.entities.entities["binary_sensor.test"] = mock_entity

    # Access via area
    entity = default_area.entities.get_entity("binary_sensor.test")
    assert entity is not None
    assert entity.entity_id == "binary_sensor.test"
```

### Example 5: Testing Coordinator Methods

```python
def test_probability_method(
    hass: HomeAssistant,
    coordinator: AreaOccupancyCoordinator
):
    """Test probability method with area_name."""
    area_name = coordinator.get_area_names()[0]
    prob = coordinator.probability(area_name)
    assert 0.0 <= prob <= 1.0

    # Test device_info method
    device_info = coordinator.device_info(area_name)
    assert device_info is not None
    assert device_info["identifiers"] == {(DOMAIN, area_name)}
```

### Example 9: Testing Config Flow with Device Registry

```python
async def test_config_flow_with_device_registry(
    hass: HomeAssistant,
    device_registry,
    config_flow_options_flow
):
    """Test config flow when called from device registry."""
    flow = config_flow_options_flow

    # Create a device in the registry
    device_entry = device_registry.async_get_or_create(
        config_entry_id=flow.config_entry.entry_id,
        identifiers={(DOMAIN, "Test Area")},
        name="Test Area",
    )

    # Update flow's device_id to match the created device
    flow._device_id = device_entry.id

    result = await flow.async_step_init()
    assert result["type"] == FlowResultType.FORM
    assert result["step_id"] == "area_config"
    assert flow._area_being_edited == "Test Area"
```

### Example 6: Testing Sensor Entities

```python
def test_sensor_with_mock_entities(coordinator_with_sensors: AreaOccupancyCoordinator):
    """Test sensor entities with pre-configured mock entities."""
    area_name = coordinator_with_sensors.get_area_names()[0]
    area = coordinator_with_sensors.get_area_or_default(area_name)

    # Mock entities are already set up
    assert "binary_sensor.motion" in area.entities.entities
    assert "media_player.tv" in area.entities.entities

    # Test sensor calculations
    prob = coordinator_with_sensors.probability(area_name)
    assert prob > 0.0
```

### Example 7: Testing with Multiple Areas

```python
def test_multiple_areas(coordinator: AreaOccupancyCoordinator):
    """Test coordinator with multiple areas."""
    # Create additional area
    area2 = create_test_area(
        coordinator,
        area_name="Kitchen",
        entity_ids=["binary_sensor.kitchen_motion"]
    )

    # Verify both areas exist
    area_names = coordinator.get_area_names()
    assert len(area_names) == 2
    assert "Testing" in area_names  # Default area name
    assert "Kitchen" in area_names
```

### Example 8: Testing Database Entity Operations

**Using `test_db` (recommended):**

```python
async def test_save_entity_data(test_db: AreaOccupancyDB):
    """Test saving entity data to database."""
    db = test_db
    area_name = db.coordinator.get_area_names()[0]
    area = db.coordinator.get_area_or_default(area_name)

    # Set up entities on the area
    area._entities = SimpleNamespace(
        entities={
            "binary_sensor.motion": Mock(entity_id="binary_sensor.motion", ...)
        }
    )

    # Save entity data
    db.save_entity_data()

    # Verify entity was saved using db_test_session
    with db.get_locked_session() as session:
        entity = session.query(db.Entities).filter_by(
            area_name=area_name,
            entity_id="binary_sensor.motion"
        ).first()
        assert entity is not None
```

**Using `db_test_session` for direct session access:**

```python
def test_entity_operations(test_db: AreaOccupancyDB, db_test_session):
    """Test entity operations with direct session."""
    session = db_test_session
    area_name = test_db.coordinator.get_area_names()[0]

    # Create entity directly
    entity = AreaOccupancyDB.Entities(
        entry_id=test_db.coordinator.entry_id,
        area_name=area_name,
        entity_id="binary_sensor.motion",
        entity_type="motion"
    )
    session.add(entity)
    session.commit()

    # Verify
    retrieved = session.query(AreaOccupancyDB.Entities).first()
    assert retrieved.entity_id == "binary_sensor.motion"
    # Changes automatically rolled back after test
```

## Best Practices

1. **Prefer real coordinators and databases** - Use `coordinator` and `test_db` over mocks when possible
2. **Always use area-based access** - Prefer `area.entities` over `coordinator.entities`
3. **Use fixtures** - Leverage `coordinator`, `test_db`, `coordinator_with_db`, and `default_area` to reduce boilerplate
4. **Patch at class level** - Use `patch_area_method()` for methods that need to survive area reloads
5. **Be explicit** - Use `area_name` parameter when calling coordinator methods
6. **Test isolation** - Each test should set up its own areas if needed
7. **Use real databases for DB tests** - Prefer `test_db` or `coordinator_with_db` over `mock_db` for database operation tests
8. **Mock only when necessary** - Use mocks for error cases or when real behavior is too complex
9. **Get area_name dynamically** - Always get `area_name` from `coordinator.get_area_names()[0]` rather than hardcoding
10. **Use `coordinator_with_sensors`** - For sensor tests that need pre-configured entities
11. **Use `test_db` for database tests** - This is the primary fixture for database testing, providing proper session management and isolation
12. **Let fixtures handle connection cleanup** - Don't manually create engines or sessions; use the provided fixtures which handle cleanup automatically
13. **Use context managers for sessions** - When accessing database directly, use `with db.get_session()` to ensure proper cleanup

## Troubleshooting

### Issue: "Area name is required in multi-area architecture"

**Solution:** Ensure you're passing `area_name` to methods that require it, or use `coordinator.get_area_or_default()` first.

### Issue: Patched methods don't work after area reload

**Solution:** Use `patch_area_method()` context manager instead of `patch.object()` on instance.

### Issue: `coordinator.entities` is None

**Solution:** Access entities via area: `area = coordinator.get_area_or_default(); area.entities`

### Issue: `TypeError: 'Mock' object is not callable`

**Solution:** Coordinator methods are now callables that take `area_name`. Mock them as callables:

```python
coordinator.probability = Mock(return_value=0.5)
prob = coordinator.probability(area_name)  # Must call with area_name
```

### Issue: `AttributeError: 'AreaOccupancyCoordinator' object has no attribute 'config'`

**Solution:** Access config via area: `area = coordinator.get_area_or_default(); area.config`

### Issue: Database tests failing with real coordinator

**Solution:** Use `test_db` or `coordinator_with_db` fixture instead of `mock_db`. These provide a real database with proper session management and isolation.

### Issue: Tests accessing `coordinator.entities` directly

**Solution:** Update to use area-based access: `area = coordinator.get_area_or_default(); area.entities`

### Issue: Hardcoded area names in tests

**Solution:** Always get area name dynamically: `area_name = coordinator.get_area_names()[0]`

### Issue: ResourceWarnings about unclosed database connections

**Solution:** The database fixtures automatically handle connection cleanup. If you see ResourceWarnings:

1. **Ensure you're using the provided fixtures** - Don't manually create engines or sessions
2. **Check pytest filterwarnings** - The `pyproject.toml` includes filters for SQLite connection warnings
3. **Verify fixture teardown** - All fixtures properly dispose of engines and close sessions
4. **Python 3.13 strictness** - Python 3.13 is very strict about resource tracking; the warnings are suppressed via pytest configuration

The warnings don't indicate actual leaks - SQLAlchemy's connection pooling handles connections correctly, but Python 3.13's resource tracker detects them before SQLAlchemy's cleanup runs.

**If warnings persist:**

- Check that you're not creating additional engines or sessions outside the fixtures
- Ensure all database operations use the context managers (`with db.get_session()`)
- Verify that `test_db` fixture is being used (it disposes the original engine immediately)

### Issue: Tests failing with "hass fixture not found"

**Solution:** Ensure you're importing `HomeAssistant` and requesting the `hass` fixture:

```python
from homeassistant.core import HomeAssistant

def test_something(hass: HomeAssistant):
    """Test with hass fixture."""
    # Use hass here
```

### Issue: Device registry tests hanging or failing

**Solution:** Use the `device_registry` fixture from `pytest-homeassistant-custom-component` instead of manually mocking:

```python
# OLD - Don't do this
with patch.object(dr, "async_get", return_value=mock_device_registry):
    # ...

# NEW - Use the fixture
async def test_device(hass: HomeAssistant, device_registry):
    device_entry = device_registry.async_get_or_create(...)
    # ...
```

## Fixture Reference

### Core Fixtures from pytest-homeassistant-custom-component

- **`hass`** - Real Home Assistant instance (from `pytest-homeassistant-custom-component`)
- **`device_registry`** - Device registry fixture (from `pytest-homeassistant-custom-component`)
- **`entity_registry`** - Entity registry fixture (from `pytest-homeassistant-custom-component`)
- **`enable_custom_integrations`** - Autouse fixture that enables custom integrations (from `pytest-homeassistant-custom-component`)

### Custom Fixtures (from conftest.py)

- **`mock_config_entry`** - Mock config entry with default values
- **`mock_realistic_config_entry`** - Mock config entry with realistic multi-area configuration
- **`coordinator`** - Primary fixture for coordinator testing (recommended default)
- **`coordinator_with_areas`** - Alias for `coordinator` fixture (backward compatibility, DEPRECATED)
- **`coordinator_with_db`** - Real coordinator with real database (wrapper around `test_db`)
- **`coordinator_with_sensors`** - Real coordinator with mock entities pre-configured
- **`coordinator_with_areas_with_sensors`** - Alias for `coordinator_with_sensors` fixture (backward compatibility, DEPRECATED)
- **`default_area`** - First area from `coordinator` (convenience fixture)

### Database Fixtures

- **`test_db`** - Primary fixture for database testing (recommended) - provides real AreaOccupancyDB with in-memory SQLite
  - Automatically disposes of original engine to prevent connection leaks
  - Uses test engine with proper session management
  - All connections are properly closed in teardown
- **`db_test_session`** - Per-test database session with automatic rollback (for direct session access)
  - Properly closes sessions and invalidates connections
  - Expunges all objects before closing
- **`coordinator_with_db`** - Wrapper around `test_db` that returns the coordinator (for tests needing coordinator access)
- **`db_engine`** - In-memory SQLite engine for low-level database tests
  - Uses `StaticPool` for shared cache support
  - Explicitly disposes of all connections in teardown
- **`db_session`** - Low-level database session (for tests that don't need AreaOccupancyDB wrapper)
  - Properly closes sessions and invalidates connections
- **`transactional_db_session`** - Database session with nested transaction for maximum isolation
  - Ensures proper cleanup order (session → transaction → connection)

**Connection Management:**

All database fixtures are designed to prevent ResourceWarnings by:

- Explicitly disposing of engines with `engine.dispose(close=True)`
- Closing all sessions and invalidating connections
- Using proper cleanup order in teardown
- Immediately disposing of original engines when overriding with test engines

### Entity Fixtures

- **`mock_entity`** - Mock entity instance
- **`mock_active_entity`** - Mock entity in active state
- **`mock_inactive_entity`** - Mock entity in inactive state
- **`mock_decay`** - Mock decay instance

### Other Fixtures

- **`mock_area`** - Standalone mock area
- **`mock_entity_manager`** - Mock entity manager
- **`mock_entity_registry`** - Mock entity registry
- **`freeze_time`** - Freeze time for consistent testing

## Additional Resources

### Package Documentation

- [pytest-homeassistant-custom-component on PyPI](https://pypi.org/project/pytest-homeassistant-custom-component/)
- [Package GitHub Repository](https://github.com/MatthewFlamm/pytest-homeassistant-custom-component)

### Project Files

- See `tests/conftest.py` for all available fixtures and their implementations
- See existing test files for examples of patterns:
  - `tests/test_coordinator.py` - Coordinator tests with real coordinators and `hass` fixture
  - `tests/test_config_flow.py` - Config flow tests with `hass` and `device_registry` fixtures
  - `tests/test_db.py` - Database tests with `test_db` fixture
  - `tests/test_sensor.py` - Sensor tests with `coordinator_with_sensors` and `hass`
  - `tests/test_service.py` - Service tests with real coordinators and `hass`
  - `tests/test_binary_sensor.py` - Binary sensor tests with `hass` fixture
- Check `custom_components/area_occupancy/coordinator.py` for coordinator API
- Check `custom_components/area_occupancy/db.py` for database API

### Installation

The package is installed as a test dependency. Ensure it's in your `requirements_test.txt`:

```
pytest-homeassistant-custom-component>=0.10.0
```
